


```{r}
library(simmer)

set.seed(1234)

customer <-
  trajectory("Customer's path") %>%
  seize("counter") %>%
  timeout(function() {rexp(1, 1/12)}) %>%
  release("counter")

bank <-
  simmer("bank") %>%
  add_resource("counter", 2) %>%
  add_generator("Customer", customer, function() {c(0, rexp(4, 1/10), -1)}, 2)

bank %>% run(until = 400)

```

```{r}
bank %>% get_mon_arrivals()
```


```{r}
bank %>% get_mon_attributes()
```

```{r}
bank %>% get_mon_resources()
```


# Add in logging

Let's increase the frequency of arrivals and the duration of counter usage too.


```{r}
library(simmer)
library(testthat)

set.seed(1234)

simmer_logs <- ""

simmer_logs <- capture_output({
print("first_line,to_discard,,,")

customer <-
  trajectory("Customer's path") %>%
  log_("arrival_departure,arrival,") %>%
  log_("queue,queue_counter,") %>%
  seize("counter") %>%
  log_("resource_use,counter_use_start,counter") %>%
  timeout(function() {rexp(1, 1/20)}) %>%
  log_("resource_use_end,counter_use_end,counter") %>%
  log_("arrival_departure,depart,") %>%
  release("counter")

bank <-
  simmer("bank") %>%
  add_resource("counter", 2) %>%
  add_generator("Customer", customer, function() {c(0, rexp(50, 1/15), -1)}, 2)

bank %>% run(until = 400)

})

```

```{r}
simmer_logs
```

```{r}
# Clean the strings using two substitutions
# First, replace the colon after the timestamp. sub() only replaces the first match.
cleaned_lines <- gsub(pattern = ": ", replacement = ",", x = simmer_logs)
# Second, remove the extra ': 0,' after the customer ID
cleaned_lines <- gsub(pattern = ": 0,", replacement = ",", x = cleaned_lines)
```

```{r}
cleaned_lines
```


```{r}
# Read the cleaned character vector directly into a data frame
log_df <- read.csv(
  text = cleaned_lines,
  header = FALSE,
  col.names = c("time","entity_id","event_type","event","resource")
)

# Discard the sacrifical row
log_df <- log_df %>% tail(-1)

log_df
```

```{r}
bank %>% get_mon_resources()
```

```{r}
assign_server_assignments <- function(df) {
  df$assigned_server <- NA

  # State: whether each server is busy
  server_busy <- c(FALSE, FALSE)
  # Queue of which server is working on each active job (for FIFO releases)
  active_jobs <- c()

  for (i in seq_len(nrow(df))) {
    prev_busy_count <- if (i == 1) 0 else df$server[i - 1]
    current_busy_count <- df$server[i]

    # Releases first
    if (current_busy_count < prev_busy_count) {
      releases <- prev_busy_count - current_busy_count
      # Remove from the front of the queue
      for (r in seq_len(releases)) {
        if (length(active_jobs) > 0) {
          released <- active_jobs[1]
          active_jobs <- active_jobs[-1]
          server_busy[released] <- FALSE
        }
      }
    }

    # New assignments
    if (current_busy_count > prev_busy_count) {
      new_assignments <- current_busy_count - prev_busy_count
      for (a in seq_len(new_assignments)) {
        # First available server in numerical order
        avail <- which(!server_busy)[1]
        if (length(avail) > 0) {
          server_busy[avail] <- TRUE
          active_jobs <- c(active_jobs, avail)
          df$assigned_server[i] <- avail
        }
      }
    }
  }

  df
}

resource_usage_raw <- bank %>% get_mon_resources()
resource_usage <- assign_server_assignments(resource_usage_raw)

resource_usage
```


```{r}
library(readr)
library(here)
library(glue)

resource_usage %>% readr::write_csv(glue("{here::here()}/examples/r_simmer/resources.csv"))
log_df %>% readr::write_csv(glue("{here::here()}/examples/r_simmer/logs.csv"))
```
