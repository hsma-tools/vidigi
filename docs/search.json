[
  {
    "objectID": "vidigi_docs/vidigi_vs_bupar.html",
    "href": "vidigi_docs/vidigi_vs_bupar.html",
    "title": "Vidigi vs BupaR",
    "section": "",
    "text": "The title of this section is perhaps misleading! As the author of the package, I think the visuals produced by the two packages occupy slightly different niches, and the use of both can benefit your project.\nAs an additional bonus, the process of creating the logs you require for a vidigi project give you the perfect dataset for your bupaR visuals too!\nbupaR outputs could form part of a verification and validation strategy. They can also perform part of your communications strategy, helping to provide a talking point for meetings with stakeholders in much the same way as a screenshot of your Simul8 or Anylogic model would. In the absence of a graphical interface for building a model, the bupar outputs can help you - and your stakeholders - to ensure that linkages between different model steps are sensible and appropriate.",
    "crumbs": [
      "Miscellaneous",
      "Vidigi vs BupaR"
    ]
  },
  {
    "objectID": "vidigi_docs/vidigi_vs_bupar.html#the-python-preprocesing",
    "href": "vidigi_docs/vidigi_vs_bupar.html#the-python-preprocesing",
    "title": "Vidigi vs BupaR",
    "section": "The Python Preprocesing",
    "text": "The Python Preprocesing\nWe will begin in Python, working to add a couple of columns to our vidigi event log to prepare it for use in bupaR.\n\nfrom examples.example_2_branching_multistep.ex_2_model_classes import Trial, g\nimport pandas as pd\nimport os\n\n#| echo: true\n\ng.sim_duration = 3000\ng.number_of_runs = 1\n\n\n\n\n\n\n\nView Imported Code, which has had logging steps added at the appropriate points in the ‘model’ class\n\n\n\n\n\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\nfrom sim_tools.distributions import Exponential, Lognormal, Uniform, Normal, Bernoulli\nfrom vidigi.resources import populate_store\nfrom examples.simulation_utility_functions import trace\n\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    '''\n    Create a scenario to parameterise the simulation model\n\n    Parameters:\n    -----------\n    random_number_set: int, optional (default=DEFAULT_RNG_SET)\n        Set to control the initial seeds of each stream of pseudo\n        random numbers used in the model.\n\n    n_triage: int\n        The number of triage cubicles\n\n    n_reg: int\n        The number of registration clerks\n\n    n_exam: int\n        The number of examination rooms\n\n    n_trauma: int\n        The number of trauma bays for stablisation\n\n    n_cubicles_non_trauma_treat: int\n        The number of non-trauma treatment cubicles\n\n    n_cubicles_trauma_treat: int\n        The number of trauma treatment cubicles\n\n    triage_mean: float\n        Mean duration of the triage distribution (Exponential)\n\n    reg_mean: float\n        Mean duration of the registration distribution (Lognormal)\n\n    reg_var: float\n        Variance of the registration distribution (Lognormal)\n\n    exam_mean: float\n        Mean of the examination distribution (Normal)\n\n    exam_var: float\n        Variance of the examination distribution (Normal)\n\n    trauma_mean: float\n        Mean of the trauma stabilisation distribution (Exponential)\n\n    trauma_treat_mean: float\n        Mean of the trauma cubicle treatment distribution (Lognormal)\n\n    trauma_treat_var: float\n        Variance of the trauma cubicle treatment distribution (Lognormal)\n\n    non_trauma_treat_mean: float\n        Mean of the non trauma treatment distribution\n\n    non_trauma_treat_var: float\n        Variance of the non trauma treatment distribution\n\n    non_trauma_treat_p: float\n        Probability non trauma patient requires treatment\n\n    prob_trauma: float\n        probability that a new arrival is a trauma patient.\n    '''\n    random_number_set = 42\n\n    n_triage=2\n    n_reg=2\n    n_exam=3\n    n_trauma=4\n    n_cubicles_non_trauma_treat=4\n    n_cubicles_trauma_treat=5\n\n    triage_mean=6\n    reg_mean=8\n    reg_var=2\n    exam_mean=16\n    exam_var=3\n    trauma_mean=90\n    trauma_treat_mean=30\n    trauma_treat_var=4\n    non_trauma_treat_mean=13.3\n    non_trauma_treat_var=2\n\n    non_trauma_treat_p=0.6\n    prob_trauma=0.12\n\n    arrival_df=\"ed_arrivals.csv\"\n\n    sim_duration = 600\n    number_of_runs = 100\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    '''\n    Class defining details for a patient entity\n    '''\n    def __init__(self, p_id):\n        '''\n        Constructor method\n\n        Params:\n        -----\n        identifier: int\n            a numeric identifier for the patient.\n        '''\n        self.identifier = p_id\n\n        # Time of arrival in model/at centre\n        self.arrival = -np.inf\n        # Total time in pathway\n        self.total_time = -np.inf\n\n        # Shared waits\n        self.wait_triage = -np.inf\n        self.wait_reg = -np.inf\n        self.wait_treat = -np.inf\n        # Non-trauma pathway - examination wait\n        self.wait_exam = -np.inf\n        # Trauma pathway - stabilisation wait\n        self.wait_trauma = -np.inf\n\n        # Shared durations\n        self.triage_duration = -np.inf\n        self.reg_duration = -np.inf\n        self.treat_duration = -np.inf\n\n        # Non-trauma pathway - examination duration\n        self.exam_duration = -np.inf\n        # Trauma pathway - stabilisation duration\n        self.trauma_duration = -np.inf\n\n\n# Class representing our model of the clinic.\nclass Model:\n    '''\n    Simulates the simplest minor treatment process for a patient\n\n    1. Arrive\n    2. Examined/treated by nurse when one available\n    3. Discharged\n    '''\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        self.event_log = []\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        self.trauma_patients = []\n        self.non_trauma_patients = []\n\n        # Create our resources\n        self.init_resources()\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Queue Time Cubicle\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_cubicle = 0\n\n        # create distributions\n\n        # Triage duration\n        self.triage_dist = Exponential(g.triage_mean,\n                                       random_seed=self.run_number*g.random_number_set)\n\n        # Registration duration (non-trauma only)\n        self.reg_dist = Lognormal(g.reg_mean,\n                                  np.sqrt(g.reg_var),\n                                  random_seed=self.run_number*g.random_number_set)\n\n        # Evaluation (non-trauma only)\n        self.exam_dist = Normal(g.exam_mean,\n                                np.sqrt(g.exam_var),\n                                random_seed=self.run_number*g.random_number_set)\n\n        # Trauma/stablisation duration (trauma only)\n        self.trauma_dist = Exponential(g.trauma_mean,\n                                       random_seed=self.run_number*g.random_number_set)\n\n        # Non-trauma treatment\n        self.nt_treat_dist = Lognormal(g.non_trauma_treat_mean,\n                                       np.sqrt(g.non_trauma_treat_var),\n                                       random_seed=self.run_number*g.random_number_set)\n\n        # treatment of trauma patients\n        self.treat_dist = Lognormal(g.trauma_treat_mean,\n                                    np.sqrt(g.non_trauma_treat_var),\n                                    random_seed=self.run_number*g.random_number_set)\n\n        # probability of non-trauma patient requiring treatment\n        self.nt_p_treat_dist = Bernoulli(g.non_trauma_treat_p,\n                                         random_seed=self.run_number*g.random_number_set)\n\n        # probability of non-trauma versus trauma patient\n        self.p_trauma_dist = Bernoulli(g.prob_trauma,\n                                       random_seed=self.run_number*g.random_number_set)\n\n        # init sampling for non-stationary poisson process\n        self.init_nspp()\n\n    def init_nspp(self):\n\n        # read arrival profile\n        self.arrivals = pd.read_csv(g.arrival_df)  # pylint: disable=attribute-defined-outside-init\n        self.arrivals['mean_iat'] = 60 / self.arrivals['arrival_rate']\n\n        # maximum arrival rate (smallest time between arrivals)\n        self.lambda_max = self.arrivals['arrival_rate'].max()  # pylint: disable=attribute-defined-outside-init\n\n        # thinning exponential\n        self.arrival_dist = Exponential(60.0 / self.lambda_max,  # pylint: disable=attribute-defined-outside-init\n                                            random_seed=self.run_number*g.random_number_set)\n\n        # thinning uniform rng\n        self.thinning_rng = Uniform(low=0.0, high=1.0,  # pylint: disable=attribute-defined-outside-init\n                                    random_seed=self.run_number*g.random_number_set)\n\n\n    def init_resources(self):\n        '''\n        Init the number of resources\n        and store in the arguments container object\n\n        Resource list:\n            1. Nurses/treatment bays (same thing in this model)\n\n        '''\n        # Shared Resources\n        self.triage_cubicles = simpy.Store(self.env)\n        populate_store(num_resources=g.n_triage,\n                simpy_store=self.triage_cubicles,\n                sim_env=self.env)\n\n        self.registration_cubicles = simpy.Store(self.env)\n        populate_store(num_resources=g.n_reg,\n                       simpy_store=self.registration_cubicles,\n                       sim_env=self.env)\n\n        # Non-trauma\n        self.exam_cubicles = simpy.Store(self.env)\n        populate_store(num_resources=g.n_exam,\n                       simpy_store=self.exam_cubicles,\n                       sim_env=self.env)\n\n        self.non_trauma_treatment_cubicles = simpy.Store(self.env)\n        populate_store(num_resources=g.n_cubicles_non_trauma_treat,\n                       simpy_store=self.non_trauma_treatment_cubicles,\n                       sim_env=self.env)\n\n        # Trauma\n        self.trauma_stabilisation_bays = simpy.Store(self.env)\n        populate_store(num_resources=g.n_trauma,\n                       simpy_store=self.trauma_stabilisation_bays,\n                       sim_env=self.env)\n\n        self.trauma_treatment_cubicles = simpy.Store(self.env)\n        populate_store(num_resources=g.n_cubicles_trauma_treat,\n                       simpy_store=self.trauma_treatment_cubicles,\n                       sim_env=self.env)\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            t = int(self.env.now // 60) % self.arrivals.shape[0]\n            lambda_t = self.arrivals['arrival_rate'].iloc[t]\n\n            # set to a large number so that at least 1 sample taken!\n            u = np.Inf\n\n            interarrival_time = 0.0\n            # reject samples if u &gt;= lambda_t / lambda_max\n            while u &gt;= (lambda_t / self.lambda_max):\n                interarrival_time += self.arrival_dist.sample()\n                u = self.thinning_rng.sample()\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(interarrival_time)\n\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            trace(f'patient {self.patient_counter} arrives at: {self.env.now:.3f}')\n            self.event_log.append(\n                {'patient': self.patient_counter,\n                 'pathway': 'Shared',\n                 'event': 'arrival',\n                 'event_type': 'arrival_departure',\n                 'time': self.env.now}\n            )\n\n            # sample if the patient is trauma or non-trauma\n            trauma = self.p_trauma_dist.sample()\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            # and store patient in list for later easy access\n            if trauma:\n                # create and store a trauma patient to update KPIs.\n                self.trauma_patients.append(p)\n                self.env.process(self.attend_trauma_pathway(p))\n\n            else:\n                # create and store a non-trauma patient to update KPIs.\n                self.non_trauma_patients.append(p)\n                self.env.process(self.attend_non_trauma_pathway(p))\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_non_trauma_pathway(self, patient):\n        '''\n        simulates the non-trauma/minor treatment process for a patient\n\n        1. request and wait for sign-in/triage\n        2. patient registration\n        3. examination\n        4a. percentage discharged\n        4b. remaining percentage treatment then discharge\n        '''\n        # record the time of arrival and entered the triage queue\n        patient.arrival = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Non-Trauma',\n             'event_type': 'queue',\n             'event': 'triage_wait_begins',\n             'time': self.env.now}\n        )\n\n        ###################################################\n        # request sign-in/triage\n        triage_resource = yield self.triage_cubicles.get()\n\n        # record the waiting time for triage\n        patient.wait_triage = self.env.now - patient.arrival\n        trace(f'patient {patient.identifier} triaged to minors '\n                f'{self.env.now:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Non-Trauma',\n                'event_type': 'resource_use',\n                'event': 'triage_begins',\n                'time': self.env.now,\n                'resource_id': triage_resource.id_attribute\n                }\n        )\n\n        # sample triage duration.\n        patient.triage_duration = self.triage_dist.sample()\n        yield self.env.timeout(patient.triage_duration)\n\n        trace(f'triage {patient.identifier} complete {self.env.now:.3f}; '\n                f'waiting time was {patient.wait_triage:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Non-Trauma',\n                'event_type': 'resource_use_end',\n                'event': 'triage_complete',\n                'time': self.env.now,\n                'resource_id': triage_resource.id_attribute}\n        )\n\n        # Resource is no longer in use, so put it back in the store\n        self.triage_cubicles.put(triage_resource)\n        #########################################################\n\n        # record the time that entered the registration queue\n        start_wait = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Non-Trauma',\n             'event_type': 'queue',\n             'event': 'MINORS_registration_wait_begins',\n             'time': self.env.now}\n        )\n\n        #########################################################\n        # request registration clerk\n        registration_resource = yield self.registration_cubicles.get()\n\n        # record the waiting time for registration\n        patient.wait_reg = self.env.now - start_wait\n        trace(f'registration of patient {patient.identifier} at '\n                f'{self.env.now:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Non-Trauma',\n                'event_type': 'resource_use',\n                'event': 'MINORS_registration_begins',\n                'time': self.env.now,\n                'resource_id': registration_resource.id_attribute\n                }\n        )\n\n        # sample registration duration.\n        patient.reg_duration = self.reg_dist.sample()\n        yield self.env.timeout(patient.reg_duration)\n\n        trace(f'patient {patient.identifier} registered at'\n                f'{self.env.now:.3f}; '\n                f'waiting time was {patient.wait_reg:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Non-Trauma',\n                'event': 'MINORS_registration_complete',\n                'event_type': 'resource_use_end',\n                'time': self.env.now,\n                'resource_id': registration_resource.id_attribute}\n        )\n        # Resource is no longer in use, so put it back in the store\n        self.registration_cubicles.put(registration_resource)\n        ########################################################\n\n        # record the time that entered the evaluation queue\n        start_wait = self.env.now\n\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Non-Trauma',\n             'event': 'MINORS_examination_wait_begins',\n             'event_type': 'queue',\n             'time': self.env.now}\n        )\n\n        #########################################################\n        # request examination resource\n        examination_resource = yield self.exam_cubicles.get()\n\n        # record the waiting time for examination to begin\n        patient.wait_exam = self.env.now - start_wait\n        trace(f'examination of patient {patient.identifier} begins '\n                f'{self.env.now:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Non-Trauma',\n                'event': 'MINORS_examination_begins',\n                'event_type': 'resource_use',\n                'time': self.env.now,\n                'resource_id': examination_resource.id_attribute\n                }\n        )\n\n        # sample examination duration.\n        patient.exam_duration = self.exam_dist.sample()\n        yield self.env.timeout(patient.exam_duration)\n\n        trace(f'patient {patient.identifier} examination complete '\n                f'at {self.env.now:.3f};'\n                f'waiting time was {patient.wait_exam:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Non-Trauma',\n                'event': 'MINORS_examination_complete',\n                'event_type': 'resource_use_end',\n                'time': self.env.now,\n                'resource_id': examination_resource.id_attribute}\n        )\n        # Resource is no longer in use, so put it back in\n        self.exam_cubicles.put(examination_resource)\n        ############################################################################\n\n        # sample if patient requires treatment?\n        patient.require_treat = self.nt_p_treat_dist.sample()  #pylint: disable=attribute-defined-outside-init\n\n        if patient.require_treat:\n\n            self.event_log.append(\n                {'patient': patient.identifier,\n                 'pathway': 'Non-Trauma',\n                 'event': 'requires_treatment',\n                 'event_type': 'attribute_assigned',\n                 'time': self.env.now}\n            )\n\n            # record the time that entered the treatment queue\n            start_wait = self.env.now\n            self.event_log.append(\n                {'patient': patient.identifier,\n                 'pathway': 'Non-Trauma',\n                 'event': 'MINORS_treatment_wait_begins',\n                 'event_type': 'queue',\n                 'time': self.env.now}\n            )\n            ###################################################\n            # request treatment cubicle\n\n            non_trauma_treatment_resource = yield self.non_trauma_treatment_cubicles.get()\n\n            # record the waiting time for treatment\n            patient.wait_treat = self.env.now - start_wait\n            trace(f'treatment of patient {patient.identifier} begins '\n                    f'{self.env.now:.3f}')\n            self.event_log.append(\n                {'patient': patient.identifier,\n                    'pathway': 'Non-Trauma',\n                    'event': 'MINORS_treatment_begins',\n                    'event_type': 'resource_use',\n                    'time': self.env.now,\n                    'resource_id': non_trauma_treatment_resource.id_attribute\n                }\n            )\n\n            # sample treatment duration.\n            patient.treat_duration = self.nt_treat_dist.sample()\n            yield self.env.timeout(patient.treat_duration)\n\n            trace(f'patient {patient.identifier} treatment complete '\n                    f'at {self.env.now:.3f};'\n                    f'waiting time was {patient.wait_treat:.3f}')\n            self.event_log.append(\n                {'patient': patient.identifier,\n                    'pathway': 'Non-Trauma',\n                    'event': 'MINORS_treatment_complete',\n                    'event_type': 'resource_use_end',\n                    'time': self.env.now,\n                    'resource_id': non_trauma_treatment_resource.id_attribute}\n            )\n\n            # Resource is no longer in use, so put it back in the store\n            self.non_trauma_treatment_cubicles.put(non_trauma_treatment_resource)\n        ##########################################################################\n\n        # Return to what happens to all patients, regardless of whether they were sampled as needing treatment\n        self.event_log.append(\n            {'patient': patient.identifier,\n            'pathway': 'Shared',\n            'event': 'depart',\n            'event_type': 'arrival_departure',\n            'time': self.env.now}\n        )\n\n        # total time in system\n        patient.total_time = self.env.now - patient.arrival\n\n    def attend_trauma_pathway(self, patient):\n        '''\n        simulates the major treatment process for a patient\n\n        1. request and wait for sign-in/triage\n        2. trauma\n        3. treatment\n        '''\n        # record the time of arrival and entered the triage queue\n        patient.arrival = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'queue',\n             'event': 'triage_wait_begins',\n             'time': self.env.now}\n        )\n\n        ###################################################\n        # request sign-in/triage\n        triage_resource = yield self.triage_cubicles.get()\n\n        # record the waiting time for triage\n        patient.wait_triage = self.env.now - patient.arrival\n\n        trace(f'patient {patient.identifier} triaged to trauma '\n                f'{self.env.now:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'resource_use',\n             'event': 'triage_begins',\n             'time': self.env.now,\n             'resource_id': triage_resource.id_attribute\n            }\n        )\n\n        # sample triage duration.\n        patient.triage_duration = self.triage_dist.sample()\n        yield self.env.timeout(patient.triage_duration)\n\n        trace(f'triage {patient.identifier} complete {self.env.now:.3f}; '\n              f'waiting time was {patient.wait_triage:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'resource_use_end',\n             'event': 'triage_complete',\n             'time': self.env.now,\n             'resource_id': triage_resource.id_attribute}\n        )\n\n        # Resource is no longer in use, so put it back in the store\n        self.triage_cubicles.put(triage_resource)\n        ###################################################\n\n        # record the time that entered the trauma queue\n        start_wait = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'queue',\n             'event': 'TRAUMA_stabilisation_wait_begins',\n             'time': self.env.now}\n        )\n\n        ###################################################\n        # request trauma room\n        trauma_resource = yield self.trauma_stabilisation_bays.get()\n\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Trauma',\n                'event_type': 'resource_use',\n                'event': 'TRAUMA_stabilisation_begins',\n                'time': self.env.now,\n                'resource_id': trauma_resource.id_attribute\n                }\n        )\n\n        # record the waiting time for trauma\n        patient.wait_trauma = self.env.now - start_wait\n\n        # sample stablisation duration.\n        patient.trauma_duration = self.trauma_dist.sample()\n        yield self.env.timeout(patient.trauma_duration)\n\n        trace(f'stabilisation of patient {patient.identifier} at '\n              f'{self.env.now:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'resource_use_end',\n             'event': 'TRAUMA_stabilisation_complete',\n             'time': self.env.now,\n             'resource_id': trauma_resource.id_attribute\n            }\n        )\n        # Resource is no longer in use, so put it back in the store\n        self.trauma_stabilisation_bays.put(trauma_resource)\n\n        #######################################################\n\n        # record the time that patient entered the treatment queue\n        start_wait = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'queue',\n             'event': 'TRAUMA_treatment_wait_begins',\n             'time': self.env.now}\n        )\n\n        ########################################################\n        # request treatment cubicle\n        trauma_treatment_resource = yield self.trauma_treatment_cubicles.get()\n\n        # record the waiting time for trauma\n        patient.wait_treat = self.env.now - start_wait\n        trace(f'treatment of patient {patient.identifier} at '\n                f'{self.env.now:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Trauma',\n                'event_type': 'resource_use',\n                'event': 'TRAUMA_treatment_begins',\n                'time': self.env.now,\n                'resource_id': trauma_treatment_resource.id_attribute\n                }\n        )\n\n        # sample treatment duration.\n        patient.treat_duration = self.trauma_dist.sample()\n        yield self.env.timeout(patient.treat_duration)\n\n        trace(f'patient {patient.identifier} treatment complete {self.env.now:.3f}; '\n              f'waiting time was {patient.wait_treat:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'resource_use_end',\n             'event': 'TRAUMA_treatment_complete',\n             'time': self.env.now,\n             'resource_id': trauma_treatment_resource.id_attribute}\n        )\n        self.event_log.append(\n            {'patient': patient.identifier,\n            'pathway': 'Shared',\n            'event': 'depart',\n            'event_type': 'arrival_departure',\n            'time': self.env.now}\n        )\n\n        # Resource is no longer in use, so put it back in the store\n        self.trauma_treatment_cubicles.put(trauma_treatment_resource)\n\n        #########################################################\n\n        # total time in system\n        patient.total_time = self.env.now - patient.arrival\n\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_cubicle = self.results_df[\"Queue Time Cubicle\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        self.event_log = pd.DataFrame(self.event_log)\n\n        self.event_log[\"run\"] = self.run_number\n\n        return {'results': self.results_df, 'event_log': self.event_log}\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Arrivals\"] = [0]\n        self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n        self.all_event_logs = []\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            random.seed(run)\n\n            my_model = Model(run)\n            model_outputs = my_model.run()\n            patient_level_results = model_outputs[\"results\"]\n            event_log = model_outputs[\"event_log\"]\n\n            self.df_trial_results.loc[run] = [\n                len(patient_level_results),\n                my_model.mean_q_time_cubicle,\n            ]\n\n            # print(event_log)\n\n            self.all_event_logs.append(event_log)\n\n        self.all_event_logs = pd.concat(self.all_event_logs)\n\n\n\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\nmy_trial.all_event_logs.head(10)\n\n   patient     pathway  ... resource_id run\n0        1      Shared  ...         NaN   0\n1        1  Non-Trauma  ...         NaN   0\n2        1  Non-Trauma  ...         1.0   0\n3        2      Shared  ...         NaN   0\n4        2  Non-Trauma  ...         NaN   0\n5        2  Non-Trauma  ...         2.0   0\n6        1  Non-Trauma  ...         1.0   0\n7        1  Non-Trauma  ...         NaN   0\n8        1  Non-Trauma  ...         1.0   0\n9        2  Non-Trauma  ...         2.0   0\n\n[10 rows x 7 columns]\n\n\n\nmy_trial.all_event_logs.event_type.value_counts()\n\nevent_type\nqueue                 2100\nresource_use          2035\nresource_use_end      2021\narrival_departure     1167\nattribute_assigned     264\nName: count, dtype: int64\n\n\n\nmy_trial.all_event_logs.event.value_counts()\n\nevent\narrival                             623\ntriage_wait_begins                  623\ntriage_begins                       622\ntriage_complete                     620\ndepart                              544\nMINORS_registration_wait_begins     539\nMINORS_registration_begins          514\nMINORS_registration_complete        512\nMINORS_examination_wait_begins      512\nMINORS_examination_begins           475\nMINORS_examination_complete         472\nrequires_treatment                  264\nMINORS_treatment_wait_begins        264\nMINORS_treatment_begins             264\nMINORS_treatment_complete           262\nTRAUMA_stabilisation_wait_begins     81\nTRAUMA_stabilisation_begins          81\nTRAUMA_stabilisation_complete        81\nTRAUMA_treatment_wait_begins         81\nTRAUMA_treatment_begins              79\nTRAUMA_treatment_complete            74\nName: count, dtype: int64\n\n\n\n# First, identify all patients who have a 'depart' event\n# patients_with_depart = my_trial.all_event_logs[my_trial.all_event_logs['event'].str.contains('depart')]['patient'].unique()\n\n# Then filter the original DataFrame to only include those patients\n# filtered_df = my_trial.all_event_logs[my_trial.all_event_logs['patient'].isin(patients_with_depart)]\n\nlogs_transformed = my_trial.all_event_logs[~my_trial.all_event_logs['event'].str.contains('wait')].copy()\n# logs_transformed = filtered_df[~filtered_df['event'].str.contains('wait')].copy()\nlogs_transformed = logs_transformed[logs_transformed['event_type'].isin(['resource_use', 'resource_use_end'])].copy()\nlogs_transformed['event_stage'] = logs_transformed['event_type'].apply(lambda x: 'complete' if 'end' in x else 'start')\nlogs_transformed['event_name'] = logs_transformed['event'].str.replace('_begins|_complete', '', regex=True)\nlogs_transformed['resource_id_full'] = logs_transformed.apply(lambda x: f\"{x['event_name']}_{x['resource_id']:.0f}\", axis=1)\nlogs_transformed = logs_transformed.sort_values(['run', 'time'], ascending=True)\n# logs_transformed[\"activity_id\"] = (\n#     logs_transformed.groupby([\"run\", \"patient\", \"event_name\"]).ngroup() + 1\n# )\n\n# logs_transformed = logs_transformed.sort_values([\"run\", \"patient\", \"activity_id\", \"event_stage\"], ascending=[True, True, True, False])\n\n# Sort the data by run, patient, time, and event_name to handle tied start times\nlogs_transformed = logs_transformed.sort_values([\"run\", \"patient\", \"time\", \"event_name\"])\n\n# Get the first occurrence of each activity (the start event)\nfirst_occurrences = (\n    logs_transformed[logs_transformed[\"event_stage\"] == \"start\"]\n    .drop_duplicates([\"run\", \"patient\", \"event_name\"])\n    .copy()\n)\n\n# Sort by time within each run to determine the proper sequence\nfirst_occurrences = first_occurrences.sort_values([\"run\", \"time\", \"event_name\"])\n\n# Assign sequential activity_id within each run\nfirst_occurrences[\"activity_id\"] = first_occurrences.groupby(\"run\").cumcount() + 1\n\n# Merge the activity_id back to the main DataFrame\nlogs_transformed = logs_transformed.merge(\n    first_occurrences[[\"run\", \"patient\", \"event_name\", \"activity_id\"]],\n    on=[\"run\", \"patient\", \"event_name\"],\n    how=\"left\"\n)\n\n# Sort for final ordering\nlogs_transformed = logs_transformed.sort_values(\n    [\"run\", \"patient\", \"activity_id\", \"event_stage\"],\n    ascending=[True, True, True, False]\n)\nlogs_transformed.head(50)\n\n    patient     pathway  ...        resource_id_full activity_id\n0         1  Non-Trauma  ...                triage_1           1\n2         1  Non-Trauma  ...                triage_1           1\n1         1  Non-Trauma  ...   MINORS_registration_1           3\n4         1  Non-Trauma  ...   MINORS_registration_1           3\n3         1  Non-Trauma  ...    MINORS_examination_1           5\n5         1  Non-Trauma  ...    MINORS_examination_1           5\n6         2  Non-Trauma  ...                triage_2           2\n8         2  Non-Trauma  ...                triage_2           2\n7         2  Non-Trauma  ...   MINORS_registration_2           4\n10        2  Non-Trauma  ...   MINORS_registration_2           4\n9         2  Non-Trauma  ...    MINORS_examination_2           6\n11        2  Non-Trauma  ...    MINORS_examination_2           6\n12        2  Non-Trauma  ...      MINORS_treatment_1           7\n13        2  Non-Trauma  ...      MINORS_treatment_1           7\n14        3  Non-Trauma  ...                triage_1           8\n16        3  Non-Trauma  ...                triage_1           8\n15        3  Non-Trauma  ...   MINORS_registration_1           9\n18        3  Non-Trauma  ...   MINORS_registration_1           9\n17        3  Non-Trauma  ...    MINORS_examination_3          12\n19        3  Non-Trauma  ...    MINORS_examination_3          12\n20        3  Non-Trauma  ...      MINORS_treatment_2          16\n21        3  Non-Trauma  ...      MINORS_treatment_2          16\n22        4  Non-Trauma  ...                triage_2          10\n24        4  Non-Trauma  ...                triage_2          10\n23        4  Non-Trauma  ...   MINORS_registration_2          11\n26        4  Non-Trauma  ...   MINORS_registration_2          11\n25        4  Non-Trauma  ...    MINORS_examination_1          13\n27        4  Non-Trauma  ...    MINORS_examination_1          13\n28        4  Non-Trauma  ...      MINORS_treatment_3          17\n29        4  Non-Trauma  ...      MINORS_treatment_3          17\n30        5  Non-Trauma  ...                triage_1          14\n32        5  Non-Trauma  ...                triage_1          14\n31        5  Non-Trauma  ...   MINORS_registration_1          15\n34        5  Non-Trauma  ...   MINORS_registration_1          15\n33        5  Non-Trauma  ...    MINORS_examination_2          18\n35        5  Non-Trauma  ...    MINORS_examination_2          18\n36        6      Trauma  ...                triage_2          19\n38        6      Trauma  ...                triage_2          19\n37        6      Trauma  ...  TRAUMA_stabilisation_1          21\n39        6      Trauma  ...  TRAUMA_stabilisation_1          21\n40        6      Trauma  ...      TRAUMA_treatment_1          37\n41        6      Trauma  ...      TRAUMA_treatment_1          37\n42        7  Non-Trauma  ...                triage_1          20\n44        7  Non-Trauma  ...                triage_1          20\n43        7  Non-Trauma  ...   MINORS_registration_2          23\n46        7  Non-Trauma  ...   MINORS_registration_2          23\n45        7  Non-Trauma  ...    MINORS_examination_3          27\n47        7  Non-Trauma  ...    MINORS_examination_3          27\n48        8  Non-Trauma  ...                triage_2          22\n50        8  Non-Trauma  ...                triage_2          22\n\n[50 rows x 11 columns]\n\n\n\nlogs_transformed[logs_transformed[\"activity_id\"]==26].sort_values('run').head(30)\n\n    patient pathway            event  ... event_name  resource_id_full  activity_id\n60       10  Trauma    triage_begins  ...     triage          triage_2           26\n62       10  Trauma  triage_complete  ...     triage          triage_2           26\n\n[2 rows x 11 columns]\n\n\n\nlogs_transformed.sort_values('activity_id').head(20)\n\n    patient     pathway  ...       resource_id_full activity_id\n0         1  Non-Trauma  ...               triage_1           1\n2         1  Non-Trauma  ...               triage_1           1\n6         2  Non-Trauma  ...               triage_2           2\n8         2  Non-Trauma  ...               triage_2           2\n1         1  Non-Trauma  ...  MINORS_registration_1           3\n4         1  Non-Trauma  ...  MINORS_registration_1           3\n7         2  Non-Trauma  ...  MINORS_registration_2           4\n10        2  Non-Trauma  ...  MINORS_registration_2           4\n3         1  Non-Trauma  ...   MINORS_examination_1           5\n5         1  Non-Trauma  ...   MINORS_examination_1           5\n11        2  Non-Trauma  ...   MINORS_examination_2           6\n9         2  Non-Trauma  ...   MINORS_examination_2           6\n12        2  Non-Trauma  ...     MINORS_treatment_1           7\n13        2  Non-Trauma  ...     MINORS_treatment_1           7\n14        3  Non-Trauma  ...               triage_1           8\n16        3  Non-Trauma  ...               triage_1           8\n15        3  Non-Trauma  ...  MINORS_registration_1           9\n18        3  Non-Trauma  ...  MINORS_registration_1           9\n24        4  Non-Trauma  ...               triage_2          10\n22        4  Non-Trauma  ...               triage_2          10\n\n[20 rows x 11 columns]\n\n\n\nlogs_transformed[[\"event_name\", \"event_stage\", \"event_type\"]].value_counts()\n\nevent_name            event_stage  event_type      \ntriage                start        resource_use        622\n                      complete     resource_use_end    620\nMINORS_registration   start        resource_use        514\n                      complete     resource_use_end    512\nMINORS_examination    start        resource_use        475\n                      complete     resource_use_end    472\nMINORS_treatment      start        resource_use        264\n                      complete     resource_use_end    262\nTRAUMA_stabilisation  complete     resource_use_end     81\n                      start        resource_use         81\nTRAUMA_treatment      start        resource_use         79\n                      complete     resource_use_end     74\nName: count, dtype: int64\n\n\n\nlogs_transformed.event.value_counts()\n\nevent\ntriage_begins                    622\ntriage_complete                  620\nMINORS_registration_begins       514\nMINORS_registration_complete     512\nMINORS_examination_begins        475\nMINORS_examination_complete      472\nMINORS_treatment_begins          264\nMINORS_treatment_complete        262\nTRAUMA_stabilisation_begins       81\nTRAUMA_stabilisation_complete     81\nTRAUMA_treatment_begins           79\nTRAUMA_treatment_complete         74\nName: count, dtype: int64\n\n\nFor ease, now let’s save these results as a file that we can load into R.\nWe could use a csv for easy interoperability. Alternatively, we could use something like Feather or Parquet, which are usable by both R and Python while retaining data types.\nFor ease of use and long-term readbility, we will use csv in this case.\n\nlogs_transformed.to_csv('simulation_logs_for_bupar.csv', index=False)",
    "crumbs": [
      "Miscellaneous",
      "Vidigi vs BupaR"
    ]
  },
  {
    "objectID": "vidigi_docs/vidigi_vs_bupar.html#moving-to-r---exploring-the-bupar-package",
    "href": "vidigi_docs/vidigi_vs_bupar.html#moving-to-r---exploring-the-bupar-package",
    "title": "Vidigi vs BupaR",
    "section": "Moving to R - Exploring the bupaR package",
    "text": "Moving to R - Exploring the bupaR package\nNow, it’s time to move to R (as bupaR and the bupaverse is only implemented in R).\npm4py exists as a process analytics package for Python, but the visuals of bupaR are of a high quality.\n\nImporting the required R functions and our data\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(readr)\nlibrary(bupaverse)\n\nWarning: package 'bupaverse' was built under R version 4.3.3\n\n\n\n.______    __    __  .______      ___   ____    ____  _______ .______          _______. _______\n|   _  \\  |  |  |  | |   _  \\    /   \\  \\   \\  /   / |   ____||   _  \\        /       ||   ____|\n|  |_)  | |  |  |  | |  |_)  |  /  ^  \\  \\   \\/   /  |  |__   |  |_)  |      |   (----`|  |__\n|   _  &lt;  |  |  |  | |   ___/  /  /_\\  \\  \\      /   |   __|  |      /        \\   \\    |   __|\n|  |_)  | |  `--'  | |  |     /  _____  \\  \\    /    |  |____ |  |\\  \\----.----)   |   |  |____\n|______/   \\______/  | _|    /__/     \\__\\  \\__/     |_______|| _| `._____|_______/    |_______|\n                                                                                                \n\n\n── Attaching packages ─────────────────────────────────────── bupaverse 0.1.0 ──\n✔ bupaR         0.5.4     ✔ processcheckR 0.1.4\n✔ edeaR         0.9.4     ✔ processmapR   0.5.6\n✔ eventdataR    0.3.1     \n\n\nWarning: package 'bupaR' was built under R version 4.3.3\n\n\nWarning: package 'processcheckR' was built under R version 4.3.3\n\n\n── Conflicts ────────────────────────────────────────── bupaverse_conflicts() ──\n✖ processcheckR::contains() masks dplyr::contains()\n✖ bupaR::filter()           masks dplyr::filter(), stats::filter()\n✖ processmapR::frequency()  masks stats::frequency()\n✖ edeaR::setdiff()          masks dplyr::setdiff(), base::setdiff()\n✖ bupaR::timestamp()        masks utils::timestamp()\n✖ processcheckR::xor()      masks base::xor()\n\nlibrary(processanimateR)\n\nWarning: package 'processanimateR' was built under R version 4.3.3\n\nlibrary(lubridate)\n\n\nAttaching package: 'lubridate'\n\nThe following objects are masked from 'package:base':\n\n    date, intersect, setdiff, union\n\nlibrary(DT)\n\nWarning: package 'DT' was built under R version 4.3.3\n\nlibrary(psmineR)\n\nWarning: package 'psmineR' was built under R version 4.3.3\n\ndata &lt;- readr::read_csv(\"simulation_logs_for_bupar.csv\")\n\nRows: 4056 Columns: 11\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (6): pathway, event, event_type, event_stage, event_name, resource_id_full\ndbl (5): patient, time, resource_id, run, activity_id\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\ndata %&gt;% head()\n\n# A tibble: 6 × 11\n  patient pathway    event        event_type  time resource_id   run event_stage\n    &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;        &lt;chr&gt;      &lt;dbl&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;      \n1       1 Non-Trauma triage_begi… resource_…  3.29           1     0 start      \n2       1 Non-Trauma triage_comp… resource_…  7.36           1     0 complete   \n3       1 Non-Trauma MINORS_regi… resource_…  7.36           1     0 start      \n4       1 Non-Trauma MINORS_regi… resource_… 15.4            1     0 complete   \n5       1 Non-Trauma MINORS_exam… resource_… 15.4            1     0 start      \n6       1 Non-Trauma MINORS_exam… resource_… 31.6            1     0 complete   \n# ℹ 3 more variables: event_name &lt;chr&gt;, resource_id_full &lt;chr&gt;,\n#   activity_id &lt;dbl&gt;\n\n\n\n\nEnsuring our data has the required time columns and is only for a single run\n\ndata_processed &lt;- data %&gt;%\n    dplyr::filter(run == 0) %&gt;%\n    dplyr::rename(minutes_after_origin=time) %&gt;%\n    # We provide a theoretical date to act as a starting point - the date does not have to be\n    # a true representation of the actual simulation, though you may wish it to be if there\n    # are date elements in your simulation (e.g. within-week or within-year seasonality)\n    dplyr::mutate(time = as.POSIXct(\"2024-01-01 00:00:00\", tz = \"UTC\") + lubridate::dminutes(minutes_after_origin)) %&gt;%\n    bupaR::convert_timestamps(\"time\", ymd_hms) %&gt;%\n    dplyr::mutate(patient = as.factor(patient))\n\nDT::datatable(data_processed)\n\n\n\n\n\n\n\nConverting to the activitylog format\n\nactivity_log &lt;- data_processed  %&gt;%\n    bupaR::eventlog(\n        case_id = \"patient\",\n        activity_id = \"event_name\",\n        activity_instance_id = \"activity_id\",\n        lifecycle_id = \"event_stage\",\n        timestamp = \"time\",\n        resource_id = \"resource_id_full\"\n        )\n\n## !!!! Note that the bupaR documentation recommmends using the\n## to_activitylog() function at the end of this set of steps.\n## This caused significant errors in testing of this code, so\n## I would not recommend following this recommendation, and instead\n## you can mimic the above\n\nactivity_log\n\n# Log of 4056 events consisting of:\n6 traces \n622 cases \n2035 instances of 6 activities \n20 resources \nEvents occurred from 2024-01-01 00:03:17 until 2024-01-03 01:58:40 \n \n# Variables were mapped as follows:\nCase identifier:        patient \nActivity identifier:        event_name \nResource identifier:        resource_id_full \nActivity instance identifier:   activity_id \nTimestamp:          time \nLifecycle transition:       event_stage \n\n# A tibble: 4,056 × 13\n   patient pathway    event    event_type minutes_after_origin resource_id   run\n   &lt;fct&gt;   &lt;chr&gt;      &lt;chr&gt;    &lt;chr&gt;                     &lt;dbl&gt;       &lt;dbl&gt; &lt;dbl&gt;\n 1 1       Non-Trauma triage_… resource_…                 3.29           1     0\n 2 1       Non-Trauma triage_… resource_…                 7.36           1     0\n 3 1       Non-Trauma MINORS_… resource_…                 7.36           1     0\n 4 1       Non-Trauma MINORS_… resource_…                15.4            1     0\n 5 1       Non-Trauma MINORS_… resource_…                15.4            1     0\n 6 1       Non-Trauma MINORS_… resource_…                31.6            1     0\n 7 2       Non-Trauma triage_… resource_…                 3.29           2     0\n 8 2       Non-Trauma triage_… resource_…                 9.41           2     0\n 9 2       Non-Trauma MINORS_… resource_…                 9.41           2     0\n10 2       Non-Trauma MINORS_… resource_…                17.1            2     0\n# ℹ 4,046 more rows\n# ℹ 6 more variables: event_stage &lt;chr&gt;, event_name &lt;chr&gt;,\n#   resource_id_full &lt;chr&gt;, activity_id &lt;dbl&gt;, time &lt;dttm&gt;, .order &lt;int&gt;",
    "crumbs": [
      "Miscellaneous",
      "Vidigi vs BupaR"
    ]
  },
  {
    "objectID": "vidigi_docs/vidigi_vs_bupar.html#creating-outputs",
    "href": "vidigi_docs/vidigi_vs_bupar.html#creating-outputs",
    "title": "Vidigi vs BupaR",
    "section": "Creating outputs",
    "text": "Creating outputs\n\nProcess Maps\n\nAbsolute frequencies\n\nactivity_log %&gt;%\n    process_map(frequency(\"absolute\"))\n\n\n\n\n\n\nactivity_log %&gt;%\n    process_map(frequency(\"absolute-case\"))\n\n\n\n\n\n\n\nRelative frequencies\n\nactivity_log %&gt;%\n    process_map(frequency(\"relative\"))\n\n\n\n\n\n\nactivity_log %&gt;%\n    process_map(frequency(\"relative-case\"),\n                render_options = list(edge_label_color = \"white\"))\n\n\n\n\n\n\nactivity_log %&gt;%\n    process_map(frequency(\"relative-consequent\"),\n                render_options = list(edge_label_color = \"white\"))\n\n\n\n\n\n\n\n\nPerformance Maps\n\nMean Waits\n\nactivity_log %&gt;%\n    process_map(performance())\n\n\n\n\n\n\n\nMax Waits\n\nactivity_log %&gt;%\n    process_map(performance(FUN = max))\n\nWarning: There was 1 warning in `summarize()`.\nℹ In argument: `label = do.call(...)`.\nℹ In group 9: `ACTIVITY_CLASSIFIER_ = NA` and `from_id = NA`.\nCaused by warning in `type()`:\n! no non-missing arguments to max; returning -Inf\n\n\nWarning: There were 2 warnings in `summarize()`.\nThe first warning was:\nℹ In argument: `value = do.call(...)`.\nℹ In group 1: `ACTIVITY_CLASSIFIER_ = \"ARTIFICIAL_END\"`, `next_act = NA`,\n  `from_id = 1`, `to_id = NA`.\nCaused by warning in `type()`:\n! no non-missing arguments to max; returning -Inf\nℹ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning.\n\n\n\n\n\n\n\n\n90th percentile\n\np90 &lt;- function(x, ...) {\n    quantile(x, probs = 0.9, ...)\n}\n\nactivity_log %&gt;%\n    process_map(performance(FUN = p90))\n\n\n\n\n\n\n\n\nAnalytics\nTake a look at this page in the bupaR docs details of each of these plots.\n\nIdle Time\n\nactivity_log %&gt;%\n    idle_time(\"resource\", units = \"mins\")\n\n# A tibble: 20 × 2\n   resource_id_full       idle_time     \n   &lt;chr&gt;                  &lt;drtn&gt;        \n 1 MINORS_treatment_1     2101.6612 mins\n 2 MINORS_treatment_2     2065.5869 mins\n 3 MINORS_treatment_3     2043.3483 mins\n 4 MINORS_treatment_4     1945.5681 mins\n 5 TRAUMA_treatment_1     1415.3914 mins\n 6 TRAUMA_treatment_2     1275.9829 mins\n 7 TRAUMA_treatment_3     1208.0795 mins\n 8 TRAUMA_treatment_5     1098.2404 mins\n 9 triage_2               1043.9654 mins\n10 triage_1                999.9198 mins\n11 TRAUMA_treatment_4      959.1452 mins\n12 MINORS_registration_2   951.0949 mins\n13 MINORS_registration_1   943.0261 mins\n14 TRAUMA_stabilisation_1  881.6663 mins\n15 TRAUMA_stabilisation_2  714.7071 mins\n16 TRAUMA_stabilisation_3  691.9842 mins\n17 TRAUMA_stabilisation_4  564.1900 mins\n18 MINORS_examination_2    469.1167 mins\n19 MINORS_examination_1    463.9669 mins\n20 MINORS_examination_3    441.1148 mins\n\n\n\nactivity_log %&gt;%\n    idle_time(\"resource\", units = \"mins\") %&gt;%\n    plot()\n\n\n\n\n\n\n\n\n\n\nProcessing Time\n\nactivity_log %&gt;%\n    processing_time(\"log\", units = \"mins\") %&gt;%\n    plot()\n\n\n\n\n\n\n\n\n\nactivity_log %&gt;%\n    processing_time(\"case\", units = \"mins\") %&gt;%\n    plot()\n\n\n\n\n\n\n\n\n\nactivity_log %&gt;%\n    processing_time(\"activity\", units = \"mins\") %&gt;%\n    plot()\n\n\n\n\n\n\n\n\n\nactivity_log %&gt;%\n    processing_time(\"resource-activity\", units = \"mins\") %&gt;%\n    plot()\n\n\n\n\n\n\n\n\n\n\nThroughput time\n\nactivity_log %&gt;%\n    throughput_time(\"log\", units = \"mins\") %&gt;%\n    plot()\n\n\n\n\n\n\n\n\n\n\nActivity Presence\n\nactivity_log %&gt;%\n    activity_presence() %&gt;%\n    plot()\n\n\n\n\n\n\n\n\n\n\n\nResource visualisations\n\nHandover-of-work network\n\nactivity_log %&gt;%\n    resource_map()\n\n\n\n\n\n\n\nResource precedence matrix\n\nactivity_log %&gt;%\n    resource_matrix() %&gt;%\n    plot()\n\n\n\n\n\n\n\n\n\n\n\nProcess matrix\n\nactivity_log %&gt;%\n    process_matrix(frequency(\"absolute\")) %&gt;%\n    plot()\n\n\n\n\n\n\n\n\n\n\nTrace Explorer\nThis plot helps us to unerstand how often different combinations of activities occur, and whether there are any unexpected paths in our data.\n\nactivity_log %&gt;%\n    trace_explorer(n_traces = 10)\n\nWarning: Fewer traces (6) found than specified `n_traces` (10).\n\n\n\n\n\n\n\n\n\n\n\nAnimated process map\n\nactivity_log %&gt;%\n    animate_process()\n\n\n\n\n\nLet’s compare directly with our vidigi output.\n\n\n\n\n\n\nTip\n\n\n\nThe key difference between what is produced via bupaverse’s animate_process and what can be created via vidigi is the ability of vidigi to more clearly show the scale of queues, and the number of resources available at any given point.\nVidigi can also more clearly highlight the impact of priority on resources through the use of distinct icons, though this is not demonstrated in this example.\n\n\n\n\n\n\n\n\nClick here to expand vidigi animation generation code\n\n\n\n\n\n\nfrom examples.example_2_branching_multistep.ex_2_model_classes import Trial, g\nfrom vidigi.animation import animate_activity_log\nimport pandas as pd\nimport plotly.io as pio\n#pio.renderers.default = \"notebook\"\npio.renderers.default = \"iframe\"\n\ng.sim_duration = 3000\ng.number_of_runs = 3\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\nevent_position_df = pd.DataFrame([\n    # {'event': 'arrival', 'x':  10, 'y': 250, 'label': \"Arrival\" },\n\n    # Triage - minor and trauma\n    {'event': 'triage_wait_begins',\n        'x':  160, 'y': 375, 'label': \"Waiting for&lt;br&gt;Triage\"  },\n    {'event': 'triage_begins',\n        'x':  160, 'y': 315, 'resource':'n_triage', 'label': \"Being Triaged\" },\n\n    # Minors (non-trauma) pathway\n    {'event': 'MINORS_registration_wait_begins',\n        'x':  300, 'y': 145, 'label': \"Waiting for&lt;br&gt;Registration\"  },\n    {'event': 'MINORS_registration_begins',\n        'x':  300, 'y': 85, 'resource':'n_reg', 'label':'Being&lt;br&gt;Registered'  },\n\n    {'event': 'MINORS_examination_wait_begins',\n        'x':  465, 'y': 145, 'label': \"Waiting for&lt;br&gt;Examination\"  },\n    {'event': 'MINORS_examination_begins',\n        'x':  465, 'y': 85, 'resource':'n_exam', 'label': \"Being&lt;br&gt;Examined\" },\n\n    {'event': 'MINORS_treatment_wait_begins',\n        'x':  630, 'y': 145, 'label': \"Waiting for&lt;br&gt;Treatment\"  },\n    {'event': 'MINORS_treatment_begins',\n        'x':  630, 'y': 85, 'resource':'n_cubicles_non_trauma_treat', 'label': \"Being&lt;br&gt;Treated\" },\n\n    # Trauma pathway\n    {'event': 'TRAUMA_stabilisation_wait_begins',\n        'x': 300, 'y': 560, 'label': \"Waiting for&lt;br&gt;Stabilisation\" },\n    {'event': 'TRAUMA_stabilisation_begins',\n        'x': 300, 'y': 490, 'resource':'n_trauma', 'label': \"Being&lt;br&gt;Stabilised\" },\n\n    {'event': 'TRAUMA_treatment_wait_begins',\n        'x': 630, 'y': 560, 'label': \"Waiting for&lt;br&gt;Treatment\" },\n    {'event': 'TRAUMA_treatment_begins',\n        'x': 630, 'y': 490, 'resource':'n_cubicles_trauma_treat', 'label': \"Being&lt;br&gt;Treated\" },\n\n    {'event': 'depart',\n    'x':  670, 'y': 330, 'label': \"Exit\"}\n    ])\n\n\nanimate_activity_log(\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==0],\n        event_position_df=event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        debug_mode=False,\n        setup_mode=False,\n        every_x_time_units=5,\n        include_play_button=True,\n        gap_between_entities=10,\n        gap_between_resources=20,\n        gap_between_queue_rows=20,\n        plotly_height=600,\n        plotly_width=1000,\n        override_x_max=700,\n        override_y_max=675,\n        entity_icon_size=12,\n        resource_icon_size=15,\n        wrap_queues_at=10,\n        step_snapshot_max=50,\n        limit_duration=3000,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/hsma-tools/vidigi/refs/heads/main/examples/example_2_branching_multistep/Full%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\n\n\n\n\n\n\n\n\n\n\nOther chart types\n\nDotted chart\nWe can see the impact of the pattern of daily arrivals across the course of the model, with the waits clearing out overnight when arrivals slow down.\n\nactivity_log %&gt;%\n    dotted_chart(x = \"absolute\")\n\n\n\n\n\n\n\n\n\nactivity_log %&gt;%\n    dotted_chart(x = \"relative\", sort=\"start\")\n\n\n\n\n\n\n\n\n\n\nBreaking down dotted charts by route\n\nMinors\n\nactivity_log %&gt;%\n    filter(event_name %in% c('MINORS_examination', 'MINORS_registration', 'MINORS_treatment', 'triage')) %&gt;%\n    dotted_chart(x = \"absolute\")\n\n\n\n\n\n\n\n\n\nactivity_log %&gt;%\n    filter(event_name %in% c('MINORS_examination', 'MINORS_registration', 'MINORS_treatment', 'triage')) %&gt;%\n    dotted_chart(x = \"relative\", sort=\"start\")\n\n\n\n\n\n\n\n\n\n\nTrauma\n\nactivity_log %&gt;%\n    filter(event_name %in% c('TRAUMA_stabilisation', 'TRAUMA_treatment', 'triage')) %&gt;%\n    dotted_chart(x = \"absolute\")\n\n\n\n\n\n\n\n\n\nactivity_log %&gt;%\n    filter(event_name %in% c('TRAUMA_stabilisation', 'TRAUMA_treatment', 'triage')) %&gt;%\n    dotted_chart(x = \"relative\", sort=\"start\")",
    "crumbs": [
      "Miscellaneous",
      "Vidigi vs BupaR"
    ]
  },
  {
    "objectID": "vidigi_docs/vidigi_vs_bupar.html#conclusion",
    "href": "vidigi_docs/vidigi_vs_bupar.html#conclusion",
    "title": "Vidigi vs BupaR",
    "section": "Conclusion",
    "text": "Conclusion\nvidigi and bupaR are complementary packages to use when visualising, verifying and validating your simulation models - or working with real-world process data.",
    "crumbs": [
      "Miscellaneous",
      "Vidigi vs BupaR"
    ]
  },
  {
    "objectID": "vidigi_docs/populating_event_logs.html",
    "href": "vidigi_docs/populating_event_logs.html",
    "title": "Populating Event Logs - vidigi 0.0.4 and below",
    "section": "",
    "text": "Four event types are supported in the model:\n\n‘arrival_departure’\n‘resource_use’\n‘resource_use_end’\n‘queue’.\n\nAs a minimum, you will require the use of ‘arrival_departure’ events and one of\n\n‘resource_use’ / ‘resource_use_end’\nOR ‘queue’\n\nYou can also use both ‘resource_use’ and ‘queue’ within the same model very effectively (see ex_1_simplest_case and ex_2_branching_and_optional_paths, among others).\n\n\nWithin this, two ‘arrival_departure’ events per entity are mandatory - arrival and depart, both with an event_type of arrival_departure, as shown below.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nArrivals must use\n‘event_type’: ‘arrival_departure’\n‘event’: ‘arrival’\n\n\n\nevent_log.append(\n      {'patient': unique_entity_identifier,\n      'pathway': 'Revision',\n      'event_type': 'arrival_departure',\n      'event': 'arrival',\n      'time': env.now}\n  )\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nDepartures must use\n‘event_type’: ‘arrival_departure’\n‘event’: ‘depart’\n\n\n\nevent_log.append(\n      {'patient': unique_entity_identifier,\n      'pathway': 'Revision',\n      'event_type': 'arrival_departure',\n      'event': 'depart',\n      'time': env.now}\n  )\n\n\n\n\n\n\n\nWarning\n\n\n\nThese are critical as they are used to determine when patients should first and last appear in the model.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nForgetting to include a departure step for all types of patients can lead to slow model and animation performance as the size of the event logs for individual moments will continue to increase indefinitely.\n\n\n\n\n\n\nQueues are key steps in the model.\nIt is possible to solely use queues and never make use of a simpy resource.\nBy tracking each important step in the process as a ‘queue’ step, the movement of patients can be accurately tracked.\nPatients will be ordered by the point at which they are added to the queue, with the first entries appearing at the front (bottom-right) of the queue.\nRecord the time the entity begins queueing for a resource with an event_type of ‘queue’.\nYou may use whatever string you wish to for the event name.\n\nevent_log.append(\n            {'patient': unique_entity_identifier,\n             'pathway': 'High intensity',\n             'event_type': 'queue',\n             'event': 'appointment_booked_waiting',\n             'time': self.env.now\n             }\n        )\n\nWhile the keys shown above are mandatory, you can add as many additional keys to a step’s log as desired. This can allow you to flexibly make use of the event log for other purposes as well as the animation.\n\n\n\nResource use is more complex to include but comes with two key benefits over the queue: - it becomes easier to monitor the length of time a resource is in use by a single entity as users won’t ‘move through’ the resource use stage (which can also prove confusing to less experienced viewers) - it becomes possible to show the total number of resources that are available, making it easier to understand how well resources are being utilised at different stages\nIn addition to the other fields, this also requires you to pass a resource_id argument. If you have set up your simpy store using the populate_store function from the utils module of the vidigi package, then your resources will have an ID attribute you can access in the way shown below after you have requested the resource with .get()\nRecord the time the resource begins use with an event_type of ‘resource_use’.\nYou may use whatever string you wish to for the event name.\n\n# request the resource\nmy_resource = yield my_resource_store.get()\n\nevent_log.append( \n    {'patient': unique_entity_identifier, \n     'pathway': 'My Pathway Name', \n     'event_type': 'resource_use', \n     'event': 'triage_begins', \n     'time': env.now, \n     'resource_id': triage_resource.id_attribute \n    } \n) \n\nWhen the resource is no longer in use, record the time with an event_type of ‘resource_use_end’.\nAgain, you may use whatever string you wish to for the event name.\nOnce again, you must record the ID of the resource that is being freed up.\nYou can do this before or after putting the resource back in the store.\n\nevent_log.append( \n            {'patient': unique_entity_identifier, \n             'pathway': 'My Pathway Name', \n             'event_type': 'resource_use_end', \n             'event': 'triage_complete', \n             'time': env.now, \n             'resource_id': triage_resource.id_attribute} \n        ) \n\n# Resource is no longer in use, so put it back in the store\nmy_resource_store.put(my_resource)",
    "crumbs": [
      "Working with older versions of vidigi",
      "Populating Event Logs - vidigi 0.0.4 and below"
    ]
  },
  {
    "objectID": "vidigi_docs/populating_event_logs.html#event-types",
    "href": "vidigi_docs/populating_event_logs.html#event-types",
    "title": "Populating Event Logs - vidigi 0.0.4 and below",
    "section": "",
    "text": "Four event types are supported in the model:\n\n‘arrival_departure’\n‘resource_use’\n‘resource_use_end’\n‘queue’.\n\nAs a minimum, you will require the use of ‘arrival_departure’ events and one of\n\n‘resource_use’ / ‘resource_use_end’\nOR ‘queue’\n\nYou can also use both ‘resource_use’ and ‘queue’ within the same model very effectively (see ex_1_simplest_case and ex_2_branching_and_optional_paths, among others).\n\n\nWithin this, two ‘arrival_departure’ events per entity are mandatory - arrival and depart, both with an event_type of arrival_departure, as shown below.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nArrivals must use\n‘event_type’: ‘arrival_departure’\n‘event’: ‘arrival’\n\n\n\nevent_log.append(\n      {'patient': unique_entity_identifier,\n      'pathway': 'Revision',\n      'event_type': 'arrival_departure',\n      'event': 'arrival',\n      'time': env.now}\n  )\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nDepartures must use\n‘event_type’: ‘arrival_departure’\n‘event’: ‘depart’\n\n\n\nevent_log.append(\n      {'patient': unique_entity_identifier,\n      'pathway': 'Revision',\n      'event_type': 'arrival_departure',\n      'event': 'depart',\n      'time': env.now}\n  )\n\n\n\n\n\n\n\nWarning\n\n\n\nThese are critical as they are used to determine when patients should first and last appear in the model.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nForgetting to include a departure step for all types of patients can lead to slow model and animation performance as the size of the event logs for individual moments will continue to increase indefinitely.\n\n\n\n\n\n\nQueues are key steps in the model.\nIt is possible to solely use queues and never make use of a simpy resource.\nBy tracking each important step in the process as a ‘queue’ step, the movement of patients can be accurately tracked.\nPatients will be ordered by the point at which they are added to the queue, with the first entries appearing at the front (bottom-right) of the queue.\nRecord the time the entity begins queueing for a resource with an event_type of ‘queue’.\nYou may use whatever string you wish to for the event name.\n\nevent_log.append(\n            {'patient': unique_entity_identifier,\n             'pathway': 'High intensity',\n             'event_type': 'queue',\n             'event': 'appointment_booked_waiting',\n             'time': self.env.now\n             }\n        )\n\nWhile the keys shown above are mandatory, you can add as many additional keys to a step’s log as desired. This can allow you to flexibly make use of the event log for other purposes as well as the animation.\n\n\n\nResource use is more complex to include but comes with two key benefits over the queue: - it becomes easier to monitor the length of time a resource is in use by a single entity as users won’t ‘move through’ the resource use stage (which can also prove confusing to less experienced viewers) - it becomes possible to show the total number of resources that are available, making it easier to understand how well resources are being utilised at different stages\nIn addition to the other fields, this also requires you to pass a resource_id argument. If you have set up your simpy store using the populate_store function from the utils module of the vidigi package, then your resources will have an ID attribute you can access in the way shown below after you have requested the resource with .get()\nRecord the time the resource begins use with an event_type of ‘resource_use’.\nYou may use whatever string you wish to for the event name.\n\n# request the resource\nmy_resource = yield my_resource_store.get()\n\nevent_log.append( \n    {'patient': unique_entity_identifier, \n     'pathway': 'My Pathway Name', \n     'event_type': 'resource_use', \n     'event': 'triage_begins', \n     'time': env.now, \n     'resource_id': triage_resource.id_attribute \n    } \n) \n\nWhen the resource is no longer in use, record the time with an event_type of ‘resource_use_end’.\nAgain, you may use whatever string you wish to for the event name.\nOnce again, you must record the ID of the resource that is being freed up.\nYou can do this before or after putting the resource back in the store.\n\nevent_log.append( \n            {'patient': unique_entity_identifier, \n             'pathway': 'My Pathway Name', \n             'event_type': 'resource_use_end', \n             'event': 'triage_complete', \n             'time': env.now, \n             'resource_id': triage_resource.id_attribute} \n        ) \n\n# Resource is no longer in use, so put it back in the store\nmy_resource_store.put(my_resource)",
    "crumbs": [
      "Working with older versions of vidigi",
      "Populating Event Logs - vidigi 0.0.4 and below"
    ]
  },
  {
    "objectID": "vidigi_docs/index.html",
    "href": "vidigi_docs/index.html",
    "title": "vidigi (Visual Interactive Dynamics and Integrated Graphical Insights)",
    "section": "",
    "text": "Welcome to vidigi - a package for visualising real or simulated pathways.\n\nPrimarily developed for healthcare simulation and intended to allow easy integration with tools like Streamlit so users can see the impact of changes to simulation parameters in real-time, vidigi handles the conversion of your simulation event logs into engaging and flexible animations.\nWith just a minimal set of logs - with helper functions provided to make that easier than ever to integrate into existing SimPy or Ciw simulations - you can start generating and customising your visualisations in minutes.\n\n\n\nInstall vidigi from PyPi with the command pip install vidigi\nRead the introduction to get an overview of the core vidigi concepts\nRead a step-by-step walkthrough of adding vidigi to an existing SimPy model\n\n\n\n\nThe source code is available on GitHub: github.com/hsma-tools/vidigi.\nSpotted a bug? Or just have a new feature you’d like to suggest? Raise an issue here\n\n\n\nvidigi is the Esperanto  for ‘to show’\n(or it’s the backronym ‘Visual Interactive Dynamics and Integrated Graphical Insights’ - whichever floats your boat)\n\n\n\nThanks are due to\n\nDr Daniel Chalk for support and SimPy training on the HSMA programme\nProfessor Tom Monks for his extensive materials and teaching on the use of simpy in healthcare and his material on converting code into packages\nHelena Robinson and Rey Tan for testing, suggestions and bugfinding\n\n\n\n\nVidigi is released under the MIT licence.\nCopyright 2024 Sammi Rosser\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "vidigi_docs/index.html#getting-started",
    "href": "vidigi_docs/index.html#getting-started",
    "title": "vidigi (Visual Interactive Dynamics and Integrated Graphical Insights)",
    "section": "",
    "text": "Install vidigi from PyPi with the command pip install vidigi\nRead the introduction to get an overview of the core vidigi concepts\nRead a step-by-step walkthrough of adding vidigi to an existing SimPy model",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "vidigi_docs/index.html#useful-links",
    "href": "vidigi_docs/index.html#useful-links",
    "title": "vidigi (Visual Interactive Dynamics and Integrated Graphical Insights)",
    "section": "",
    "text": "The source code is available on GitHub: github.com/hsma-tools/vidigi.\nSpotted a bug? Or just have a new feature you’d like to suggest? Raise an issue here",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "vidigi_docs/index.html#what-does-the-name-mean",
    "href": "vidigi_docs/index.html#what-does-the-name-mean",
    "title": "vidigi (Visual Interactive Dynamics and Integrated Graphical Insights)",
    "section": "",
    "text": "vidigi is the Esperanto  for ‘to show’\n(or it’s the backronym ‘Visual Interactive Dynamics and Integrated Graphical Insights’ - whichever floats your boat)",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "vidigi_docs/index.html#acknowledgements",
    "href": "vidigi_docs/index.html#acknowledgements",
    "title": "vidigi (Visual Interactive Dynamics and Integrated Graphical Insights)",
    "section": "",
    "text": "Thanks are due to\n\nDr Daniel Chalk for support and SimPy training on the HSMA programme\nProfessor Tom Monks for his extensive materials and teaching on the use of simpy in healthcare and his material on converting code into packages\nHelena Robinson and Rey Tan for testing, suggestions and bugfinding",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "vidigi_docs/index.html#licence",
    "href": "vidigi_docs/index.html#licence",
    "title": "vidigi (Visual Interactive Dynamics and Integrated Graphical Insights)",
    "section": "",
    "text": "Vidigi is released under the MIT licence.\nCopyright 2024 Sammi Rosser\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "vidigi_docs/basic_example_with_vidigi_logger_helpers.html",
    "href": "vidigi_docs/basic_example_with_vidigi_logger_helpers.html",
    "title": "A very simple example with one server",
    "section": "",
    "text": "vidigi\nsimpy - for simulation model (or see the Ciw functions and examples elsewhere in this documentation)\nrandom - for generating random arrivals\npandas - for managing dataframes\n\n\nimport simpy\nimport pandas as pd\nimport random\nfrom vidigi.animation import animate_activity_log\nfrom vidigi.logging import EventLogger\nfrom vidigi.utils import EventPosition, create_event_position_df",
    "crumbs": [
      "Walkthroughs",
      "A very simple example with one server"
    ]
  },
  {
    "objectID": "vidigi_docs/basic_example_with_vidigi_logger_helpers.html#step-1.-import-required-libraries",
    "href": "vidigi_docs/basic_example_with_vidigi_logger_helpers.html#step-1.-import-required-libraries",
    "title": "A very simple example with one server",
    "section": "",
    "text": "vidigi\nsimpy - for simulation model (or see the Ciw functions and examples elsewhere in this documentation)\nrandom - for generating random arrivals\npandas - for managing dataframes\n\n\nimport simpy\nimport pandas as pd\nimport random\nfrom vidigi.animation import animate_activity_log\nfrom vidigi.logging import EventLogger\nfrom vidigi.utils import EventPosition, create_event_position_df",
    "crumbs": [
      "Walkthroughs",
      "A very simple example with one server"
    ]
  },
  {
    "objectID": "vidigi_docs/basic_example_with_vidigi_logger_helpers.html#step-2.-set-up-simulation-parameters",
    "href": "vidigi_docs/basic_example_with_vidigi_logger_helpers.html#step-2.-set-up-simulation-parameters",
    "title": "A very simple example with one server",
    "section": "Step 2. Set up simulation parameters",
    "text": "Step 2. Set up simulation parameters\n\n# Simple simulation parameters\nSIM_DURATION = 50\nNUM_SERVERS = 1\nARRIVAL_RATE = 1.0\nSERVICE_TIME = 3.0",
    "crumbs": [
      "Walkthroughs",
      "A very simple example with one server"
    ]
  },
  {
    "objectID": "vidigi_docs/basic_example_with_vidigi_logger_helpers.html#step-3.-write-model-code-with-event-logs",
    "href": "vidigi_docs/basic_example_with_vidigi_logger_helpers.html#step-3.-write-model-code-with-event-logs",
    "title": "A very simple example with one server",
    "section": "Step 3. Write model code with event logs",
    "text": "Step 3. Write model code with event logs\nCreate a simple simulation model using simpy.\nOn the left is a basic simpy model. If not familiar check out simpy documentation for intro to simpy.\nOn the right is how we incorporate vidigi. Information for vidigi collected in a list of dictionaries which we will convert into a dataframe. You need a arrival_departure event.\n\n\n\nSimple SimPy Model\n\ndef patient_generator(env, server, event_log):\n    \"\"\"Generate patients arriving at the shop\"\"\"\n    patient_id = 0\n\n    while True:\n        patient_id += 1\n\n        # Start the patient process\n        env.process(patient_process(env, patient_id, server, event_log))\n\n        # Wait for next arrival\n        yield env.timeout(random.expovariate(ARRIVAL_RATE))\n\ndef patient_process(env, patient_id, server, event_log):\n    \"\"\"Process a single patient through the system\"\"\"\n\n    # Request server\n    with server.request() as request:\n        yield request\n\n        # Service time\n        service_duration = random.expovariate(1.0/SERVICE_TIME)\n        yield env.timeout(service_duration)\n\n# Run the simulation\ndef run_simulation():\n    env = simpy.Environment()\n    server = simpy.Resource(env, capacity=NUM_SERVERS)\n    event_log = []\n\n    # Start patient generator\n    env.process(patient_generator(env, server, event_log))\n\n    # Run simulation\n    env.run(until=SIM_DURATION)\n\n\n\n\n\nWith Vidigi Modifications\n\ndef patient_generator(env, server, logger):\n    \"\"\"Generate patients arriving at the shop\"\"\"\n    patient_id = 0\n\n    while True:\n        patient_id += 1\n\n        # Log arrival\n        logger.log_arrival(entity_id=patient_id) \n\n        # Start the patient process\n        env.process(patient_process(env, patient_id, server, logger))\n\n        # Wait for next arrival\n        yield env.timeout(random.expovariate(ARRIVAL_RATE))\n\ndef patient_process(env, patient_id, server, logger):\n    \"\"\"Process a single patient through the system\"\"\"\n\n    # Log start of queue wait \n    logger.log_queue(entity_id=patient_id, event='queue_wait_begins') \n\n    # Request server\n    with server.request() as request:\n        yield request\n\n        # Log service start\n        logger.log_resource_use_start(entity_id=patient_id, event=\"service_begins\", resource_id=1) \n\n        # Service time\n        service_duration = random.expovariate(1.0/SERVICE_TIME)\n        yield env.timeout(service_duration)\n\n        # Log service start\n        logger.log_resource_use_end(entity_id=patient_id, event=\"service_complete\", resource_id=1) \n\n    # Log departure \n    logger.log_departure(entity_id=patient_id)  \n\n# Run the simulation\ndef run_simulation():\n    env = simpy.Environment()\n    server = simpy.Resource(env, capacity=NUM_SERVERS)\n    logger = EventLogger(env=env) \n\n    # Start patient generator\n    env.process(patient_generator(env, server, logger))\n\n    # Run simulation\n    env.run(until=SIM_DURATION)\n\n    return logger.to_dataframe()",
    "crumbs": [
      "Walkthroughs",
      "A very simple example with one server"
    ]
  },
  {
    "objectID": "vidigi_docs/basic_example_with_vidigi_logger_helpers.html#step-4.-run-simulation",
    "href": "vidigi_docs/basic_example_with_vidigi_logger_helpers.html#step-4.-run-simulation",
    "title": "A very simple example with one server",
    "section": "Step 4. Run simulation",
    "text": "Step 4. Run simulation\n\n# Run simulation and get event log\nevent_log_df = run_simulation()\nprint(f\"Generated {len(event_log_df)} events\")\n\nGenerated 134 events",
    "crumbs": [
      "Walkthroughs",
      "A very simple example with one server"
    ]
  },
  {
    "objectID": "vidigi_docs/basic_example_with_vidigi_logger_helpers.html#step-5.-create-event-positions-dataframe",
    "href": "vidigi_docs/basic_example_with_vidigi_logger_helpers.html#step-5.-create-event-positions-dataframe",
    "title": "A very simple example with one server",
    "section": "Step 5. Create event positions dataframe",
    "text": "Step 5. Create event positions dataframe\n\n# Define positions for animation\nevent_positions = create_event_position_df([\n    EventPosition(event='arrival', x=0, y=350, label=\"Entrance\"),\n    EventPosition(event='queue_wait_begins', x=250, y=250, label=\"Queue\"),\n    EventPosition(event='service_begins', x=250, y=150, resource='server', label=\"Being Served\"),\n    EventPosition(event='depart', x=250, y=50, label=\"Exit\")\n])",
    "crumbs": [
      "Walkthroughs",
      "A very simple example with one server"
    ]
  },
  {
    "objectID": "vidigi_docs/basic_example_with_vidigi_logger_helpers.html#step-6.-create-animation",
    "href": "vidigi_docs/basic_example_with_vidigi_logger_helpers.html#step-6.-create-animation",
    "title": "A very simple example with one server",
    "section": "Step 6. Create animation",
    "text": "Step 6. Create animation\nExplaining:\n\nplotly_height and plotly_width\noverride_x_max and override_y_max\nsetup_mode\nevery_x_time_units\n\n\n# Create animation\nanimate_activity_log(\n    event_log=event_log_df,\n    event_position_df=event_positions,\n    every_x_time_units=1,\n    plotly_height=600,\n    override_x_max=360,\n    limit_duration=SIM_DURATION\n)",
    "crumbs": [
      "Walkthroughs",
      "A very simple example with one server"
    ]
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure_old.html",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure_old.html",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.4 and below",
    "section": "",
    "text": "On the Health Service Modelling Associates (HSMA) course we teach a particular way of writing your simpy models. More details of the approach we take can be found in our Little Book of DES.\nHowever, the core concepts of adding vidigi to your models will be the same across different models - so this example will hopefully be helpful regardless of the way you structure your simpy models.",
    "crumbs": [
      "Working with older versions of vidigi",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.4 and below"
    ]
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure_old.html#vidigis-requirements",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure_old.html#vidigis-requirements",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.4 and below",
    "section": "Vidigi’s requirements",
    "text": "Vidigi’s requirements\nThe key input vidigi requires an event log of the times that each entity in your system reached key milestones like arriving in the system, beginning to queue for a resource, being seen by a resource, and exiting the system.\nWe also need to tell vidigi what kind of activity is happening at each point:\n\narrive/depart\nqueue\nresource_use\n\nWe also provide vidigi with a table of coordinates that will help it to lay out our entities and resources, and determine their path from the entrance, to the exit, and to some extent their movement between stages.\nVidigi then takes this event log and the layout table and will process them into a table that tracks the position of every entity in the system at specified time intervals.",
    "crumbs": [
      "Working with older versions of vidigi",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.4 and below"
    ]
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure_old.html#hsma-model-structure",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure_old.html#hsma-model-structure",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.4 and below",
    "section": "HSMA Model Structure",
    "text": "HSMA Model Structure\nIn HSMA, we use four primary classes to structure our models:\n\ng, which stores model parameters (like the number of resources of a given type and distribution parameters) and simulation parameters (like the number of replications to run and the )\nEntity, which may be named something more descriptive like ‘Patient’ or ‘Customer’. You may also have more than one entity class. Each entity will store information such as its ID, and will be passed into the model to work through the pathway.\nModel, which will generate entities, simulate the pathway the entity takes through the system, and contain a way to run a single replication of the model\nTrial, which allows us to run the simulation multiple times, collect results from all of these, and get an indication of average performance and performance variation across our different model runs",
    "crumbs": [
      "Working with older versions of vidigi",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.4 and below"
    ]
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure_old.html#a-simple-model",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure_old.html#a-simple-model",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.4 and below",
    "section": "A Simple Model",
    "text": "A Simple Model\nWe’re going to start off with a very simple model of a walk-in clinic pathway.\nIn this clinic, patients arrive and are seen in the order they arrive by one of several available nurses. All nurses have the same skillset, so the queue is a simple first-in-first-out (FIFO). There is some variability in the arrival time of patients, as well as variability in how long it takes for each patient to be seen.\n\nthe g Class\nIn our g class, we set up parameters that will be used throughout.\n\nclass g:\n    random_number_set = 42 # Control\n    ial seeds of each stream of pseudorandom numbers used\n\n    n_cubicles = 3 # The number of treatment cubicles\n    trauma_treat_mean = 40 # Mean of the trauma cubicle treatment distribution (Lognormal)\n    trauma_treat_var = 5 # Variance of the trauma cubicle treatment distribution (Lognormal)\n\n    arrival_rate = 5 # mean of the exponential distribution for sampling the inter-arrival time of entities\n\n\n    sim_duration = 600 # The number of time units the simulation will run for\n    number_of_runs = 100 # The number of times the simulation will be run with different random number streams\n\n\n\nthe Patient Class\nOur Patient class represents a single individual.\nThe attributes in this class are used to track various metrics that will be used for determining how well our particular scenario has performed - think of it like a person holding a clipboard that is having various times and figures recorded on it as they move through the system.\n\nclass Patient:\n    def __init__(self, p_id):\n        self.identifier = p_id\n        self.arrival = -np.inf\n        self.wait_treat = -np.inf\n        self.total_time = -np.inf\n        self.treat_duration = -np.inf\n\n\n\nthe Model Class\nOur model class is more complex.\n\nthe init method\nFirst, we set up a series of attributes\n\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        self.patients = []\n\n        # Create our resources\n        self.init_resources()\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Queue Time Cubicle\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_cubicle = 0\n\n        self.patient_inter_arrival_dist = Exponential(mean = g.arrival_rate,\n                                                      random_seed = self.run_number*g.random_number_set)\n        self.treat_dist = Lognormal(mean = g.trauma_treat_mean,\n                                    stdev = g.trauma_treat_var,\n                                    random_seed = self.run_number*g.random_number_set)\n\n\n\nthe init_resources method\n\n    def init_resources(self):\n        '''\n        Init the number of resources\n\n        Resource list:\n            1. Nurses/treatment bays (same thing in this model)\n\n        '''\n        self.treatment_cubicles = simpy.Resource(self.env, capacity=g.n_cubicles)\n\n\n\nthe generator_patient_arrivals method\n\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            # Store patient in list for later easy access\n            self.patients.append(p)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = self.patient_inter_arrival_dist.sample()\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n\n\nthe attend_clinic function\n\n    def attend_clinic(self, patient):\n        self.arrival = self.env.now\n\n        # request examination resource\n        start_wait = self.env.now\n\n        with self.treatment_cubicles.request() as req:\n            # Seize a treatment resource when available\n            yield req\n\n            # record the waiting time for registration\n            self.wait_treat = self.env.now - start_wait\n\n            # sample treatment duration\n            self.treat_duration = self.treat_dist.sample()\n            yield self.env.timeout(self.treat_duration)\n\n        # total time in system\n        self.total_time = self.env.now - self.arrival\n\n\n\nthe calculate_run_results function\n\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_cubicle = self.results_df[\"Queue Time Cubicle\"].mean()\n\n\n\nthe run function\n\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n\n\n\nthe Trial Class\n\nthe init method\n\ndef  __init__(self):\n    self.df_trial_results = pd.DataFrame()\n    self.df_trial_results[\"Run Number\"] = [0]\n    self.df_trial_results[\"Arrivals\"] = [0]\n    self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n    self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n\n\nThe run_trial method\nRun the simulation for the number of runs specified in g class.\nor each run, we create a new instance of the Model class and call its run method, which sets everything else in motion.\nOnce the run has completed, we grab out the stored run results (just mean queuing time here) and store it against the run number in the trial results dataframe.\n\n    def run_trial(self):\n        print(f\"{g.n_cubicles} nurses\")\n        print(\"\") ## Print a blank line\n\n        for run in range(g.number_of_runs):\n            random.seed(run)\n\n            my_model = Model(run)\n            my_model.run()\n\n            self.df_trial_results.loc[run] = [my_model.mean_q_time_cubicle]\n\n        return self.df_trial_results",
    "crumbs": [
      "Working with older versions of vidigi",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.4 and below"
    ]
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure_old.html#making-changes-for-vidigi",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure_old.html#making-changes-for-vidigi",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.4 and below",
    "section": "Making Changes for Vidigi",
    "text": "Making Changes for Vidigi\n\nimports\n\n\n\nOriginal\n\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\nfrom sim_tools.distributions import Exponential, Lognormal\n\n\n\n\n\n\nWith Vidigi Modifications\n\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\nfrom sim_tools.distributions import Exponential, Lognormal\nfrom vidigi.resources import populate_store \nfrom vidigi.animation import animate_activity_log \n\n\n\n\n\n\nthe g Class\nOur g class is unchanged.\n\n\nthe Entity Class\nOur entity class - in this case, Patient - is unchanged.\n\n\nthe Model Class\n\nThe init method\nTo our init method for the Model class, we add an empty list that will store event logs throughout the model run for each patient.\n\n\n\nOriginal\n\ndef __init__(self, run_number):\n    # Create a SimPy environment in which everything will live\n    self.env = simpy.Environment()\n\n    # Create a patient counter (which we'll use as a patient ID)\n    self.patient_counter = 0\n\n    # Create an empty list to store patient objects in\n    self.patients = []\n\n    # Create our resources\n    self.init_resources()\n\n    # Store the passed in run number\n    self.run_number = run_number\n\n    # Create a new Pandas DataFrame that will store some results\n    # against the patient ID (which we'll use as the index).\n    self.results_df = pd.DataFrame()\n    self.results_df[\"Patient ID\"] = [1]\n    self.results_df[\"Queue Time Cubicle\"] = [0.0]\n    self.results_df[\"Time with Nurse\"] = [0.0]\n    self.results_df.set_index(\"Patient ID\", inplace=True)\n\n    # Create an attribute to store the mean queuing times\n    # across this run of the model\n    self.mean_q_time_cubicle = 0\n\n    self.patient_inter_arrival_dist = Exponential(\n        mean = g.arrival_rate,\n        random_seed = self.run_number*g.random_number_set\n        )\n\n    self.treat_dist = Lognormal(\n        mean = g.trauma_treat_mean,\n        stdev = g.trauma_treat_var,\n        random_seed = self.run_number*g.random_number_set\n        )\n\n\n\n\n\n\nWith Vidigi Modifications\n\ndef __init__(self, run_number):\n    # Create a SimPy environment in which everything will live\n    self.env = simpy.Environment()\n\n    # Add an empty list to store our event logs in \n    self.event_log = [] \n\n    # Create a patient counter (which we'll use as a patient ID)\n    self.patient_counter = 0\n\n    # Create an empty list to store patient objects in\n    self.patients = []\n\n    # Create our resources\n    self.init_resources()\n\n    # Store the passed in run number\n    self.run_number = run_number\n\n    # Create a new Pandas DataFrame that will store some results\n    # against the patient ID (which we'll use as the index)\n    self.results_df = pd.DataFrame()\n    self.results_df[\"Patient ID\"] = [1]\n    self.results_df[\"Queue Time Cubicle\"] = [0.0]\n    self.results_df[\"Time with Nurse\"] = [0.0]\n    self.results_df.set_index(\"Patient ID\", inplace=True)\n\n    # Create an attribute to store the mean queuing times\n    # across this run of the model\n    self.mean_q_time_cubicle = 0\n\n    self.patient_inter_arrival_dist = Exponential(\n        mean = g.arrival_rate,\n        random_seed = self.run_number*g.random_number_set\n        )\n\n    self.treat_dist = Lognormal(\n        mean = g.trauma_treat_mean,\n        stdev = g.trauma_treat_var,\n        random_seed = self.run_number*g.random_number_set\n        )\n\n\n\n\n\n\nthe init_resources method\nVidigi needs to know which resource a user made use of so that we can ensure it stays with the correct resource throughout its time in the animation.\nThe standard simpy Resource does not have a way of tracking that, so we need to do two things: - create a simpy Store that we will store our resources in - use the vidigi helper function populate_store() to generate a store full of special resources that each have a unique ID we can track when doing our event logging\nOverall, the use of stores won’t generally change your code too much - and we cover exactly what needs to change a little later in this document.\nIf you are using priority resources, this step will be a little different - see Example 3 in the documents if you need to use Resources that prioritise some entities over others.\n\n\n\nOriginal\n\ndef init_resources(self):\n    self.treatment_cubicles = simpy.Resource(\n        self.env,\n        capacity=g.n_cubicles\n        )\n\n\n\n\n\n\nWith Vidigi Modifications\n\ndef init_resources(self):\n    self.treatment_cubicles = simpy.Store(self.env) \n\n    populate_store(  \n        num_resources=g.n_cubicles, \n        simpy_store=self.treatment_cubicles, \n        sim_env=self.env\n        ) \n\n\n\n\n\n\nthe generator_patient_arrivals method\nThis method is unchanged.\n\n\nthe attend_clinic method\nThis is the key place in which we add our logging. The logs are what vidigi relies on to calculate who should be where, when, within the animation.\nEvent logging takes the format below:\n\nself.event_log.append(\n        {'patient': entity_identifier,\n            'pathway': 'My_Pathway_Name',\n            'event_type': 'arrival_departure', # or 'queue', 'resource_use', or 'resource_use_end'\n            'event': 'arrival', # or 'depart', or for 'queue' and 'resource_use' or 'resource_use_end' you can determine your own event name\n            'time': self.env.now}\n    )\n\nMore details about event logging can be found in the ‘Event Logging’ page.\nThis is also where we need to change the way we request resources to account for the fact we are now using a simpy store instead of directly interacting with our simpy resources.\nWhere we would have previously used\n\nwith self.treatment_cubicles.request() as req:\n    # Seize a treatment resource when available\n    yield req\n\n    # ALL CODE WHERE WE NEED TO KEEP HOLD OF THE RESOURCE\n\n# CONTINUE AFTER RELEASING RESOURCE HERE\n\nwe instead now use\n\n# Seize a treatment resource when available\ntreatment_resource = yield self.treatment_cubicles.get()\n\n# ALL CODE WHERE WE NEED TO KEEP HOLD OF THE RESOURCE\n\n# CONTINUE AFTER RELEASING RESOURCE HERE\n\n# Resource is no longer in use, so put it back in the store\nself.treatment_cubicles.put(treatment_resource)\n\n\n\n\nOriginal\n\ndef attend_clinic(self, patient):\n    self.arrival = self.env.now\n\n    # request examination resource\n    start_wait = self.env.now\n\n    with self.treatment_cubicles.request() as req:\n        # Seize a treatment resource when available\n        yield req\n\n        # record the waiting time for registration\n        self.wait_treat = self.env.now - start_wait\n\n        # sample treatment duration\n        self.treat_duration = self.treat_dist.sample()\n        yield self.env.timeout(self.treat_duration)\n\n    # total time in system\n    self.total_time = self.env.now - self.arrival\n\n\n\n\n\n\nWith Vidigi Modifications\n\ndef attend_clinic(self, patient):\n    self.arrival = self.env.now\n    self.event_log.append( \n        {'patient': patient.identifier, \n            'pathway': 'Simplest', \n            'event_type': 'arrival_departure', \n            # you must use this event name for arrival events\n            'event': 'arrival',  \n            'time': self.env.now} \n    ) \n\n    # request examination resource\n    start_wait = self.env.now\n    self.event_log.append( \n        {'patient': patient.identifier, \n            'pathway': 'Simplest', \n            # for a queue, you can define your chosen event name\n            'event': 'treatment_wait_begins', \n            'event_type': 'queue', \n            'time': self.env.now} \n    ) \n\n    # Seize a treatment resource when available\n    treatment_resource = yield self.treatment_cubicles.get() \n\n    # record the waiting time for registration\n    self.wait_treat = self.env.now - start_wait\n    self.event_log.append( \n        {'patient': patient.identifier, \n            'pathway': 'Simplest', \n            'event': 'treatment_begins', \n            # for a resource_use, you can define your chosen event name\n            'event_type': 'resource_use', \n            'time': self.env.now, \n            # grab the resource id from the treatment_resource requested\n            'resource_id': treatment_resource.id_attribute \n            } \n    ) \n\n    # sample treatment duration\n    self.treat_duration = self.treat_dist.sample()\n    yield self.env.timeout(self.treat_duration)\n\n    self.event_log.append( \n        {'patient': patient.identifier, \n            'pathway': 'Simplest', \n            # for a resource_use_end, you can define your chosen event name\n            'event': 'treatment_complete', \n            'event_type': 'resource_use_end', \n            'time': self.env.now, \n            'resource_id': treatment_resource.id_attribute} \n    ) \n\n    # Resource is no longer in use, so put it back in the store \n    self.treatment_cubicles.put(treatment_resource) \n\n    # total time in system\n    self.total_time = self.env.now - self.arrival\n    self.event_log.append( \n        {'patient': patient.identifier, \n        'pathway': 'Simplest', \n        'event': 'depart', # you must use this event name for departure events \n        'event_type': 'arrival_departure', \n        'time': self.env.now} \n    ) \n\n\n\n\n\n\nthe calculate_run_results method\nThis method is unchanged.\n\n\nthe run method\n\n\n\nOriginal\n\ndef run(self):\n    # Start up our DES entity generators that create new patients.  We've\n    # only got one in this model, but we'd need to do this for each one if\n    # we had multiple generators.\n    self.env.process(self.generator_patient_arrivals())\n\n    # Run the model for the duration specified in g class\n    self.env.run(until=g.sim_duration)\n\n    # Now the simulation run has finished, call the method that calculates\n    # run results\n    self.calculate_run_results()\n\n\n\n\n\n\nWith Vidigi Modifications\n\ndef run(self):\n    # Start up our DES entity generators that create new patients.  We've\n    # only got one in this model, but we'd need to do this for each one if\n    # we had multiple generators.\n    self.env.process(self.generator_patient_arrivals())\n\n    # Run the model for the duration specified in g class\n    self.env.run(until=g.sim_duration)\n\n    # Now the simulation run has finished, call the method that calculates\n    # run results\n    self.calculate_run_results()\n\n    self.event_log = pd.DataFrame(self.event_log) \n\n    self.event_log[\"run\"] = self.run_number \n\n    return {'results': self.results_df, 'event_log': self.event_log}  \n\n\n\n\n\n\n\nthe Trial Class\n\nthe init method\n\n\n\nOriginal\n\ndef  __init__(self):\n    self.df_trial_results = pd.DataFrame()\n    self.df_trial_results[\"Run Number\"] = [0]\n    self.df_trial_results[\"Arrivals\"] = [0]\n    self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n    self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n\n\n\n\n\nWith Vidigi Modifications\n\ndef  __init__(self):\n    self.df_trial_results = pd.DataFrame()\n    self.df_trial_results[\"Run Number\"] = [0]\n    self.df_trial_results[\"Arrivals\"] = [0]\n    self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n    self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    self.all_event_logs = [] \n\n\n\n\n\n\nthe run_trial method\n\n\n\nOriginal\n\ndef run_trial(self):\n    for run in range(g.number_of_runs):\n        random.seed(run)\n\n        my_model = Model(run)\n        my_model.run()\n\n        self.df_trial_results.loc[run] = [\n            my_model.mean_q_time_cubicle\n        ]\n\n    return self.df_trial_results\n\n\n\n\n\n\nWith Vidigi Modifications\n\ndef run_trial(self):\n    for run in range(g.number_of_runs):\n        random.seed(run)\n\n        my_model = Model(run)\n        model_outputs = my_model.run()\n        patient_level_results = model_outputs[\"results\"] \n        event_log = model_outputs[\"event_log\"] \n\n        self.df_trial_results.loc[run] = [\n            my_model.mean_q_time_cubicle\n        ]\n\n        self.all_event_logs.append(event_log) \n\n    self.all_event_logs = pd.concat(self.all_event_logs)",
    "crumbs": [
      "Working with older versions of vidigi",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.4 and below"
    ]
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure_old.html#using-vidigi-to-create-an-animation-from-our-event-log",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure_old.html#using-vidigi-to-create-an-animation-from-our-event-log",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.4 and below",
    "section": "Using vidigi to create an animation from our event log",
    "text": "Using vidigi to create an animation from our event log\nFor simple animations with vidigi, it is recommended that you use the animate_activity_log function.\nThis all-in-one function takes an event log of the structure discussed above, then turns it into an animated output that can be embedded in a quarto document, a web app, or saved as a standalone HTML file.\nFirst, we need to create an instance of our trial class, then run the trial.\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\nThe dataframe of event logs can then be viewed using my_trial.all_event_logs\n\nThe event_position_df\nWe can then generate our coordinates for the initial positioning of each step.\n\n\n\n\n\n\nNote\n\n\n\nThe ‘event’ names must match the event names you assigned in the logging steps.\nHowever, this will not be displayed anywhere in the final setup. Instead, use ‘label’ to define a human-readable label that can optionally be displayed in the final animation.\n\n\n\n\n\n\n\n\nWarning\n\n\n\n‘label’ should not be left out or be an empty string - both of these will cause problems.\n\n\n\n\n\n\n\n\nNote\n\n\n\nYou only need to provide positions for\n\narrival\ndeparture\nqueue\nresource_use (optional - you can have an animation that is only queues)\n\ni.e. you do not need to provide coordinates for resource_use_end\nYou can also opt to skip any queue or resource_use steps you do not want to show, though note that this could produce a misleading output if not carefully explained to end users\n\n\n\n\n\n\n\n\nTip\n\n\n\nFor queues and resource use, the coordinate will correspond to the bottom-right-hand corner of the block of queueing entities or resources.\n\n\n\nevent_position_df = pd.DataFrame([\n                    {'event': 'arrival',\n                     'x':  50, 'y': 300,\n                     'label': \"Arrival\" },\n\n                    # Triage - minor and trauma\n                    {'event': 'treatment_wait_begins',\n                     'x':  205, 'y': 275,\n                     'label': \"Waiting for Treatment\"},\n\n                    {'event': 'treatment_begins',\n                     'x':  205, 'y': 175,\n                     'resource':'n_cubicles',\n                     'label': \"Being Treated\"},\n\n                    {'event': 'depart',\n                     'x':  270, 'y': 70,\n                     'label': \"Exit\"}\n\n                ])",
    "crumbs": [
      "Working with older versions of vidigi",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.4 and below"
    ]
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure_old.html#creating-the-animation",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure_old.html#creating-the-animation",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.4 and below",
    "section": "Creating the animation",
    "text": "Creating the animation\nFinally, we can create the animation.\n\n\n\n\n\n\nWarning\n\n\n\nIt is important that you only pass in a single run at a time!\nPassing a dataframe in containing more than one run will produce incorrect animations.\nYou may, however, wish to give the user control over which run they visualise using a dropdown in something like Streamlit or Shiny - or perhaps\n\n\n\nsingle_run_event_log_df = my_trial.all_event_logs[my_trial.all_event_logs['run']==1]\n\nanimate_activity_log(\n        event_log=single_run_event_log_df,\n        event_position_df= event_position_df,\n        scenario=g(), # Use an instance of the g class as our scenario\n        limit_duration=g.sim_duration,\n        debug_mode=True, # Turn on logging messages\n        setup_mode=True, # Turn on axis units - this can help with honing your event_position_df\n        every_x_time_units=1,\n        include_play_button=True,\n        entity_icon_size=20,\n        resource_icon_size=20,\n        gap_between_entities=6,\n        gap_between_resource_rows=25,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        wrap_queues_at=25,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=True # display our Label column from our event_position_df\n    )\n\n\n\n\n\n\n\nClick here to view the full code\n\n\n\n\n\n\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\nfrom sim_tools.distributions import Exponential, Lognormal\nfrom vidigi.resources import populate_store\nfrom vidigi.animation import animate_activity_log\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    '''\n    Create a scenario to parameterise the simulation model\n\n    Parameters:\n    -----------\n    random_number_set: int, optional (default=DEFAULT_RNG_SET)\n        Set to control the initial seeds of each stream of pseudo\n        random numbers used in the model.\n\n    n_cubicles: int\n        The number of treatment cubicles\n\n    trauma_treat_mean: float\n        Mean of the trauma cubicle treatment distribution (Lognormal)\n\n    trauma_treat_var: float\n        Variance of the trauma cubicle treatment distribution (Lognormal)\n\n    arrival_rate: float\n        Set the mean of the exponential distribution that is used to sample the\n        inter-arrival time of patients\n\n    sim_duration: int\n        The number of time units the simulation will run for\n\n    number_of_runs: int\n        The number of times the simulation will be run with different random number streams\n\n    '''\n    random_number_set = 42\n\n    n_cubicles = 3\n    trauma_treat_mean = 40\n    trauma_treat_var = 5\n\n    arrival_rate = 5\n\n    sim_duration = 600\n    number_of_runs = 100\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    '''\n    Class defining details for a patient entity\n    '''\n    def __init__(self, p_id):\n        '''\n        Constructor method\n\n        Params:\n        -----\n        identifier: int\n            a numeric identifier for the patient.\n        '''\n        self.identifier = p_id\n        self.arrival = -np.inf\n        self.wait_treat = -np.inf\n        self.total_time = -np.inf\n        self.treat_duration = -np.inf\n\n# Class representing our model of the clinic.\nclass Model:\n    '''\n    Simulates the simplest minor treatment process for a patient\n\n    1. Arrive\n    2. Examined/treated by nurse when one available\n    3. Discharged\n    '''\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        self.event_log = []\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        self.patients = []\n\n        # Create our resources\n        self.init_resources()\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Queue Time Cubicle\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_cubicle = 0\n\n        self.patient_inter_arrival_dist = Exponential(mean = g.arrival_rate,\n                                                      random_seed = self.run_number*g.random_number_set)\n        self.treat_dist = Lognormal(mean = g.trauma_treat_mean,\n                                    stdev = g.trauma_treat_var,\n                                    random_seed = self.run_number*g.random_number_set)\n\n    def init_resources(self):\n        '''\n        Init the number of resources\n        and store in the arguments container object\n\n        Resource list:\n            1. Nurses/treatment bays (same thing in this model)\n\n        '''\n        self.treatment_cubicles = simpy.Store(self.env)\n\n        populate_store(num_resources=g.n_cubicles,\n                       simpy_store=self.treatment_cubicles,\n                       sim_env=self.env)\n\n        # for i in range(g.n_cubicles):\n        #     self.treatment_cubicles.put(\n        #         CustomResource(\n        #             self.env,\n        #             capacity=1,\n        #             id_attribute = i+1)\n        #         )\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            # Store patient in list for later easy access\n            self.patients.append(p)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = self.patient_inter_arrival_dist.sample()\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        self.arrival = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Simplest',\n             'event_type': 'arrival_departure',\n             'event': 'arrival',\n             'time': self.env.now}\n        )\n\n        # request examination resource\n        start_wait = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Simplest',\n             'event': 'treatment_wait_begins',\n             'event_type': 'queue',\n             'time': self.env.now}\n        )\n\n        # Seize a treatment resource when available\n        treatment_resource = yield self.treatment_cubicles.get()\n\n        # record the waiting time for registration\n        self.wait_treat = self.env.now - start_wait\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Simplest',\n                'event': 'treatment_begins',\n                'event_type': 'resource_use',\n                'time': self.env.now,\n                'resource_id': treatment_resource.id_attribute\n                }\n        )\n\n        # sample treatment duration\n        self.treat_duration = self.treat_dist.sample()\n        yield self.env.timeout(self.treat_duration)\n\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Simplest',\n                'event': 'treatment_complete',\n                'event_type': 'resource_use_end',\n                'time': self.env.now,\n                'resource_id': treatment_resource.id_attribute}\n        )\n\n        # Resource is no longer in use, so put it back in\n        self.treatment_cubicles.put(treatment_resource)\n\n        # total time in system\n        self.total_time = self.env.now - self.arrival\n        self.event_log.append(\n            {'patient': patient.identifier,\n            'pathway': 'Simplest',\n            'event': 'depart',\n            'event_type': 'arrival_departure',\n            'time': self.env.now}\n        )\n\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_cubicle = self.results_df[\"Queue Time Cubicle\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        self.event_log = pd.DataFrame(self.event_log)\n\n        self.event_log[\"run\"] = self.run_number\n\n        return {'results': self.results_df, 'event_log': self.event_log}\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Arrivals\"] = [0]\n        self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n        self.all_event_logs = []\n\n    # Method to run a trial\n    def run_trial(self):\n        print(f\"{g.n_cubicles} nurses\")\n        print(\"\") ## Print a blank line\n\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            random.seed(run)\n\n            my_model = Model(run)\n            model_outputs = my_model.run()\n            patient_level_results = model_outputs[\"results\"]\n            event_log = model_outputs[\"event_log\"]\n\n            self.df_trial_results.loc[run] = [\n                len(patient_level_results),\n                my_model.mean_q_time_cubicle,\n            ]\n\n            # print(event_log)\n\n            self.all_event_logs.append(event_log)\n\n        self.all_event_logs = pd.concat(self.all_event_logs)\n\n\n\n\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\nsingle_run_event_log_df = my_trial.all_event_logs[my_trial.all_event_logs['run']==1]\n\nanimate_activity_log(\n        event_log=single_run_event_log_df,\n        event_position_df= event_position_df,\n        scenario=g(), # Use an instance of the g class as our scenario\n        entity_col_name=\"patient\",\n        limit_duration=g.sim_duration,\n        debug_mode=True, # Turn on logging messages\n        setup_mode=True, # Turn on axis units - this can help with honing your event_position_df\n        every_x_time_units=1,\n        include_play_button=True,\n        entity_icon_size=20,\n        resource_icon_size=20,\n        gap_between_entities=6,\n        gap_between_queue_rows=25,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        wrap_queues_at=25,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=True # display our Label column from our event_position_df\n    )\n\n3 nurses\n\nAnimation function called at 15:40:07\nIteration through time-unit-by-time-unit logs complete 15:40:10\nSnapshot df concatenation complete at 15:40:10\nReshaped animation dataframe finished construction at 15:40:10\nPlacement dataframe finished construction at 15:40:10\nOutput animation generation complete at 15:40:14\nTotal Time Elapsed: 6.41 seconds\n\n\n        \n        \n        \n\n\n                                                    \n\n\nWhen you have finished tweaking the layout, you can further enhance your output.\n\nanimate_activity_log(\n        event_log=single_run_event_log_df,\n        event_position_df= event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        limit_duration=g.sim_duration,\n        debug_mode=False, # Turn off logging messages\n        setup_mode=False, # Turn off axis units\n        every_x_time_units=1,\n        include_play_button=True,\n        entity_icon_size=20,\n        resource_icon_size=20,\n        gap_between_entities=6,\n        gap_between_queue_rows=25,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        wrap_queues_at=25,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=False, # hide our Label column from our event_position_df\n        # Add a local or web-hosted image as our background\n        add_background_image=\"https://raw.githubusercontent.com/hsma-tools/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\")\n\n                                                    \n\n\nWe can then rerun our animation, passing in different parameters - though make sure to rerun your trial if you do so!\nHere, we will increase the number of cubicles from 3 to 7 and see the impact this has on the queue size.\n\ng.n_cubicles = 7 \n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\nsingle_run_event_log_df = my_trial.all_event_logs[my_trial.all_event_logs['run']==1]\n\nanimate_activity_log(\n        event_log=single_run_event_log_df,\n        event_position_df= event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        limit_duration=g.sim_duration,\n        debug_mode=False, # Turn off logging messages\n        setup_mode=False, # Turn off axis units\n        every_x_time_units=1,\n        include_play_button=True,\n        entity_icon_size=20,\n        resource_icon_size=20,\n        gap_between_entities=6,\n        gap_between_queue_rows=25,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        wrap_queues_at=25,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=False, # hide our Label column from our event_position_df\n        # Add a local or web-hosted image as our background\n        add_background_image=\"https://raw.githubusercontent.com/hsma-tools/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\")\n\n7 nurses",
    "crumbs": [
      "Working with older versions of vidigi",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 0.0.4 and below"
    ]
  },
  {
    "objectID": "reference/utils.VidigiStore.html",
    "href": "reference/utils.VidigiStore.html",
    "title": "utils.VidigiStore",
    "section": "",
    "text": "utils.VidigiStore(self, env, capacity=float('inf'), init_items=None)\nA wrapper around SimPy’s Store that allows using a context manager pattern similar to resource requests.\nThis allows code like:\nwith store.request() as req: yield req # Use the item that was obtained yield env.timeout(10) # Item is automatically returned when exiting the context\nAI USE DISCLOSURE: This code was generated by Claude 3.7 Sonnet. It has been evaluated and tested by a human.\n\n\n\n\n\nName\nDescription\n\n\n\n\ncapacity\nGet the capacity of the store\n\n\nitems\nGet all items currently in the store\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nget\nAlias for request() to maintain compatibility with both patterns.\n\n\nget_direct\nGet an item from the store without the context manager.\n\n\nput\nPut an item into the store.\n\n\nrequest\nRequest context manager for getting an item from the store.\n\n\nrequest_direct\nAlias for get_direct() to maintain consistent API with SimPy resources.\n\n\n\n\n\nutils.VidigiStore.get()\nAlias for request() to maintain compatibility with both patterns.\nReturns: A context manager for getting an item\n\n\n\nutils.VidigiStore.get_direct()\nGet an item from the store without the context manager. Use this if you don’t want to automatically return the item.\nReturns: A get event that can be yielded\n\n\n\nutils.VidigiStore.put(item)\nPut an item into the store.\nArgs: item: The item to put in the store\n\n\n\nutils.VidigiStore.request()\nRequest context manager for getting an item from the store. The item is automatically returned when exiting the context.\nUsage: with store.request() as req: yield req # This yields the get event # Now we have the item from the store yield env.timeout(10) # Item is automatically returned when exiting the context\nReturns: A context manager that returns the get event and handles returning the item\n\n\n\nutils.VidigiStore.request_direct()\nAlias for get_direct() to maintain consistent API with SimPy resources.\nReturns: A get event that can be yielded"
  },
  {
    "objectID": "reference/utils.VidigiStore.html#attributes",
    "href": "reference/utils.VidigiStore.html#attributes",
    "title": "utils.VidigiStore",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncapacity\nGet the capacity of the store\n\n\nitems\nGet all items currently in the store"
  },
  {
    "objectID": "reference/utils.VidigiStore.html#methods",
    "href": "reference/utils.VidigiStore.html#methods",
    "title": "utils.VidigiStore",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget\nAlias for request() to maintain compatibility with both patterns.\n\n\nget_direct\nGet an item from the store without the context manager.\n\n\nput\nPut an item into the store.\n\n\nrequest\nRequest context manager for getting an item from the store.\n\n\nrequest_direct\nAlias for get_direct() to maintain consistent API with SimPy resources.\n\n\n\n\n\nutils.VidigiStore.get()\nAlias for request() to maintain compatibility with both patterns.\nReturns: A context manager for getting an item\n\n\n\nutils.VidigiStore.get_direct()\nGet an item from the store without the context manager. Use this if you don’t want to automatically return the item.\nReturns: A get event that can be yielded\n\n\n\nutils.VidigiStore.put(item)\nPut an item into the store.\nArgs: item: The item to put in the store\n\n\n\nutils.VidigiStore.request()\nRequest context manager for getting an item from the store. The item is automatically returned when exiting the context.\nUsage: with store.request() as req: yield req # This yields the get event # Now we have the item from the store yield env.timeout(10) # Item is automatically returned when exiting the context\nReturns: A context manager that returns the get event and handles returning the item\n\n\n\nutils.VidigiStore.request_direct()\nAlias for get_direct() to maintain consistent API with SimPy resources.\nReturns: A get event that can be yielded"
  },
  {
    "objectID": "reference/utils.VidigiPriorityStore.html",
    "href": "reference/utils.VidigiPriorityStore.html",
    "title": "utils.VidigiPriorityStore",
    "section": "",
    "text": "utils.VidigiPriorityStore(self, env, capacity=float('inf'), init_items=None)\nAn optimized SimPy priority store that eliminates delays between resource release and acquisition by directly triggering waiting events.\nThis implementation provides the same API as the original VidigiPriorityStore but with immediate resource handoff between processes.\nAI USE DISCLOSURE: This code was generated by Claude 3.7 Sonnet. It has been evaluated and tested by a human.\n\n\n\n\n\nName\nDescription\n\n\n\n\nget\nCreate an event to get an item from the store.\n\n\nget_direct\nGet an item from the store without the context manager.\n\n\nput\nPut an item into the store.\n\n\nrequest\nRequest context manager for getting an item from the store.\n\n\nrequest_direct\nAlias for get_direct() to maintain consistent API.\n\n\nreturn_item\nReturn an item to the store and immediately process any waiting get requests.\n\n\n\n\n\nutils.VidigiPriorityStore.get(priority=0)\nCreate an event to get an item from the store.\nArgs: priority: Lower values indicate higher priority (default: 0)\nReturns: A get event that can be yielded\n\n\n\nutils.VidigiPriorityStore.get_direct(priority=0)\nGet an item from the store without the context manager. Use this if you don’t want to automatically return the item.\nReturns: A get event that can be yielded\n\n\n\nutils.VidigiPriorityStore.put(item)\nPut an item into the store.\nArgs: item: The item to put in the store\nReturns: A put event that can be yielded\n\n\n\nutils.VidigiPriorityStore.request(priority=0)\nRequest context manager for getting an item from the store. The item is automatically returned when exiting the context.\nArgs: priority: Lower values indicate higher priority (default: 0)\nReturns: A context manager that yields the get event and handles item return\n\n\n\nutils.VidigiPriorityStore.request_direct(priority=0)\nAlias for get_direct() to maintain consistent API.\nReturns: A get event that can be yielded\n\n\n\nutils.VidigiPriorityStore.return_item(item)\nReturn an item to the store and immediately process any waiting get requests.\nThis is the key to eliminating delays - it directly triggers waiting get requests without going through the normal put/get mechanism.\nArgs: item: The item to return to the store"
  },
  {
    "objectID": "reference/utils.VidigiPriorityStore.html#methods",
    "href": "reference/utils.VidigiPriorityStore.html#methods",
    "title": "utils.VidigiPriorityStore",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget\nCreate an event to get an item from the store.\n\n\nget_direct\nGet an item from the store without the context manager.\n\n\nput\nPut an item into the store.\n\n\nrequest\nRequest context manager for getting an item from the store.\n\n\nrequest_direct\nAlias for get_direct() to maintain consistent API.\n\n\nreturn_item\nReturn an item to the store and immediately process any waiting get requests.\n\n\n\n\n\nutils.VidigiPriorityStore.get(priority=0)\nCreate an event to get an item from the store.\nArgs: priority: Lower values indicate higher priority (default: 0)\nReturns: A get event that can be yielded\n\n\n\nutils.VidigiPriorityStore.get_direct(priority=0)\nGet an item from the store without the context manager. Use this if you don’t want to automatically return the item.\nReturns: A get event that can be yielded\n\n\n\nutils.VidigiPriorityStore.put(item)\nPut an item into the store.\nArgs: item: The item to put in the store\nReturns: A put event that can be yielded\n\n\n\nutils.VidigiPriorityStore.request(priority=0)\nRequest context manager for getting an item from the store. The item is automatically returned when exiting the context.\nArgs: priority: Lower values indicate higher priority (default: 0)\nReturns: A context manager that yields the get event and handles item return\n\n\n\nutils.VidigiPriorityStore.request_direct(priority=0)\nAlias for get_direct() to maintain consistent API.\nReturns: A get event that can be yielded\n\n\n\nutils.VidigiPriorityStore.return_item(item)\nReturn an item to the store and immediately process any waiting get requests.\nThis is the key to eliminating delays - it directly triggers waiting get requests without going through the normal put/get mechanism.\nArgs: item: The item to return to the store"
  },
  {
    "objectID": "reference/utils.populate_store.html",
    "href": "reference/utils.populate_store.html",
    "title": "utils.populate_store",
    "section": "",
    "text": "utils.populate_store(num_resources, simpy_store, sim_env)\nPopulate a SimPy Store (or VidigiPriorityStore) with CustomResource objects.\nThis function creates a specified number of CustomResource objects and adds them to a SimPy Store, a VidigiStore, or VidigiPriorityStore.\nEach CustomResource is initialized with a capacity of 1 and a unique ID attribute, which is crucial for animation functions where you wish to show an individual entity consistently using the same resource.\nIf using VidigiPriorityStore, you will need to pass the relevant priority in to the .get() argument when pulling a resource out of the store.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnum_resources\nint\nThe number of CustomResource objects to create and add to the store.\nrequired\n\n\nsimpy_store\nsimpy.Store or vidigi.utils.VidigiPriorityStore\nThe SimPy Store object to populate with resources.\nrequired\n\n\nsim_env\nsimpy.Environment\nThe SimPy environment in which the resources and store exist.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nEach CustomResource is created with a capacity of 1.\nThe ID attribute of each CustomResource is set to its index in the creation loop plus one, ensuring unique IDs starting from 1.\nThis function is typically used to initialize a pool of resources at the start of a simulation.\n\n\n\n\n&gt;&gt;&gt; import simpy\n&gt;&gt;&gt; env = simpy.Environment()\n&gt;&gt;&gt; resource_store = simpy.Store(env)\n&gt;&gt;&gt; populate_store(5, resource_store, env)\n&gt;&gt;&gt; len(resource_store.items)  # The store now contains 5 CustomResource objects\n5"
  },
  {
    "objectID": "reference/utils.populate_store.html#parameters",
    "href": "reference/utils.populate_store.html#parameters",
    "title": "utils.populate_store",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nnum_resources\nint\nThe number of CustomResource objects to create and add to the store.\nrequired\n\n\nsimpy_store\nsimpy.Store or vidigi.utils.VidigiPriorityStore\nThe SimPy Store object to populate with resources.\nrequired\n\n\nsim_env\nsimpy.Environment\nThe SimPy environment in which the resources and store exist.\nrequired"
  },
  {
    "objectID": "reference/utils.populate_store.html#returns",
    "href": "reference/utils.populate_store.html#returns",
    "title": "utils.populate_store",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nNone"
  },
  {
    "objectID": "reference/utils.populate_store.html#notes",
    "href": "reference/utils.populate_store.html#notes",
    "title": "utils.populate_store",
    "section": "",
    "text": "Each CustomResource is created with a capacity of 1.\nThe ID attribute of each CustomResource is set to its index in the creation loop plus one, ensuring unique IDs starting from 1.\nThis function is typically used to initialize a pool of resources at the start of a simulation."
  },
  {
    "objectID": "reference/utils.populate_store.html#examples",
    "href": "reference/utils.populate_store.html#examples",
    "title": "utils.populate_store",
    "section": "",
    "text": "&gt;&gt;&gt; import simpy\n&gt;&gt;&gt; env = simpy.Environment()\n&gt;&gt;&gt; resource_store = simpy.Store(env)\n&gt;&gt;&gt; populate_store(5, resource_store, env)\n&gt;&gt;&gt; len(resource_store.items)  # The store now contains 5 CustomResource objects\n5"
  },
  {
    "objectID": "reference/utils.EventPosition.html",
    "href": "reference/utils.EventPosition.html",
    "title": "utils.EventPosition",
    "section": "",
    "text": "utils.EventPosition()\nPydantic model for a single event position.\nThis model defines the position and label of an event within a visual layout. Coordinates represent the bottom-right corner of a queue or resource, and an optional label or resource can be associated with the event.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nevent\nstr\nThe name of the event. Must match the event names as they appear in your event log.\n\n\nx\nint\nThe x-coordinate for the event. Represents the bottom-right corner of the queue or resource.\n\n\ny\nint\nThe y-coordinate for the event. Represents the bottom-right corner of the queue or resource.\n\n\nlabel\nstr\nThe display label for the event. Used if display_stage_labels=True. Allows for a more user-friendly version of the event name (e.g., ‘Queuing for Till’).\n\n\nresource\nOptional[str]\nThe optional resource associated with the event. Must match a resource name provided in your scenario object.",
    "crumbs": [
      "vidigi Function Reference",
      "Event Positioning Utility Functions and Classes",
      "utils.EventPosition"
    ]
  },
  {
    "objectID": "reference/utils.EventPosition.html#attributes",
    "href": "reference/utils.EventPosition.html#attributes",
    "title": "utils.EventPosition",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nevent\nstr\nThe name of the event. Must match the event names as they appear in your event log.\n\n\nx\nint\nThe x-coordinate for the event. Represents the bottom-right corner of the queue or resource.\n\n\ny\nint\nThe y-coordinate for the event. Represents the bottom-right corner of the queue or resource.\n\n\nlabel\nstr\nThe display label for the event. Used if display_stage_labels=True. Allows for a more user-friendly version of the event name (e.g., ‘Queuing for Till’).\n\n\nresource\nOptional[str]\nThe optional resource associated with the event. Must match a resource name provided in your scenario object.",
    "crumbs": [
      "vidigi Function Reference",
      "Event Positioning Utility Functions and Classes",
      "utils.EventPosition"
    ]
  },
  {
    "objectID": "reference/utils.CustomResource.html",
    "href": "reference/utils.CustomResource.html",
    "title": "utils.CustomResource",
    "section": "",
    "text": "utils.CustomResource(self, env, capacity, id_attribute=None)\nA custom resource class that extends simpy.Resource with an additional ID attribute.\nThis class allows for more detailed tracking and management of resources in a simulation by adding an ID attribute to each resource instance.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nenv\nsimpy.Environment\nThe SimPy environment in which this resource exists.\nrequired\n\n\ncapacity\nint\nThe capacity of the resource (how many units can be in use simultaneously).\nrequired\n\n\nid_attribute\nany\nAn identifier for the resource (default is None).\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nid_attribute\nany\nAn identifier for the resource, which can be used for custom tracking or logic.\n\n\n\n\n\n\nThis class inherits from simpy.Resource and overrides the request and release methods to allow for custom handling of the id_attribute. The actual implementation of ID assignment or reset logic should be added by the user as needed.\n\n\n\nenv = simpy.Environment()\ncustom_resource = CustomResource(env, capacity=1, id_attribute=\"Resource_1\")\ndef process(env, resource):\n    with resource.request() as req:\n        yield req\n        print(f\"Using resource with ID: {resource.id_attribute}\")\n        yield env.timeout(1)\nenv.process(process(env, custom_resource))\nenv.run()\nUsing resource with ID: Resource_1\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nrelease\nRelease the resource.\n\n\nrequest\nRequest the resource.\n\n\n\n\n\nutils.CustomResource.release(*args, **kwargs)\nRelease the resource.\nThis method can be customized to handle the ID attribute when a release is made. Currently, it simply calls the parent class’s release method.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nutils.CustomResource.request(*args, **kwargs)\nRequest the resource.\nThis method can be customized to handle the ID attribute when a request is made. Currently, it simply calls the parent class’s request method.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nsimpy.events.Request\nA SimPy request event."
  },
  {
    "objectID": "reference/utils.CustomResource.html#parameters",
    "href": "reference/utils.CustomResource.html#parameters",
    "title": "utils.CustomResource",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nenv\nsimpy.Environment\nThe SimPy environment in which this resource exists.\nrequired\n\n\ncapacity\nint\nThe capacity of the resource (how many units can be in use simultaneously).\nrequired\n\n\nid_attribute\nany\nAn identifier for the resource (default is None).\nNone"
  },
  {
    "objectID": "reference/utils.CustomResource.html#attributes",
    "href": "reference/utils.CustomResource.html#attributes",
    "title": "utils.CustomResource",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nid_attribute\nany\nAn identifier for the resource, which can be used for custom tracking or logic."
  },
  {
    "objectID": "reference/utils.CustomResource.html#notes",
    "href": "reference/utils.CustomResource.html#notes",
    "title": "utils.CustomResource",
    "section": "",
    "text": "This class inherits from simpy.Resource and overrides the request and release methods to allow for custom handling of the id_attribute. The actual implementation of ID assignment or reset logic should be added by the user as needed."
  },
  {
    "objectID": "reference/utils.CustomResource.html#examples",
    "href": "reference/utils.CustomResource.html#examples",
    "title": "utils.CustomResource",
    "section": "",
    "text": "env = simpy.Environment()\ncustom_resource = CustomResource(env, capacity=1, id_attribute=\"Resource_1\")\ndef process(env, resource):\n    with resource.request() as req:\n        yield req\n        print(f\"Using resource with ID: {resource.id_attribute}\")\n        yield env.timeout(1)\nenv.process(process(env, custom_resource))\nenv.run()\nUsing resource with ID: Resource_1"
  },
  {
    "objectID": "reference/utils.CustomResource.html#methods",
    "href": "reference/utils.CustomResource.html#methods",
    "title": "utils.CustomResource",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nrelease\nRelease the resource.\n\n\nrequest\nRequest the resource.\n\n\n\n\n\nutils.CustomResource.release(*args, **kwargs)\nRelease the resource.\nThis method can be customized to handle the ID attribute when a release is made. Currently, it simply calls the parent class’s release method.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nutils.CustomResource.request(*args, **kwargs)\nRequest the resource.\nThis method can be customized to handle the ID attribute when a request is made. Currently, it simply calls the parent class’s request method.\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nsimpy.events.Request\nA SimPy request event."
  },
  {
    "objectID": "reference/resources.VidigiStore.html",
    "href": "reference/resources.VidigiStore.html",
    "title": "resources.VidigiStore",
    "section": "",
    "text": "resources.VidigiStore(self, env, num_resources=None, capacity=float('inf'))\nA wrapper around SimPy’s Store that allows using a context manager pattern similar to resource requests.\nThis allows code like:\nwith store.request() as req: yield req # Use the item that was obtained yield env.timeout(10) # Item is automatically returned when exiting the context\nAI USE DISCLOSURE: This code was generated by Claude 3.7 Sonnet. It has been evaluated and tested by a human.\n\n\n\n\n\nName\nDescription\n\n\n\n\ncapacity\nGet the capacity of the store\n\n\nitems\nGet all items currently in the store\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncancel_get\nCancels a pending get request by removing it from the queue.\n\n\nget\nAlias for request() to maintain compatibility with both patterns.\n\n\nget_direct\nGet an item from the store without the context manager.\n\n\npopulate\nPopulate this VidigiStore with VidigiResource objects.\n\n\nput\nPut an item into the store.\n\n\nrequest\nRequest context manager for getting an item from the store.\n\n\nrequest_direct\nAlias for get_direct() to maintain consistent API with SimPy resources.\n\n\n\n\n\nresources.VidigiStore.cancel_get(get_event)\nCancels a pending get request by removing it from the queue.\n\n\n\nresources.VidigiStore.get()\nAlias for request() to maintain compatibility with both patterns.\nReturns: A context manager for getting an item\n\n\n\nresources.VidigiStore.get_direct()\nGet an item from the store without the context manager. Use this if you don’t want to automatically return the item.\nReturns: A get event that can be yielded\n\n\n\nresources.VidigiStore.populate(num_resources)\nPopulate this VidigiStore with VidigiResource objects.\nCreates num_resources VidigiResource objects and adds them to this store.\nEach VidigiResource is initialized with a capacity of 1 and a unique ID starting at 1.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnum_resources\nint\nThe number of VidigiResource objects to create and add to the store.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nresources.VidigiStore.put(item)\nPut an item into the store.\nArgs: item: The item to put in the store\n\n\n\nresources.VidigiStore.request()\nRequest context manager for getting an item from the store. The item is automatically returned when exiting the context.\nUsage: with store.request() as req: yield req # This yields the get event # Now we have the item from the store yield env.timeout(10) # Item is automatically returned when exiting the context\nReturns: A context manager that returns the get event and handles returning the item\n\n\n\nresources.VidigiStore.request_direct()\nAlias for get_direct() to maintain consistent API with SimPy resources.\nReturns: A get event that can be yielded",
    "crumbs": [
      "vidigi Function Reference",
      "Simpy Resource Classes",
      "resources.VidigiStore"
    ]
  },
  {
    "objectID": "reference/resources.VidigiStore.html#attributes",
    "href": "reference/resources.VidigiStore.html#attributes",
    "title": "resources.VidigiStore",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncapacity\nGet the capacity of the store\n\n\nitems\nGet all items currently in the store",
    "crumbs": [
      "vidigi Function Reference",
      "Simpy Resource Classes",
      "resources.VidigiStore"
    ]
  },
  {
    "objectID": "reference/resources.VidigiStore.html#methods",
    "href": "reference/resources.VidigiStore.html#methods",
    "title": "resources.VidigiStore",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncancel_get\nCancels a pending get request by removing it from the queue.\n\n\nget\nAlias for request() to maintain compatibility with both patterns.\n\n\nget_direct\nGet an item from the store without the context manager.\n\n\npopulate\nPopulate this VidigiStore with VidigiResource objects.\n\n\nput\nPut an item into the store.\n\n\nrequest\nRequest context manager for getting an item from the store.\n\n\nrequest_direct\nAlias for get_direct() to maintain consistent API with SimPy resources.\n\n\n\n\n\nresources.VidigiStore.cancel_get(get_event)\nCancels a pending get request by removing it from the queue.\n\n\n\nresources.VidigiStore.get()\nAlias for request() to maintain compatibility with both patterns.\nReturns: A context manager for getting an item\n\n\n\nresources.VidigiStore.get_direct()\nGet an item from the store without the context manager. Use this if you don’t want to automatically return the item.\nReturns: A get event that can be yielded\n\n\n\nresources.VidigiStore.populate(num_resources)\nPopulate this VidigiStore with VidigiResource objects.\nCreates num_resources VidigiResource objects and adds them to this store.\nEach VidigiResource is initialized with a capacity of 1 and a unique ID starting at 1.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnum_resources\nint\nThe number of VidigiResource objects to create and add to the store.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nresources.VidigiStore.put(item)\nPut an item into the store.\nArgs: item: The item to put in the store\n\n\n\nresources.VidigiStore.request()\nRequest context manager for getting an item from the store. The item is automatically returned when exiting the context.\nUsage: with store.request() as req: yield req # This yields the get event # Now we have the item from the store yield env.timeout(10) # Item is automatically returned when exiting the context\nReturns: A context manager that returns the get event and handles returning the item\n\n\n\nresources.VidigiStore.request_direct()\nAlias for get_direct() to maintain consistent API with SimPy resources.\nReturns: A get event that can be yielded",
    "crumbs": [
      "vidigi Function Reference",
      "Simpy Resource Classes",
      "resources.VidigiStore"
    ]
  },
  {
    "objectID": "reference/resources.VidigiPriorityStoreLegacy.html",
    "href": "reference/resources.VidigiPriorityStoreLegacy.html",
    "title": "resources.VidigiPriorityStoreLegacy",
    "section": "",
    "text": "resources.VidigiPriorityStoreLegacy()\nA SimPy store that processes requests with priority.\nThis class extends the SimPy Store to include a priority queue for handling requests. Requests are processed based on their priority, submission time, and preemption flag.\nAttributes: GetQueue (class): A reference to the sorted queue implementation used for handling prioritized requests. get (class): A reference to the PriorityGet class, which handles the creation of prioritized requests.\n\n\nCredit to arabinelli # https://stackoverflow.com/questions/58603000/how-do-i-make-a-priority-get-request-from-resource-store",
    "crumbs": [
      "vidigi Function Reference",
      "legacy Functions",
      "resources.VidigiPriorityStoreLegacy"
    ]
  },
  {
    "objectID": "reference/resources.VidigiPriorityStoreLegacy.html#notes",
    "href": "reference/resources.VidigiPriorityStoreLegacy.html#notes",
    "title": "resources.VidigiPriorityStoreLegacy",
    "section": "",
    "text": "Credit to arabinelli # https://stackoverflow.com/questions/58603000/how-do-i-make-a-priority-get-request-from-resource-store",
    "crumbs": [
      "vidigi Function Reference",
      "legacy Functions",
      "resources.VidigiPriorityStoreLegacy"
    ]
  },
  {
    "objectID": "reference/resources.populate_store.html",
    "href": "reference/resources.populate_store.html",
    "title": "resources.populate_store",
    "section": "",
    "text": "resources.populate_store(num_resources, simpy_store, sim_env)\nPopulate a SimPy Store (or VidigiPriorityStore) with VidigiResource objects.\nThis function creates a specified number of VidigiResource objects and adds them to a SimPy Store, a VidigiStore, or VidigiPriorityStore.\nEach VidigiResource is initialized with a capacity of 1 and a unique ID attribute, which is crucial for animation functions where you wish to show an individual entity consistently using the same resource.\nIf using VidigiPriorityStore, you will need to pass the relevant priority in to the .get() argument when pulling a resource out of the store.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnum_resources\nint\nThe number of VidigiResource objects to create and add to the store.\nrequired\n\n\nsimpy_store\n(simpy.Store, vidigi.resources.VidigiStore or vidigi.resources.VidigiPriorityStore)\nThe SimPy Store object to populate with resources.\nrequired\n\n\nsim_env\nsimpy.Environment\nThe SimPy environment in which the resources and store exist.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nEach VidigiResource is created with a capacity of 1.\nThe ID attribute of each VidigiResource is set to its index in the creation loop plus one, ensuring unique IDs starting from 1.\nThis function is typically used to initialize a pool of resources at the start of a simulation.\n\n\n\n\n&gt;&gt;&gt; import simpy\n&gt;&gt;&gt; env = simpy.Environment()\n&gt;&gt;&gt; resource_store = simpy.Store(env)\n&gt;&gt;&gt; populate_store(5, resource_store, env)\n&gt;&gt;&gt; len(resource_store.items)  # The store now contains 5 VidigiResource objects\n5",
    "crumbs": [
      "vidigi Function Reference",
      "Simpy Resource Classes",
      "resources.populate_store"
    ]
  },
  {
    "objectID": "reference/resources.populate_store.html#parameters",
    "href": "reference/resources.populate_store.html#parameters",
    "title": "resources.populate_store",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nnum_resources\nint\nThe number of VidigiResource objects to create and add to the store.\nrequired\n\n\nsimpy_store\n(simpy.Store, vidigi.resources.VidigiStore or vidigi.resources.VidigiPriorityStore)\nThe SimPy Store object to populate with resources.\nrequired\n\n\nsim_env\nsimpy.Environment\nThe SimPy environment in which the resources and store exist.\nrequired",
    "crumbs": [
      "vidigi Function Reference",
      "Simpy Resource Classes",
      "resources.populate_store"
    ]
  },
  {
    "objectID": "reference/resources.populate_store.html#returns",
    "href": "reference/resources.populate_store.html#returns",
    "title": "resources.populate_store",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nNone",
    "crumbs": [
      "vidigi Function Reference",
      "Simpy Resource Classes",
      "resources.populate_store"
    ]
  },
  {
    "objectID": "reference/resources.populate_store.html#notes",
    "href": "reference/resources.populate_store.html#notes",
    "title": "resources.populate_store",
    "section": "",
    "text": "Each VidigiResource is created with a capacity of 1.\nThe ID attribute of each VidigiResource is set to its index in the creation loop plus one, ensuring unique IDs starting from 1.\nThis function is typically used to initialize a pool of resources at the start of a simulation.",
    "crumbs": [
      "vidigi Function Reference",
      "Simpy Resource Classes",
      "resources.populate_store"
    ]
  },
  {
    "objectID": "reference/resources.populate_store.html#examples",
    "href": "reference/resources.populate_store.html#examples",
    "title": "resources.populate_store",
    "section": "",
    "text": "&gt;&gt;&gt; import simpy\n&gt;&gt;&gt; env = simpy.Environment()\n&gt;&gt;&gt; resource_store = simpy.Store(env)\n&gt;&gt;&gt; populate_store(5, resource_store, env)\n&gt;&gt;&gt; len(resource_store.items)  # The store now contains 5 VidigiResource objects\n5",
    "crumbs": [
      "vidigi Function Reference",
      "Simpy Resource Classes",
      "resources.populate_store"
    ]
  },
  {
    "objectID": "reference/prep.generate_animation_df.html",
    "href": "reference/prep.generate_animation_df.html",
    "title": "prep.generate_animation_df",
    "section": "",
    "text": "prep.generate_animation_df(\n    full_entity_df,\n    event_position_df,\n    wrap_queues_at=20,\n    wrap_resources_at=20,\n    step_snapshot_max=50,\n    gap_between_entities=10,\n    gap_between_resources=10,\n    gap_between_resource_rows=30,\n    gap_between_queue_rows=30,\n    time_col_name='time',\n    entity_col_name='entity_id',\n    event_type_col_name='event_type',\n    event_col_name='event',\n    resource_col_name='resource_id',\n    debug_mode=False,\n    custom_entity_icon_list=None,\n    include_fun_emojis=False,\n)\nGenerate a DataFrame for animation purposes by adding position information to entity data.\nThis function takes entity event data and adds positional information for visualization, handling both queuing and resource use events.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfull_entity_df\npd.DataFrame\nOutput of reshape_for_animation(), containing entity event data.\nrequired\n\n\nevent_position_df\npd.DataFrame\nDataFrame with columns ‘event’, ‘x’, and ‘y’, specifying initial positions for each event type.\nrequired\n\n\nwrap_queues_at\nint\nNumber of entities in a queue before wrapping to a new row (default is 20).\n20\n\n\nwrap_resources_at\nint\nNumber of resources to show before wrapping to a new row (default is 20).\n20\n\n\nstep_snapshot_max\nint\nMaximum number of patients to show in each snapshot (default is 50).\n50\n\n\ngap_between_entities\nint\nHorizontal spacing between entities in pixels (default is 10).\n10\n\n\ngap_between_resources\nint\nHorizontal spacing between resources in pixels (default is 10).\n10\n\n\ngap_between_queue_rows\nint\nVertical spacing between rows in pixels (default is 30).\n30\n\n\ngap_between_resource_rows\nint\nVertical spacing between rows in pixels (default is 30).\n30\n\n\ntime_col_name\nstr\nName of the column in event_log that contains the timestamp of each event. Timestamps should represent the number of time units since the simulation began.\n\"time\"\n\n\nentity_col_name\nstr\nName of the column in event_log that contains the unique identifier for each entity (e.g., “entity_id”, “entity”, “patient”, “patient_id”, “customer”, “ID”).\n\"entity_id\"\n\n\nevent_type_col_name\nstr\nName of the column in event_log that specifies the category of the event. Supported event types include ‘arrival_departure’, ‘resource_use’, ‘resource_use_end’, and ‘queue’.\n\"event_type\"\n\n\nresource_col_name\nstr\nName of the column for the resource identifier. Used for ‘resource_use’ events.\n\"resource_id\"\n\n\nevent_col_name\nstr\nName of the column in event_log that specifies the actual event that occurred.\n\"event\"\n\n\ndebug_mode\nbool\nIf True, print debug information during processing (default is False).\nFalse\n\n\ncustom_entity_icon_list\nlist\nIf provided, will be used as the list for entity icons. Once the end of the list is reached, it will loop back around to the beginning (so e.g. if a list of 8 icons is provided, entities 1 to 8 will use the provided emoji list, and then entity 9 will use the same icon as entity 1, and so on.)\nNone\n\n\ninclude_fun_emojis\nbool\nIf True, include the more ‘fun’ emojis, such as Santa Claus. Ignored if a custom entity icon list is passed.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\nA DataFrame with added columns for x and y positions, and icons for each entity.\n\n\n\n\n\n\n\nThe function handles both queuing and resource use events differently.\nIt assigns unique icons to entities for visualization.\nQueues can be wrapped to multiple rows if they exceed a specified length.\nThe function adds a visual indicator for additional entities when exceeding the snapshot limit.\n\n\n\n\n\nWrite a test to ensure that no entity ID appears in multiple places at a single time unit.",
    "crumbs": [
      "vidigi Function Reference",
      "Step-By-Step Functions",
      "prep.generate_animation_df"
    ]
  },
  {
    "objectID": "reference/prep.generate_animation_df.html#parameters",
    "href": "reference/prep.generate_animation_df.html#parameters",
    "title": "prep.generate_animation_df",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nfull_entity_df\npd.DataFrame\nOutput of reshape_for_animation(), containing entity event data.\nrequired\n\n\nevent_position_df\npd.DataFrame\nDataFrame with columns ‘event’, ‘x’, and ‘y’, specifying initial positions for each event type.\nrequired\n\n\nwrap_queues_at\nint\nNumber of entities in a queue before wrapping to a new row (default is 20).\n20\n\n\nwrap_resources_at\nint\nNumber of resources to show before wrapping to a new row (default is 20).\n20\n\n\nstep_snapshot_max\nint\nMaximum number of patients to show in each snapshot (default is 50).\n50\n\n\ngap_between_entities\nint\nHorizontal spacing between entities in pixels (default is 10).\n10\n\n\ngap_between_resources\nint\nHorizontal spacing between resources in pixels (default is 10).\n10\n\n\ngap_between_queue_rows\nint\nVertical spacing between rows in pixels (default is 30).\n30\n\n\ngap_between_resource_rows\nint\nVertical spacing between rows in pixels (default is 30).\n30\n\n\ntime_col_name\nstr\nName of the column in event_log that contains the timestamp of each event. Timestamps should represent the number of time units since the simulation began.\n\"time\"\n\n\nentity_col_name\nstr\nName of the column in event_log that contains the unique identifier for each entity (e.g., “entity_id”, “entity”, “patient”, “patient_id”, “customer”, “ID”).\n\"entity_id\"\n\n\nevent_type_col_name\nstr\nName of the column in event_log that specifies the category of the event. Supported event types include ‘arrival_departure’, ‘resource_use’, ‘resource_use_end’, and ‘queue’.\n\"event_type\"\n\n\nresource_col_name\nstr\nName of the column for the resource identifier. Used for ‘resource_use’ events.\n\"resource_id\"\n\n\nevent_col_name\nstr\nName of the column in event_log that specifies the actual event that occurred.\n\"event\"\n\n\ndebug_mode\nbool\nIf True, print debug information during processing (default is False).\nFalse\n\n\ncustom_entity_icon_list\nlist\nIf provided, will be used as the list for entity icons. Once the end of the list is reached, it will loop back around to the beginning (so e.g. if a list of 8 icons is provided, entities 1 to 8 will use the provided emoji list, and then entity 9 will use the same icon as entity 1, and so on.)\nNone\n\n\ninclude_fun_emojis\nbool\nIf True, include the more ‘fun’ emojis, such as Santa Claus. Ignored if a custom entity icon list is passed.\nFalse",
    "crumbs": [
      "vidigi Function Reference",
      "Step-By-Step Functions",
      "prep.generate_animation_df"
    ]
  },
  {
    "objectID": "reference/prep.generate_animation_df.html#returns",
    "href": "reference/prep.generate_animation_df.html#returns",
    "title": "prep.generate_animation_df",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\npd.DataFrame\nA DataFrame with added columns for x and y positions, and icons for each entity.",
    "crumbs": [
      "vidigi Function Reference",
      "Step-By-Step Functions",
      "prep.generate_animation_df"
    ]
  },
  {
    "objectID": "reference/prep.generate_animation_df.html#notes",
    "href": "reference/prep.generate_animation_df.html#notes",
    "title": "prep.generate_animation_df",
    "section": "",
    "text": "The function handles both queuing and resource use events differently.\nIt assigns unique icons to entities for visualization.\nQueues can be wrapped to multiple rows if they exceed a specified length.\nThe function adds a visual indicator for additional entities when exceeding the snapshot limit.",
    "crumbs": [
      "vidigi Function Reference",
      "Step-By-Step Functions",
      "prep.generate_animation_df"
    ]
  },
  {
    "objectID": "reference/prep.generate_animation_df.html#todo",
    "href": "reference/prep.generate_animation_df.html#todo",
    "title": "prep.generate_animation_df",
    "section": "",
    "text": "Write a test to ensure that no entity ID appears in multiple places at a single time unit.",
    "crumbs": [
      "vidigi Function Reference",
      "Step-By-Step Functions",
      "prep.generate_animation_df"
    ]
  },
  {
    "objectID": "reference/index.html#all-in-one-animation-functions",
    "href": "reference/index.html#all-in-one-animation-functions",
    "title": "All Functions",
    "section": "All-In-One Animation Functions",
    "text": "All-In-One Animation Functions\n\n\n\nanimation.animate_activity_log\nGenerate an animated visualization of patient flow through a system.",
    "crumbs": [
      "vidigi Function Reference",
      "All Functions"
    ]
  },
  {
    "objectID": "reference/index.html#step-by-step-functions",
    "href": "reference/index.html#step-by-step-functions",
    "title": "All Functions",
    "section": "Step-By-Step Functions",
    "text": "Step-By-Step Functions\n\n\n\nprep.reshape_for_animations\nReshape event log data for animation purposes.\n\n\nprep.generate_animation_df\nGenerate a DataFrame for animation purposes by adding position information to entity data.\n\n\nanimation.generate_animation\nGenerate an animated visualization of patient flow through a system.",
    "crumbs": [
      "vidigi Function Reference",
      "All Functions"
    ]
  },
  {
    "objectID": "reference/index.html#animation-enhancers",
    "href": "reference/index.html#animation-enhancers",
    "title": "All Functions",
    "section": "Animation Enhancers",
    "text": "Animation Enhancers\n\n\n\nanimation.add_repeating_overlay\nAdd a repeating overlay (rectangle and text) to an animated Plotly figure using traces.",
    "crumbs": [
      "vidigi Function Reference",
      "All Functions"
    ]
  },
  {
    "objectID": "reference/index.html#simpy-resource-classes",
    "href": "reference/index.html#simpy-resource-classes",
    "title": "All Functions",
    "section": "Simpy Resource Classes",
    "text": "Simpy Resource Classes\n\n\n\nresources.VidigiResource\nA simple resource class with an ID attribute for use in VidigiStore and VidigiPriorityStore.\n\n\nresources.VidigiStore\nA wrapper around SimPy’s Store that allows using a context manager pattern\n\n\nresources.VidigiPriorityStore\nAn optimized SimPy priority store that eliminates delays between resource\n\n\nresources.populate_store\nPopulate a SimPy Store (or VidigiPriorityStore) with VidigiResource objects.",
    "crumbs": [
      "vidigi Function Reference",
      "All Functions"
    ]
  },
  {
    "objectID": "reference/index.html#event-logging-utility-functions-and-classes",
    "href": "reference/index.html#event-logging-utility-functions-and-classes",
    "title": "All Functions",
    "section": "Event Logging Utility Functions and Classes",
    "text": "Event Logging Utility Functions and Classes\n\n\n\nlogging.EventLogger",
    "crumbs": [
      "vidigi Function Reference",
      "All Functions"
    ]
  },
  {
    "objectID": "reference/index.html#event-positioning-utility-functions-and-classes",
    "href": "reference/index.html#event-positioning-utility-functions-and-classes",
    "title": "All Functions",
    "section": "Event Positioning Utility Functions and Classes",
    "text": "Event Positioning Utility Functions and Classes\n\n\n\nutils.EventPosition\nPydantic model for a single event position.\n\n\nutils.create_event_position_df\nCreates a DataFrame for event positions from a list of EventPosition objects.",
    "crumbs": [
      "vidigi Function Reference",
      "All Functions"
    ]
  },
  {
    "objectID": "reference/index.html#streamlit-utility-functions",
    "href": "reference/index.html#streamlit-utility-functions",
    "title": "All Functions",
    "section": "Streamlit Utility Functions",
    "text": "Streamlit Utility Functions\n\n\n\nutils.streamlit_play_all\nProgrammatically triggers all ‘Play’ buttons in Plotly animations embedded in Streamlit using JavaScript.",
    "crumbs": [
      "vidigi Function Reference",
      "All Functions"
    ]
  },
  {
    "objectID": "reference/index.html#ciw-utility-functions",
    "href": "reference/index.html#ciw-utility-functions",
    "title": "All Functions",
    "section": "ciw Utility Functions",
    "text": "ciw Utility Functions\n\n\n\nciw.event_log_from_ciw_recs\nGiven the ciw recs object, return a dataframe in the format expected by the vidigi",
    "crumbs": [
      "vidigi Function Reference",
      "All Functions"
    ]
  },
  {
    "objectID": "reference/index.html#legacy-functions",
    "href": "reference/index.html#legacy-functions",
    "title": "All Functions",
    "section": "legacy Functions",
    "text": "legacy Functions\n\n\n\nresources.VidigiPriorityStoreLegacy\nA SimPy store that processes requests with priority.",
    "crumbs": [
      "vidigi Function Reference",
      "All Functions"
    ]
  },
  {
    "objectID": "reference/animation.generate_animation.html",
    "href": "reference/animation.generate_animation.html",
    "title": "animation.generate_animation",
    "section": "",
    "text": "animation.generate_animation(\n    full_entity_df_plus_pos,\n    event_position_df,\n    scenario=None,\n    time_col_name='time',\n    entity_col_name='entity_id',\n    event_col_name='event',\n    resource_col_name='resource_id',\n    pathway_col_name=None,\n    simulation_time_unit='minutes',\n    plotly_height=900,\n    plotly_width=None,\n    include_play_button=True,\n    add_background_image=None,\n    display_stage_labels=True,\n    entity_icon_size=24,\n    text_size=24,\n    resource_icon_size=24,\n    override_x_max=None,\n    override_y_max=None,\n    time_display_units=None,\n    start_date=None,\n    start_time=None,\n    resource_opacity=0.8,\n    custom_resource_icon=None,\n    wrap_resources_at=20,\n    gap_between_resources=10,\n    gap_between_resource_rows=30,\n    setup_mode=False,\n    frame_duration=400,\n    frame_transition_duration=600,\n    debug_mode=False,\n    background_image_opacity=0.5,\n    overflow_text_color='black',\n    stage_label_text_colour='black',\n    backend='express',\n)\nGenerate an animated visualization of patient flow through a system.\n\nThis function creates an interactive Plotly animation based on patient data and event positions.\n\n\nfull_entity_df_plus_pos : pd.DataFrame\n    DataFrame containing entity data with position information.\n    This will be the output of passing an event log through the reshape_for_animations()\n    and generate_animation_df() functions\nevent_position_df : pd.DataFrame\n    DataFrame specifying the positions of different events.\nscenario : object, optional\n    Object containing attributes for resource counts at different steps.\n    time_col_name : str, default=\"time\"\n    Name of the column in `event_log` that contains the timestamp of each event.\n    Timestamps should represent the number of time units since the simulation began.\nentity_col_name : str, default=\"entity_id\"\n    Name of the column in `event_log` that contains the unique identifier for each entity\n    (e.g., \"entity_id\", \"entity\", \"patient\", \"patient_id\", \"customer\", \"ID\").\nevent_col_name : str, default=\"event\"\n    Name of the column in `event_log` that specifies the actual event that occurred.\npathway_col_name : str, optional, default=None\n    Name of the column in `event_log` that identifies the specific pathway or\n    process flow the entity is following. If `None`, it is assumed that pathway\n    information is not present.\nresource_col_name : str, default=\"resource_id\"\n    Name of the column for the resource identifier. Used for 'resource_use' events.\nsimulation_time_unit: string, optional\n    Time unit used within the simulation (default is minutes).\n    Possible values are 'seconds', 'minutes', 'hours', 'days', 'weeks', 'years'\nplotly_height : int, optional\n    Height of the Plotly figure in pixels (default is 900).\nplotly_width : int, optional\n    Width of the Plotly figure in pixels (default is None).\ninclude_play_button : bool, optional\n    Whether to include a play button in the animation (default is True).\nadd_background_image : str, optional\n    Path to a background image file to add to the animation (default is None).\ndisplay_stage_labels : bool, optional\n    Whether to display labels for each stage (default is True).\nentity_icon_size : int, optional\n    Size of entity icons in the animation (default is 24).\ntext_size : int, optional\n    Size of text labels in the animation (default is 24).\nresource_icon_size : int, optional\n    Size of resource icons in the animation (default is 24).\noverride_x_max : int, optional\n    Override the maximum x-coordinate (default is None).\noverride_y_max : int, optional\n    Override the maximum y-coordinate (default is None).\n    time_display_units : str, optional\n    Format for displaying time on the animation timeline. This affects how simulation time is\n    converted into human-readable dates or clock formats. If `None` (default), the raw simulation\n    time is used.\n    Predefined options:\n    'dhms' : Day Month Year + HH:MM:SS (e.g., \"06 June 2025 14:23:45\")\n    'dhms_ampm' : Same as 'dhms', but in 12-hour format with AM/PM (e.g., \"06 June 2025 02:23:45 PM\")\n    'dhm'  : Day Month Year + HH:MM (e.g., \"06 June 2025 14:23\")\n    'dhm_ampm' : 12-hour format with AM/PM (e.g., \"06 June 2025 02:23 PM\")\n    'dh'   : Day Month Year + HH (e.g., \"06 June 2025 14\")\n    'dh_ampm' : 12-hour format with AM/PM (e.g., \"06 June 2025 02 PM\")\n    'd'    : Full weekday and date (e.g., \"Friday 06 June 2025\")\n    'm'    : Month and year (e.g., \"June 2025\")\n    'y'    : Year only (e.g., \"2025\")\n    'day_clock' or 'simulation_day_clock': Show simulation-relative day and time (e.g., \"Simulation Day 3\n14:15”) ‘day_clock_ampm’ or ‘simulation_day_clock_ampm’: Same as above, but time is shown in 12-hour clock with AM/PM (e.g., “Simulation Day 3 02:15 PM”) Alternatively, you can supply a custom strftime format string (e.g., ‘%Y-%m-%d %H’) to control the display manually. start_date : str, optional Start date for the animation in ‘YYYY-MM-DD’ format. Only used when time_display_units is ‘d’ or ‘dhm’ (default is None). start_time : str, optional Start date for the animation in ‘HH:MM:SS’ format. Only used when time_display_units is ‘d’ or ‘dhm’ (default is None). resource_opacity : float, optional Opacity of resource icons (default is 0.8). custom_resource_icon : str, optional Custom icon to use for resources (default is None). wrap_resources_at : int, optional Number of resources to show before wrapping to a new row (default is 20). If this has been set elsewhere, it is also important to set it in this function to ensure the visual indicators of the resources wrap in the same way the entities using those resources do. gap_between_resources : int, optional Spacing between resources in pixels (default is 10). gap_between_resource_rows : int, optional Vertical spacing between rows in pixels (default is 30). setup_mode : bool, optional Whether to run in setup mode, showing grid and tick marks (default is False). frame_duration : int, optional Duration of each frame in milliseconds (default is 400). frame_transition_duration : int, optional Duration of transition between frames in milliseconds (default is 600). debug_mode : bool, optional Whether to run in debug mode with additional output (default is False). background_image_opacity : float, optional Opacity (0 is transparent, to 1, completely opaque) of the provided background image backend: str, optional EXPERIMENTAL. Whether to use the plotly express backend for the initial plot (default), or the experimental plotly go backend. The go approach is currently unstable and much slower. Use at your own risk.\n\n\n\nplotly.graph_objs._figure.Figure\n    An animated Plotly figure object representing the patient flow.\n\n\n\n- The function uses Plotly Express to create an animated scatter plot.\n- Time can be displayed as actual dates or as model time units.\n- The animation supports customization of icon sizes, resource representation, and animation speed.\n- A background image can be added to provide context for the patient flow.\n- If `time_display_units` is specified, the simulation time is converted into real-world\n  datetimes using the `simulation_time_unit` and optionally `start_date` and `start_time`.\n- If `start_date` and/or `start_time` are not provided, a default offset from today's date\n  is used.\n- The `snapshot_time` column is transformed to datetime strings, and a `snapshot_time_display`\n  column is created for visual display.",
    "crumbs": [
      "vidigi Function Reference",
      "Step-By-Step Functions",
      "animation.generate_animation"
    ]
  },
  {
    "objectID": "reference/animation.generate_animation.html#parameters",
    "href": "reference/animation.generate_animation.html#parameters",
    "title": "animation.generate_animation",
    "section": "",
    "text": "full_entity_df_plus_pos : pd.DataFrame\n    DataFrame containing entity data with position information.\n    This will be the output of passing an event log through the reshape_for_animations()\n    and generate_animation_df() functions\nevent_position_df : pd.DataFrame\n    DataFrame specifying the positions of different events.\nscenario : object, optional\n    Object containing attributes for resource counts at different steps.\n    time_col_name : str, default=\"time\"\n    Name of the column in `event_log` that contains the timestamp of each event.\n    Timestamps should represent the number of time units since the simulation began.\nentity_col_name : str, default=\"entity_id\"\n    Name of the column in `event_log` that contains the unique identifier for each entity\n    (e.g., \"entity_id\", \"entity\", \"patient\", \"patient_id\", \"customer\", \"ID\").\nevent_col_name : str, default=\"event\"\n    Name of the column in `event_log` that specifies the actual event that occurred.\npathway_col_name : str, optional, default=None\n    Name of the column in `event_log` that identifies the specific pathway or\n    process flow the entity is following. If `None`, it is assumed that pathway\n    information is not present.\nresource_col_name : str, default=\"resource_id\"\n    Name of the column for the resource identifier. Used for 'resource_use' events.\nsimulation_time_unit: string, optional\n    Time unit used within the simulation (default is minutes).\n    Possible values are 'seconds', 'minutes', 'hours', 'days', 'weeks', 'years'\nplotly_height : int, optional\n    Height of the Plotly figure in pixels (default is 900).\nplotly_width : int, optional\n    Width of the Plotly figure in pixels (default is None).\ninclude_play_button : bool, optional\n    Whether to include a play button in the animation (default is True).\nadd_background_image : str, optional\n    Path to a background image file to add to the animation (default is None).\ndisplay_stage_labels : bool, optional\n    Whether to display labels for each stage (default is True).\nentity_icon_size : int, optional\n    Size of entity icons in the animation (default is 24).\ntext_size : int, optional\n    Size of text labels in the animation (default is 24).\nresource_icon_size : int, optional\n    Size of resource icons in the animation (default is 24).\noverride_x_max : int, optional\n    Override the maximum x-coordinate (default is None).\noverride_y_max : int, optional\n    Override the maximum y-coordinate (default is None).\n    time_display_units : str, optional\n    Format for displaying time on the animation timeline. This affects how simulation time is\n    converted into human-readable dates or clock formats. If `None` (default), the raw simulation\n    time is used.\n    Predefined options:\n    'dhms' : Day Month Year + HH:MM:SS (e.g., \"06 June 2025 14:23:45\")\n    'dhms_ampm' : Same as 'dhms', but in 12-hour format with AM/PM (e.g., \"06 June 2025 02:23:45 PM\")\n    'dhm'  : Day Month Year + HH:MM (e.g., \"06 June 2025 14:23\")\n    'dhm_ampm' : 12-hour format with AM/PM (e.g., \"06 June 2025 02:23 PM\")\n    'dh'   : Day Month Year + HH (e.g., \"06 June 2025 14\")\n    'dh_ampm' : 12-hour format with AM/PM (e.g., \"06 June 2025 02 PM\")\n    'd'    : Full weekday and date (e.g., \"Friday 06 June 2025\")\n    'm'    : Month and year (e.g., \"June 2025\")\n    'y'    : Year only (e.g., \"2025\")\n    'day_clock' or 'simulation_day_clock': Show simulation-relative day and time (e.g., \"Simulation Day 3\n14:15”) ‘day_clock_ampm’ or ‘simulation_day_clock_ampm’: Same as above, but time is shown in 12-hour clock with AM/PM (e.g., “Simulation Day 3 02:15 PM”) Alternatively, you can supply a custom strftime format string (e.g., ‘%Y-%m-%d %H’) to control the display manually. start_date : str, optional Start date for the animation in ‘YYYY-MM-DD’ format. Only used when time_display_units is ‘d’ or ‘dhm’ (default is None). start_time : str, optional Start date for the animation in ‘HH:MM:SS’ format. Only used when time_display_units is ‘d’ or ‘dhm’ (default is None). resource_opacity : float, optional Opacity of resource icons (default is 0.8). custom_resource_icon : str, optional Custom icon to use for resources (default is None). wrap_resources_at : int, optional Number of resources to show before wrapping to a new row (default is 20). If this has been set elsewhere, it is also important to set it in this function to ensure the visual indicators of the resources wrap in the same way the entities using those resources do. gap_between_resources : int, optional Spacing between resources in pixels (default is 10). gap_between_resource_rows : int, optional Vertical spacing between rows in pixels (default is 30). setup_mode : bool, optional Whether to run in setup mode, showing grid and tick marks (default is False). frame_duration : int, optional Duration of each frame in milliseconds (default is 400). frame_transition_duration : int, optional Duration of transition between frames in milliseconds (default is 600). debug_mode : bool, optional Whether to run in debug mode with additional output (default is False). background_image_opacity : float, optional Opacity (0 is transparent, to 1, completely opaque) of the provided background image backend: str, optional EXPERIMENTAL. Whether to use the plotly express backend for the initial plot (default), or the experimental plotly go backend. The go approach is currently unstable and much slower. Use at your own risk.",
    "crumbs": [
      "vidigi Function Reference",
      "Step-By-Step Functions",
      "animation.generate_animation"
    ]
  },
  {
    "objectID": "reference/animation.generate_animation.html#returns",
    "href": "reference/animation.generate_animation.html#returns",
    "title": "animation.generate_animation",
    "section": "",
    "text": "plotly.graph_objs._figure.Figure\n    An animated Plotly figure object representing the patient flow.",
    "crumbs": [
      "vidigi Function Reference",
      "Step-By-Step Functions",
      "animation.generate_animation"
    ]
  },
  {
    "objectID": "reference/animation.generate_animation.html#notes",
    "href": "reference/animation.generate_animation.html#notes",
    "title": "animation.generate_animation",
    "section": "",
    "text": "- The function uses Plotly Express to create an animated scatter plot.\n- Time can be displayed as actual dates or as model time units.\n- The animation supports customization of icon sizes, resource representation, and animation speed.\n- A background image can be added to provide context for the patient flow.\n- If `time_display_units` is specified, the simulation time is converted into real-world\n  datetimes using the `simulation_time_unit` and optionally `start_date` and `start_time`.\n- If `start_date` and/or `start_time` are not provided, a default offset from today's date\n  is used.\n- The `snapshot_time` column is transformed to datetime strings, and a `snapshot_time_display`\n  column is created for visual display.",
    "crumbs": [
      "vidigi Function Reference",
      "Step-By-Step Functions",
      "animation.generate_animation"
    ]
  },
  {
    "objectID": "reference/animation.add_repeating_overlay.html",
    "href": "reference/animation.add_repeating_overlay.html",
    "title": "animation.add_repeating_overlay",
    "section": "",
    "text": "animation.add_repeating_overlay(\n    fig,\n    overlay_text,\n    first_start_frame,\n    on_duration_frames,\n    off_duration_frames,\n    rect_color='grey',\n    rect_opacity=0.5,\n    text_size=40,\n    text_font_color='white',\n    relative_text_position_x=0.5,\n    relative_text_position_y=0.5,\n)\nAdd a repeating overlay (rectangle and text) to an animated Plotly figure using traces.\nThis function adds overlay elements as additional traces rather than layout shapes/annotations, which enables the overlay to work without requiring redraw=True during animation. The overlay follows a repeating on/off pattern starting from a specified frame.\n\n\nfig : plotly.graph_objects.Figure The animated Plotly figure object to modify. overlay_text : str The text to display in the overlay. first_start_frame : int The frame index where the overlay first appears. Must be &gt;= 0. on_duration_frames : float The number of frames the overlay remains visible. Will be converted to int. off_duration_frames : float The number of frames the overlay is hidden between appearances. Will be converted to int. rect_color : str, default ‘grey’ The background color of the overlay rectangle. Accepts any valid CSS color string (e.g., ‘red’, ‘#FF0000’, ‘rgba(255,0,0,0.5)’). rect_opacity : float, default 0.5 The opacity of the overlay rectangle. Must be between 0 (transparent) and 1 (opaque). text_size : int, default 40 The font size of the overlay text in points. text_font_color : str, default ‘white’ The color of the overlay text. Accepts any valid CSS color string. relative_text_position_x : float, default 0.5 The horizontal position of the text within the overlay rectangle. 0.0 = left edge, 0.5 = center, 1.0 = right edge. relative_text_position_y : float, default 0.5 The vertical position of the text within the overlay rectangle. 0.0 = bottom edge, 0.5 = center, 1.0 = top edge.\n\n\n\nplotly.graph_objects.Figure The modified Plotly figure object with the repeating overlay added as traces. The original figure is modified in-place and also returned.\n\n\n\n\nThe overlay uses secondary axes (x2, y2) to position elements in paper coordinates (0 to 1 range) independent of the main plot’s data coordinates.\nThe overlay pattern repeats with a cycle length of (on_duration_frames + off_duration_frames).\nFrame indexing is 0-based, so first_start_frame=0 means the overlay starts from the first frame.\nThe condition i &gt; start_frame ensures the overlay doesn’t appear on the initial frame unless explicitly specified.\nThis implementation works without requiring redraw=True in animation configurations, making it more efficient for complex animated plots.\nreturns UserWarning If the figure has no frames, a warning is printed and the figure is returned unchanged.\nreturns UserWarning If the sum of on_duration_frames and off_duration_frames is not positive, a warning is printed and the figure is returned unchanged.",
    "crumbs": [
      "vidigi Function Reference",
      "Animation Enhancers",
      "animation.add_repeating_overlay"
    ]
  },
  {
    "objectID": "reference/animation.add_repeating_overlay.html#parameters",
    "href": "reference/animation.add_repeating_overlay.html#parameters",
    "title": "animation.add_repeating_overlay",
    "section": "",
    "text": "fig : plotly.graph_objects.Figure The animated Plotly figure object to modify. overlay_text : str The text to display in the overlay. first_start_frame : int The frame index where the overlay first appears. Must be &gt;= 0. on_duration_frames : float The number of frames the overlay remains visible. Will be converted to int. off_duration_frames : float The number of frames the overlay is hidden between appearances. Will be converted to int. rect_color : str, default ‘grey’ The background color of the overlay rectangle. Accepts any valid CSS color string (e.g., ‘red’, ‘#FF0000’, ‘rgba(255,0,0,0.5)’). rect_opacity : float, default 0.5 The opacity of the overlay rectangle. Must be between 0 (transparent) and 1 (opaque). text_size : int, default 40 The font size of the overlay text in points. text_font_color : str, default ‘white’ The color of the overlay text. Accepts any valid CSS color string. relative_text_position_x : float, default 0.5 The horizontal position of the text within the overlay rectangle. 0.0 = left edge, 0.5 = center, 1.0 = right edge. relative_text_position_y : float, default 0.5 The vertical position of the text within the overlay rectangle. 0.0 = bottom edge, 0.5 = center, 1.0 = top edge.",
    "crumbs": [
      "vidigi Function Reference",
      "Animation Enhancers",
      "animation.add_repeating_overlay"
    ]
  },
  {
    "objectID": "reference/animation.add_repeating_overlay.html#returns",
    "href": "reference/animation.add_repeating_overlay.html#returns",
    "title": "animation.add_repeating_overlay",
    "section": "",
    "text": "plotly.graph_objects.Figure The modified Plotly figure object with the repeating overlay added as traces. The original figure is modified in-place and also returned.",
    "crumbs": [
      "vidigi Function Reference",
      "Animation Enhancers",
      "animation.add_repeating_overlay"
    ]
  },
  {
    "objectID": "reference/animation.add_repeating_overlay.html#notes",
    "href": "reference/animation.add_repeating_overlay.html#notes",
    "title": "animation.add_repeating_overlay",
    "section": "",
    "text": "The overlay uses secondary axes (x2, y2) to position elements in paper coordinates (0 to 1 range) independent of the main plot’s data coordinates.\nThe overlay pattern repeats with a cycle length of (on_duration_frames + off_duration_frames).\nFrame indexing is 0-based, so first_start_frame=0 means the overlay starts from the first frame.\nThe condition i &gt; start_frame ensures the overlay doesn’t appear on the initial frame unless explicitly specified.\nThis implementation works without requiring redraw=True in animation configurations, making it more efficient for complex animated plots.\nreturns UserWarning If the figure has no frames, a warning is printed and the figure is returned unchanged.\nreturns UserWarning If the sum of on_duration_frames and off_duration_frames is not positive, a warning is printed and the figure is returned unchanged.",
    "crumbs": [
      "vidigi Function Reference",
      "Animation Enhancers",
      "animation.add_repeating_overlay"
    ]
  },
  {
    "objectID": "HISTORY.html",
    "href": "HISTORY.html",
    "title": "1.0.1 (in progress - not yet released)",
    "section": "",
    "text": "Added ‘background_image_opacity’ argument to generate_animation and animate_activity_log. Default opacity is 0.5, which matches the previous hardcoded value.\nAdded ‘overflow_text_color’ argument to generate_animation and animate_activity_log. Default is ‘black’. Overflow text refers to the ‘+ x more’ text that appears when queue lengths exceed the snapshot size.\nAdded ‘stage_label_text_colour’ argument to generate_animation and animate_activity_log. Default is ‘black’. These are the optional labels showing the stages as defined in the event position dataframe, which you may be using instead of passing in a custom background with stage labels.\nAdd ability to log custom events with non-standard event_type using the .log_custom_event() method of the EventLogger class.",
    "crumbs": [
      "Changelog"
    ]
  },
  {
    "objectID": "HISTORY.html#changelog",
    "href": "HISTORY.html#changelog",
    "title": "1.0.1 (in progress - not yet released)",
    "section": "Changelog",
    "text": "Changelog\n\nBREAKING CHANGES\n\nsignificant changes to VidigiPriorityStore\n\nBREAKING: the original implementation of VidigiPriorityStore has been renamed to VidigiPriorityStoreLegacy\n\ndefault entity column name for all prep and animation functions is now ‘entity_id’ rather than ‘patient’. This can be managed by passing in the argument entity_col_name=\"patient\" to each of these functions.\nvarious classes and functions have been moved into more appropriate files, rather than all existing in Utils.\n\nVidigiStore, VidigiPriorityStore, VidigiPriorityStoreLegacy and other resources are now in vidigi.resources\nEventLogger is now in vidigi.logging\n\nparameter icon_and_text_size has been removed and replaced with separate parameters\n\nresource_icon_size\nentity_icon_size\ntext_size\n\nparameter gap_between_rows has been removed and replaced with separate parameters for queues and resources\n\ngap_between_queue_rows\ngap_between_resource_rows\n\nCustomResource is now called VidigiResource. This generally should not cause problems as you are likely to only be accessing it indirectly through use of VidigiStore or VidigiPriorityStore.\ninit_items argument for VidigiStore and VidigiPriorityStore has been replaced with num_resources. Defaulting to none, this functions identically to the populate_stores function, but instead allows you to initialise the resource on start.\nthe dataframe expected by generate_animation_df is now full_entity_df, not full_patient_df. Only the parameter name needs updating.\nthe dataframe expected by generate_animation is now full_entity_df_plus_pos, not full_patient_df_plus_pos. Only the parameter name needs updating.\n\nNEW FEATURES:\nAdds\n\nan additional VidigiStore class to replace use of standard store\ntests to ensure identical functioning of VidigiStore, VidigiPriorityStore and VidigiPriorityStoreLegacy to their core simpy counterparts\n\nThe benefit of these new classes is that they allow the common resource requesting patterns to be used\nSo\nwith self.nurse.request() as req:\n    # Freeze the function until the request for a nurse can be met.\n    # The patient is currently queuing.\n    yield req\nwill work when using a VidigiStore or VidigiPriorityStore - mimicking the syntax of making a request from resources - while supporting the inclusion of a resource ID attribute (not possible with traditional simpy resources) that is necessary to grab for simpy.\nTo access the attribute, it does necessitate some small change -\nwith self.nurse.request() as req:\n    # Freeze the function until the request for a nurse can be met.\n    # The patient is currently queuing.\n    nurse_resource = yield req ## NEED TO ASSIGN HERE\nSo req.id_attribute would not work\nbut\nnurse_resource.id_attribute would\nThis is hopefully still a far less substantial change than was required previously, where models using resources had to switch to using .get() and .put().\nFurther testing still required for more complex request logic that incorporates aspects like reneging.\nAdditional new features:\n\nallow flexible naming of all key input columns - so you’re no longer limited to ‘patient’, ‘event’, ‘event_type’, ‘resource_id’, ‘time’, ‘pathway’.\n\nthese are now controlled with the parameters entity_col_name, event_col_name, event_type_col_name, resource_col_name\", \"time_col_name\", \"pathway_col_name\n\nadd helper class for event logging (from vidigi.logging import EventLogger)\nadd helper class and function for generating an event positioning dataframe (from vidigi.utils import EventPosition, create_event_position_df)\nadd helper function for generating a repeating overlay to the final animation, e.g. to make it clear when something like night or a clinic closure is occurring (from vidigi.animation import add_repeating_overlay\nadd in a wide range of additional ways that the simulation time can be displayed (e.g. ‘Simulation Day 1’, am/pm rather than 24 hour, or even custom strftime string)\n\n\n\nBUGFIXES\n\nfix bugs preventing the generation of ‘resourceless’ animations\nfix bugs relating to resource wrapping with multiple pools\nprevent shifting of entities to the exit position on the final frame\nfix bug leading to skipped frames when no entities present\nfix bugs with ordering of ciw logs\nfix bug with incorrect end type for resource use in ciw logs\nensure sim start and end time are respected in different situations\nensure sensible behaviour when start_time parameter is provided but start_date is not\nensure exit step always shown\n\n\n\nOTHER\n\nbump ciw example from 2.x to 3.x\nadd more complex ciw example\nadd resourceless queue examples\nadd multiple concurrent trace example",
    "crumbs": [
      "Changelog"
    ]
  },
  {
    "objectID": "HISTORY.html#migration-guide-vidigi-0.0.4-1.0.0",
    "href": "HISTORY.html#migration-guide-vidigi-0.0.4-1.0.0",
    "title": "1.0.1 (in progress - not yet released)",
    "section": "🚀 Migration Guide: vidigi 0.0.4 → 1.0.0",
    "text": "🚀 Migration Guide: vidigi 0.0.4 → 1.0.0\nThis guide will help you update your code and workflows to work with vidigi version 1.0.0, which includes breaking changes, new features, and important bug fixes.\n\n\n⚠️ Breaking Changes\n\n1. Default Entity Column Name\nWas: 'patient' Now: 'entity_id'\nUpdate your function calls OR change your entity ID column name to entity_id:\n# Before\nanimate_activity_log(event_log,  event_position_df)\n\n# After\nanimate_activity_log(event_log,  event_position_df, entity_col_name=\"patient\")\n\n\n\n2. Module Reorganization\nSome classes and functions have moved:\n\n\n\n\n\n\n\nOld Location\nNew Location\n\n\n\n\nvidigi.utils.VidigiPriorityStore\nvidigi.resources.VidigiPriorityStoreLegacy\n\n\n\nUpdate your import statements accordingly.\n\n\n\n3. Visual Parameter Changes\n\nicon_and_text_size → replaced with:\n\nresource_icon_size\nentity_icon_size\ntext_size\n\ngap_between_rows → replaced with:\n\ngap_between_queue_rows\ngap_between_resource_rows\n\n\n\n\n\n4. Parameter names for main dataframes in step-by-step functions\n\nthe dataframe expected by generate_animation_df is now full_entity_df, not full_patient_df. Only the parameter name needs updating.\nthe dataframe expected by generate_animation is now full_entity_df_plus_pos, not full_patient_df_plus_pos. Only the parameter name needs updating.\n\n\n\n5. CustomResource Renamed\nCustomResource is now VidigiResource. This is typically used indirectly through VidigiStore or VidigiPriorityStore, so minimal changes may be needed unless you were using it directly.\n\n\n\n6. Resource Initialization Parameter\ninit_items has been replaced with num_resources in VidigiStore and VidigiPriorityStore.\nExample:\n\nBefore\nresource_store = VidigiStore(simulation_env, init_items=[...])\nOR\nresource_store = simpy.Store(simulation_env)\npopulate_store(5, resource_store, simulation_env)\n\n\nAfter\nresource_store = VidigiStore(simulation_env, num_resources=3)\n\n\n\n\n\n✨ New Features\n\n✅ Flexible Column Names\nYou can now customize column names in the animation and animation prep functions, meaning you are no longer tied to using ‘patient’ for your entity IDs!\n\nentity_col_name\nevent_col_name\nevent_type_col_name\nresource_col_name\ntime_col_name\npathway_col_name\n\nDefaults are\n\nentity_id\nevent\nevent_type\nresource_id\ntime\npathway\n\n(note ‘pathway’ is an optional column you may choose not to populate)\n\n\n\n✅ What You Should Do\n\nUpdate your column name to ‘entity_id’ instead of ‘patient’ or pass overrides in the form of ’entity_col_name=“patient”`\nUpdate import paths\nUpdate parameter names for the main dataframe in generate_animation_df and generation_animation (if using the step-by-step animation functions instead of the all-in-one)\nSwitch from VidigiPriorityStore to VidigiPriorityStoreLegacy if you don’t want to have to make any changes to how you request resources\nReplace removed sizing and spacing parameters with new ones\nExplore new features and examples - the new resource types, event logging helpers and event positioning helpers may make your life easier!\n\n\nIf you run into issues or have questions, check out the documentation or open an issue on the repo. Thanks for upgrading!",
    "crumbs": [
      "Changelog"
    ]
  },
  {
    "objectID": "examples/feat_repeating_overlay/feat_repeating_overlay.html",
    "href": "examples/feat_repeating_overlay/feat_repeating_overlay.html",
    "title": "Highlighting different periods with a repeating overlay",
    "section": "",
    "text": "from examples.feat_repeating_overlay.feat_repeating_overlay_model_classes import Trial, g\nfrom vidigi.prep import reshape_for_animations, generate_animation_df\nfrom vidigi.animation import generate_animation, add_repeating_overlay\nfrom vidigi.utils import EventPosition, create_event_position_df\nimport os\nimport pandas as pd\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\ng.sim_duration = 60 * 24 * 7 # 7 days\ng.number_of_runs = 1\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\n4 nurses\nmy_trial.all_event_logs.head(50)\n\n\n\n\n\n\n\n\npatient\npathway\nevent_type\nevent\ntime\nresource_id\nrun\n\n\n\n\n0\n1\nSimplest\narrival_departure\narrival\n3.399660\nNaN\n0\n\n\n1\n1\nSimplest\nqueue\ntreatment_wait_begins\n3.399660\nNaN\n0\n\n\n2\n1\nSimplest\nresource_use\ntreatment_begins\n3.399660\n1.0\n0\n\n\n3\n2\nSimplest\narrival_departure\narrival\n8.497645\nNaN\n0\n\n\n4\n2\nSimplest\nqueue\ntreatment_wait_begins\n8.497645\nNaN\n0\n\n\n5\n2\nSimplest\nresource_use\ntreatment_begins\n8.497645\n2.0\n0\n\n\n6\n3\nSimplest\narrival_departure\narrival\n8.596678\nNaN\n0\n\n\n7\n3\nSimplest\nqueue\ntreatment_wait_begins\n8.596678\nNaN\n0\n\n\n8\n3\nSimplest\nresource_use\ntreatment_begins\n8.596678\n3.0\n0\n\n\n9\n4\nSimplest\narrival_departure\narrival\n8.608025\nNaN\n0\n\n\n10\n4\nSimplest\nqueue\ntreatment_wait_begins\n8.608025\nNaN\n0\n\n\n11\n4\nSimplest\nresource_use\ntreatment_begins\n8.608025\n4.0\n0\n\n\n12\n5\nSimplest\narrival_departure\narrival\n11.359739\nNaN\n0\n\n\n13\n5\nSimplest\nqueue\ntreatment_wait_begins\n11.359739\nNaN\n0\n\n\n14\n6\nSimplest\narrival_departure\narrival\n19.509442\nNaN\n0\n\n\n15\n6\nSimplest\nqueue\ntreatment_wait_begins\n19.509442\nNaN\n0\n\n\n16\n7\nSimplest\narrival_departure\narrival\n22.877356\nNaN\n0\n\n\n17\n7\nSimplest\nqueue\ntreatment_wait_begins\n22.877356\nNaN\n0\n\n\n18\n8\nSimplest\narrival_departure\narrival\n26.653863\nNaN\n0\n\n\n19\n8\nSimplest\nqueue\ntreatment_wait_begins\n26.653863\nNaN\n0\n\n\n20\n9\nSimplest\narrival_departure\narrival\n40.737793\nNaN\n0\n\n\n21\n9\nSimplest\nqueue\ntreatment_wait_begins\n40.737793\nNaN\n0\n\n\n22\n1\nSimplest\nresource_use_end\ntreatment_complete\n43.717044\n1.0\n0\n\n\n23\n1\nSimplest\narrival_departure\ndepart\n43.717044\nNaN\n0\n\n\n24\n5\nSimplest\nresource_use\ntreatment_begins\n43.717044\n1.0\n0\n\n\n25\n2\nSimplest\nresource_use_end\ntreatment_complete\n47.541216\n2.0\n0\n\n\n26\n2\nSimplest\narrival_departure\ndepart\n47.541216\nNaN\n0\n\n\n27\n6\nSimplest\nresource_use\ntreatment_begins\n47.541216\n2.0\n0\n\n\n28\n4\nSimplest\nresource_use_end\ntreatment_complete\n48.820975\n4.0\n0\n\n\n29\n4\nSimplest\narrival_departure\ndepart\n48.820975\nNaN\n0\n\n\n30\n7\nSimplest\nresource_use\ntreatment_begins\n48.820975\n4.0\n0\n\n\n31\n3\nSimplest\nresource_use_end\ntreatment_complete\n51.582490\n3.0\n0\n\n\n32\n3\nSimplest\narrival_departure\ndepart\n51.582490\nNaN\n0\n\n\n33\n8\nSimplest\nresource_use\ntreatment_begins\n51.582490\n3.0\n0\n\n\n34\n10\nSimplest\narrival_departure\narrival\n71.026558\nNaN\n0\n\n\n35\n10\nSimplest\nqueue\ntreatment_wait_begins\n71.026558\nNaN\n0\n\n\n36\n5\nSimplest\nresource_use_end\ntreatment_complete\n80.847148\n1.0\n0\n\n\n37\n5\nSimplest\narrival_departure\ndepart\n80.847148\nNaN\n0\n\n\n38\n9\nSimplest\nresource_use\ntreatment_begins\n80.847148\n1.0\n0\n\n\n39\n11\nSimplest\narrival_departure\narrival\n87.458700\nNaN\n0\n\n\n40\n11\nSimplest\nqueue\ntreatment_wait_begins\n87.458700\nNaN\n0\n\n\n41\n12\nSimplest\narrival_departure\narrival\n87.465138\nNaN\n0\n\n\n42\n12\nSimplest\nqueue\ntreatment_wait_begins\n87.465138\nNaN\n0\n\n\n43\n6\nSimplest\nresource_use_end\ntreatment_complete\n89.060237\n2.0\n0\n\n\n44\n6\nSimplest\narrival_departure\ndepart\n89.060237\nNaN\n0\n\n\n45\n10\nSimplest\nresource_use\ntreatment_begins\n89.060237\n2.0\n0\n\n\n46\n7\nSimplest\nresource_use_end\ntreatment_complete\n95.509386\n4.0\n0\n\n\n47\n7\nSimplest\narrival_departure\ndepart\n95.509386\nNaN\n0\n\n\n48\n11\nSimplest\nresource_use\ntreatment_begins\n95.509386\n4.0\n0\n\n\n49\n8\nSimplest\nresource_use_end\ntreatment_complete\n96.241403\n3.0\n0\n# Create a list of EventPosition objects\nevent_position_df = create_event_position_df([\n    EventPosition(event='arrival', x=50, y=300, label=\"Arrival\"),\n    EventPosition(event='treatment_wait_begins', x=205, y=275, label=\"Waiting for Treatment\"),\n    EventPosition(event='treatment_begins', x=205, y=175, resource='n_cubicles', label=\"Being Treated\"),\n    EventPosition(event='depart', x=270, y=70, label=\"Exit\")\n])\nmy_trial.all_event_logs[my_trial.all_event_logs['run']==0]\n\n\n\n\n\n\n\n\npatient\npathway\nevent_type\nevent\ntime\nresource_id\nrun\n\n\n\n\n0\n1\nSimplest\narrival_departure\narrival\n3.399660\nNaN\n0\n\n\n1\n1\nSimplest\nqueue\ntreatment_wait_begins\n3.399660\nNaN\n0\n\n\n2\n1\nSimplest\nresource_use\ntreatment_begins\n3.399660\n1.0\n0\n\n\n3\n2\nSimplest\narrival_departure\narrival\n8.497645\nNaN\n0\n\n\n4\n2\nSimplest\nqueue\ntreatment_wait_begins\n8.497645\nNaN\n0\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n3981\n914\nSimplest\narrival_departure\ndepart\n9374.860981\nNaN\n0\n\n\n3982\n915\nSimplest\nresource_use_end\ntreatment_complete\n9377.867245\n2.0\n0\n\n\n3983\n915\nSimplest\narrival_departure\ndepart\n9377.867245\nNaN\n0\n\n\n3984\n912\nSimplest\nresource_use_end\ntreatment_complete\n9381.404322\n4.0\n0\n\n\n3985\n912\nSimplest\narrival_departure\ndepart\n9381.404322\nNaN\n0\n\n\n\n\n3986 rows × 7 columns\nLIMIT_DURATION = g.sim_duration\nWRAP_QUEUES_AT = 15\nSTEP_SNAPSHOT_MAX = WRAP_QUEUES_AT * 4\n\nfull_patient_df = reshape_for_animations(\n    event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==0],\n    every_x_time_units=10,\n    entity_col_name=\"patient\",\n    step_snapshot_max=STEP_SNAPSHOT_MAX,\n    limit_duration=LIMIT_DURATION,\n    debug_mode=True\n    )\n\nfull_patient_df.head(15)\n\nIteration through time-unit-by-time-unit logs complete 14:23:52\nSnapshot df concatenation complete at 14:23:52\n\n\n\n\n\n\n\n\n\nsnapshot_time\nindex\npatient\npathway\nevent_type\nevent\ntime\nresource_id\nrun\nrank\nadditional\n\n\n\n\n0\n0\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\nNaN\n\n\n1\n10\n2.0\n1.0\nSimplest\nresource_use\ntreatment_begins\n3.399660\n1.0\n0.0\n1.0\nNaN\n\n\n2\n10\n5.0\n2.0\nSimplest\nresource_use\ntreatment_begins\n8.497645\n2.0\n0.0\n2.0\nNaN\n\n\n3\n10\n8.0\n3.0\nSimplest\nresource_use\ntreatment_begins\n8.596678\n3.0\n0.0\n3.0\nNaN\n\n\n4\n10\n11.0\n4.0\nSimplest\nresource_use\ntreatment_begins\n8.608025\n4.0\n0.0\n4.0\nNaN\n\n\n5\n20\n2.0\n1.0\nSimplest\nresource_use\ntreatment_begins\n3.399660\n1.0\n0.0\n1.0\nNaN\n\n\n6\n20\n5.0\n2.0\nSimplest\nresource_use\ntreatment_begins\n8.497645\n2.0\n0.0\n2.0\nNaN\n\n\n7\n20\n8.0\n3.0\nSimplest\nresource_use\ntreatment_begins\n8.596678\n3.0\n0.0\n3.0\nNaN\n\n\n8\n20\n11.0\n4.0\nSimplest\nresource_use\ntreatment_begins\n8.608025\n4.0\n0.0\n4.0\nNaN\n\n\n9\n20\n13.0\n5.0\nSimplest\nqueue\ntreatment_wait_begins\n11.359739\nNaN\n0.0\n1.0\nNaN\n\n\n10\n20\n15.0\n6.0\nSimplest\nqueue\ntreatment_wait_begins\n19.509442\nNaN\n0.0\n2.0\nNaN\n\n\n11\n30\n2.0\n1.0\nSimplest\nresource_use\ntreatment_begins\n3.399660\n1.0\n0.0\n1.0\nNaN\n\n\n12\n30\n5.0\n2.0\nSimplest\nresource_use\ntreatment_begins\n8.497645\n2.0\n0.0\n2.0\nNaN\n\n\n13\n30\n8.0\n3.0\nSimplest\nresource_use\ntreatment_begins\n8.596678\n3.0\n0.0\n3.0\nNaN\n\n\n14\n30\n11.0\n4.0\nSimplest\nresource_use\ntreatment_begins\n8.608025\n4.0\n0.0\n4.0\nNaN\nfull_patient_df_plus_pos = generate_animation_df(\n    full_entity_df=full_patient_df,\n    event_position_df=event_position_df,\n    entity_col_name=\"patient\",\n    wrap_queues_at=WRAP_QUEUES_AT,\n    step_snapshot_max=STEP_SNAPSHOT_MAX,\n    gap_between_entities=10,\n    gap_between_resources=10,\n    gap_between_resource_rows=30,\n    gap_between_queue_rows=30,\n    debug_mode=True\n    )\n\nfull_patient_df_plus_pos.sort_values(['patient', 'snapshot_time']).head(15)\n\nPlacement dataframe finished construction at 14:23:53\n\n\n\n\n\n\n\n\n\nsnapshot_time\nindex\npatient\npathway\nevent_type\nevent\ntime\nresource_id\nrun\nrank\nadditional\nx\ny_final\nlabel\nresource\nx_final\nrow\ny\nicon\n\n\n\n\n17207\n10\n2.0\n1.0\nSimplest\nresource_use\ntreatment_begins\n3.399660\n1.0\n0.0\n1.0\nNaN\n205.0\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n17208\n20\n2.0\n1.0\nSimplest\nresource_use\ntreatment_begins\n3.399660\n1.0\n0.0\n1.0\nNaN\n205.0\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n17209\n30\n2.0\n1.0\nSimplest\nresource_use\ntreatment_begins\n3.399660\n1.0\n0.0\n1.0\nNaN\n205.0\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n17210\n40\n2.0\n1.0\nSimplest\nresource_use\ntreatment_begins\n3.399660\n1.0\n0.0\n1.0\nNaN\n205.0\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n17206\n50\n2.0\n1.0\nSimplest\nresource_use\ndepart\n3.399660\n1.0\n0.0\n1.0\nNaN\n270.0\n70.0\nExit\nNone\n270.0\n0.0\nNaN\n🧔🏼\n\n\n17212\n10\n5.0\n2.0\nSimplest\nresource_use\ntreatment_begins\n8.497645\n2.0\n0.0\n2.0\nNaN\n205.0\n175.0\nBeing Treated\nn_cubicles\n195.0\n0.0\nNaN\n👨🏿‍🦯\n\n\n17213\n20\n5.0\n2.0\nSimplest\nresource_use\ntreatment_begins\n8.497645\n2.0\n0.0\n2.0\nNaN\n205.0\n175.0\nBeing Treated\nn_cubicles\n195.0\n0.0\nNaN\n👨🏿‍🦯\n\n\n17214\n30\n5.0\n2.0\nSimplest\nresource_use\ntreatment_begins\n8.497645\n2.0\n0.0\n2.0\nNaN\n205.0\n175.0\nBeing Treated\nn_cubicles\n195.0\n0.0\nNaN\n👨🏿‍🦯\n\n\n17215\n40\n5.0\n2.0\nSimplest\nresource_use\ntreatment_begins\n8.497645\n2.0\n0.0\n2.0\nNaN\n205.0\n175.0\nBeing Treated\nn_cubicles\n195.0\n0.0\nNaN\n👨🏿‍🦯\n\n\n17211\n50\n5.0\n2.0\nSimplest\nresource_use\ndepart\n8.497645\n2.0\n0.0\n2.0\nNaN\n270.0\n70.0\nExit\nNone\n260.0\n0.0\nNaN\n👨🏿‍🦯\n\n\n17222\n10\n8.0\n3.0\nSimplest\nresource_use\ntreatment_begins\n8.596678\n3.0\n0.0\n3.0\nNaN\n205.0\n175.0\nBeing Treated\nn_cubicles\n185.0\n0.0\nNaN\n👨🏻‍🦰\n\n\n17223\n20\n8.0\n3.0\nSimplest\nresource_use\ntreatment_begins\n8.596678\n3.0\n0.0\n3.0\nNaN\n205.0\n175.0\nBeing Treated\nn_cubicles\n185.0\n0.0\nNaN\n👨🏻‍🦰\n\n\n17224\n30\n8.0\n3.0\nSimplest\nresource_use\ntreatment_begins\n8.596678\n3.0\n0.0\n3.0\nNaN\n205.0\n175.0\nBeing Treated\nn_cubicles\n185.0\n0.0\nNaN\n👨🏻‍🦰\n\n\n17225\n40\n8.0\n3.0\nSimplest\nresource_use\ntreatment_begins\n8.596678\n3.0\n0.0\n3.0\nNaN\n205.0\n175.0\nBeing Treated\nn_cubicles\n185.0\n0.0\nNaN\n👨🏻‍🦰\n\n\n17226\n50\n8.0\n3.0\nSimplest\nresource_use\ntreatment_begins\n8.596678\n3.0\n0.0\n1.0\nNaN\n205.0\n175.0\nBeing Treated\nn_cubicles\n185.0\n0.0\nNaN\n👨🏻‍🦰\nfull_patient_df_plus_pos[full_patient_df_plus_pos[\"patient\"]==\"overnight_closure\"]\n\n\n\n\n\n\n\n\nsnapshot_time\nindex\npatient\npathway\nevent_type\nevent\ntime\nresource_id\nrun\nrank\nadditional\nx\ny_final\nlabel\nresource\nx_final\nrow\ny\nicon\nfig = generate_animation(\n        full_entity_df_plus_pos=full_patient_df_plus_pos.sort_values(['patient', 'snapshot_time']),\n        event_position_df= event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        debug_mode=True,\n        setup_mode=False,\n        include_play_button=True,\n        start_time=\"08:00:00\",\n        entity_icon_size=20,\n        resource_icon_size=20,\n        gap_between_resource_rows=30,\n        plotly_height=700,\n        frame_duration=800,\n        frame_transition_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        time_display_units=\"day_clock_ampm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nfig\n\nOutput animation generation complete at 14:24:04",
    "crumbs": [
      "Feature Breakdowns",
      "Highlighting different periods with a repeating overlay"
    ]
  },
  {
    "objectID": "examples/feat_repeating_overlay/feat_repeating_overlay.html#adding-the-overlay",
    "href": "examples/feat_repeating_overlay/feat_repeating_overlay.html#adding-the-overlay",
    "title": "Highlighting different periods with a repeating overlay",
    "section": "Adding the overlay",
    "text": "Adding the overlay\nIf you drag the slider through to 8pm, you will see an overlay showing the clinic is closed. This will continue through until 8am the next day.\n\nadd_repeating_overlay(\n    fig,\n    \"🌙 Clinic Closed\",\n    first_start_frame=int((60 * 12) / 10), # After 12 hours, but we only have a frame every 10 minutes\n    on_duration_frames=int((60 * 12) / 10),\n    off_duration_frames=int((60 * 12) / 10),\n    rect_color=\"navy\",\n    rect_opacity=0.1\n    )",
    "crumbs": [
      "Feature Breakdowns",
      "Highlighting different periods with a repeating overlay"
    ]
  },
  {
    "objectID": "examples/feat_repeating_overlay/feat_repeating_overlay.html#text-overlay-in-a-different-position-with-no-overall-overlay",
    "href": "examples/feat_repeating_overlay/feat_repeating_overlay.html#text-overlay-in-a-different-position-with-no-overall-overlay",
    "title": "Highlighting different periods with a repeating overlay",
    "section": "Text overlay in a different position with no overall overlay",
    "text": "Text overlay in a different position with no overall overlay\nLet’s first generate the basic fig again.\n\nfig = generate_animation(\n        full_entity_df_plus_pos=full_patient_df_plus_pos.sort_values(['patient', 'snapshot_time']),\n        event_position_df= event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        debug_mode=True,\n        setup_mode=False,\n        include_play_button=True,\n        start_time=\"08:00:00\",\n        entity_icon_size=20,\n        resource_icon_size=20,\n        gap_between_resource_rows=30,\n        plotly_height=700,\n        frame_duration=800,\n        frame_transition_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        time_display_units=\"day_clock_ampm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nfig\n\nOutput animation generation complete at 14:24:17\n\n\n                                                    \n\n\n\nadd_repeating_overlay(\n    fig,\n    \"🌙&lt;br&gt;Clinic&lt;br&gt;Closed\",\n    first_start_frame=int((60 * 12) / 10), # After 12 hours, but we only have a frame every 10 minutes\n    on_duration_frames=int((60 * 12) / 10),\n    off_duration_frames=int((60 * 12) / 10),\n    rect_opacity=0,\n    relative_text_position_x=0.85,\n    relative_text_position_y=0.7,\n    text_font_color=\"black\"\n    )",
    "crumbs": [
      "Feature Breakdowns",
      "Highlighting different periods with a repeating overlay"
    ]
  },
  {
    "objectID": "examples/example_9_wide_resource_spacing_multiple/ex_9_model.html",
    "href": "examples/example_9_wide_resource_spacing_multiple/ex_9_model.html",
    "title": "Creative Layouts - Multiple Ward Example",
    "section": "",
    "text": "import pandas as pd\n\nfrom examples.example_9_wide_resource_spacing_multiple.ex_9_model_classes import g, Trial\n\nfrom vidigi.animation import animate_activity_log\n\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\n\n\nclinic_simulation = Trial()\n\n\nclinic_simulation.trial_results\n\n\n\n\n\n\n\n\nentity_id\nevent_type\nevent\ntime\npathway\nrun_number\ntimestamp\nresource_id\n\n\n\n\n0\n1\narrival_departure\narrival\n0.000000\nNone\n1\nNone\nNaN\n\n\n1\n1\nqueue\nbed_wait_begins\n0.000000\nNone\n1\nNone\nNaN\n\n\n2\n1\nresource_use\nmaple_stay_begins\n0.000000\nNone\n1\nNone\n1.0\n\n\n3\n2\narrival_departure\narrival\n0.519445\nNone\n1\nNone\nNaN\n\n\n4\n2\nqueue\nbed_wait_begins\n0.519445\nNone\n1\nNone\nNaN\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n10272\n2143\narrival_departure\narrival\n8735.445825\nNone\n100\nNone\nNaN\n\n\n10273\n2143\nqueue\nbed_wait_begins\n8735.445825\nNone\n100\nNone\nNaN\n\n\n10274\n2144\narrival_departure\narrival\n8735.740369\nNone\n100\nNone\nNaN\n\n\n10275\n2144\nqueue\nbed_wait_begins\n8735.740369\nNone\n100\nNone\nNaN\n\n\n10276\n2144\nresource_use\nmaple_stay_begins\n8735.740369\nNone\n100\nNone\n8.0\n\n\n\n\n1050654 rows × 8 columns\n\n\n\n\nevent_position_df = pd.DataFrame([\n                    {'event': 'arrival',\n                     'x':  50, 'y': 800,\n                     'label': \"Arrival\" },\n\n                    # Triage - minor and trauma\n                    {'event': 'bed_wait_begins',\n                     'x':  505, 'y': 700,\n                     'label': \"Waiting for Bed&lt;br&gt;in Preferred Ward\"},\n\n                    {'event': 'ash_stay_begins',\n                     'x':  675, 'y': 275,\n                     'resource':'number_of_beds_ash',\n                     'label': \"Ash Ward\"},\n\n                    {'event': 'oak_stay_begins',\n                     'x':  205, 'y': 475,\n                     'resource':'number_of_beds_oak',\n                     'label': \"Oak Ward\"},\n\n                    {'event': 'maple_stay_begins',\n                     'x':  205, 'y': 175,\n                     'resource':'number_of_beds_maple',\n                     'label': \"Maple Ward\"},\n\n                    {'event': 'depart',\n                     'x':  740, 'y': 70,\n                     'label': \"Exit\"}\n\n                ])\n\n\nanimate_activity_log(\n        event_log=clinic_simulation.trial_results[clinic_simulation.trial_results['run_number']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        # Key animation prep parameters\n        every_x_time_units=3,\n        simulation_time_unit=\"hours\",\n        limit_duration=g.sim_duration,\n        step_snapshot_max=125,\n        # Animation display parameters\n        time_display_units=\"dhm\",\n        include_play_button=True,\n        setup_mode=False,\n        debug_mode=True,\n        frame_duration=500,\n        # Text parameters\n        display_stage_labels=True,\n        text_size=20,\n        # Entity and queue size and spacing\n        entity_icon_size=16,\n        wrap_queues_at=25,\n        gap_between_entities=12,\n        gap_between_queue_rows=30,\n        # Resource size and spacing\n        gap_between_resources=80,\n        gap_between_resource_rows=40,\n        resource_icon_size=25,\n        wrap_resources_at=2,\n        custom_resource_icon='🛏️',\n        custom_entity_icon_list=['🧍'],\n        # Plot size\n        plotly_height=800,\n        plotly_width=1000,\n        # Internal plot coordinates\n        override_x_max=800,\n        override_y_max=900,\n        )\n\nAnimation function called at 10:00:28\nIteration through time-unit-by-time-unit logs complete 10:00:47\nSnapshot df concatenation complete at 10:00:48\nReshaped animation dataframe finished construction at 10:00:49\nPlacement dataframe finished construction at 10:00:50\nOutput animation generation complete at 10:01:07\nTotal Time Elapsed: 39.66 seconds",
    "crumbs": [
      "SimPy Examples",
      "Creative Layouts - Multiple Ward Example"
    ]
  },
  {
    "objectID": "examples/example_7_simplest_case_priority_resource_storewrapper/ex_7_simplest_case_priority_resource.html",
    "href": "examples/example_7_simplest_case_priority_resource_storewrapper/ex_7_simplest_case_priority_resource.html",
    "title": "Using the VidigiPriorityStore to Simplify Model Code Changes with Priority Resources",
    "section": "",
    "text": "In vidigi 1.0.0, a new version of VidigiPriorityStore has been added that can be used almost exactly like a resource - reducing the amount of rewriting required to incorporate vidigi into your model.\nThis allows us to use the pattern\nwith self.treatment_cubicles.request(priority=patient.priority) as req:\n\n    treatment_resource = yield req\n\n    ### Continue all code in the indented portion that requires the resource, with the resource\n    ### automatically being returned to the store when the indented portion completes\nInstead of\ntreatment_resource = yield self.treatment_cubicles.get(priority=patient.priority)\n\n### Continue all code that requires the resource\n\nself.treatment_cubicles.put(treatment_resource)\n(even though we are still using a Store behind the scenes)\nThis minimizes the syntax changes and rewriting that are required when converting an existing model built using resources to a vidigi-compatible state.\nWhen setting up the resources, we simply use the pattern\nfrom vidigi.utils import VidigiPriorityStore, populate_store\n\n...\n\nself.treatment_cubicles = VidigiPriorityStore(self.env)\n\npopulate_store(num_resources=g.n_cubicles, # or wherever you are storing your resource counts\n               simpy_store=self.treatment_cubicles, # pass in the VidgiStore we created\n               sim_env=self.env # include the simpy env this will sit in\n               )\n\nfrom examples.example_7_simplest_case_priority_resource_storewrapper.ex_7_model_classes import Trial, g\nfrom vidigi.prep import reshape_for_animations, generate_animation_df\nfrom vidigi.animation import generate_animation, animate_activity_log\nimport pandas as pd\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\nimport os\n\n\n\n\n\n\n\nView Imported Code, which has had logging steps added at the appropriate points in the ‘model’ class\n\n\n\n\n\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\nfrom sim_tools.distributions import Exponential, Lognormal\nfrom vidigi.resources import VidigiPriorityStore\n\nclass g:\n    '''\n    Create a scenario to parameterise the simulation model\n\n    Parameters:\n    -----------\n    random_number_set: int, optional (default=DEFAULT_RNG_SET)\n        Set to control the initial seeds of each stream of pseudo\n        random numbers used in the model.\n\n    n_cubicles: int\n        The number of treatment cubicles\n\n    trauma_treat_mean: float\n        Mean of the trauma cubicle treatment distribution (Lognormal)\n\n    trauma_treat_var: float\n        Variance of the trauma cubicle treatment distribution (Lognormal)\n\n        arrival_rate: float\n        Set the mean of the exponential distribution that is used to sample the\n        inter-arrival time of patients\n\n    '''\n    random_number_set = 42\n\n    n_cubicles = 4\n    trauma_treat_mean = 40\n    trauma_treat_var = 5\n\n    arrival_rate = 5\n    sim_duration = 600\n    number_of_runs = 100\n\nclass Patient:\n    '''\n    Class defining details for a patient entity\n    '''\n    def __init__(self, p_id):\n        '''\n        Constructor method\n\n        Params:\n        -----\n        identifier: int\n            a numeric identifier for the patient.\n        '''\n        self.identifier = p_id\n        self.arrival = -np.inf\n        self.wait_treat = -np.inf\n        self.total_time = -np.inf\n        self.treat_duration = -np.inf\n\n        # Randomly initialise a patient priority value\n        # Lower values will be prioritised - so priority 1 will be seen before priority 2\n        if random.uniform(0, 1) &lt; 0.2:\n            self.priority = 1\n        else:\n            self.priority = 2\n\nclass Model:\n    '''\n    Simulates the simplest minor treatment process for a patient\n\n    1. Arrive\n    2. Examined/treated by nurse when one available\n    3. Discharged\n    '''\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        self.event_log = []\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        self.patients = []\n\n        # Create our resources\n        self.init_resources()\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Queue Time Cubicle\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_cubicle = 0\n\n        self.patient_inter_arrival_dist = Exponential(mean = g.arrival_rate,\n                                                      random_seed = self.run_number*g.random_number_set)\n        self.treat_dist = Lognormal(mean = g.trauma_treat_mean,\n                                    stdev = g.trauma_treat_var,\n                                    random_seed = self.run_number*g.random_number_set)\n\n    def init_resources(self):\n        '''\n        Init the number of resources\n        and store in the arguments container object\n\n        Resource list:\n            1. Nurses/treatment bays (same thing in this model)\n\n        '''\n        self.treatment_cubicles = VidigiPriorityStore(self.env, num_resources=g.n_cubicles)\n\n    # A generator function that represents the DES generator for patient arrivals\n    def generator_patient_arrivals(self):\n        # Use an infinite loop here to keep doing this indefinitely while the simulation runs\n        while True:\n            # Increment the patient counter by 1 (first patient will have an ID of 1)\n            self.patient_counter += 1\n\n            p = Patient(self.patient_counter)\n\n            # Store patient in list for later easy access\n            self.patients.append(p)\n\n            # Tell SimPy to start up the attend_clinic generator function with this patient\n            # (the generator function that will model the patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving\n            sampled_inter = self.patient_inter_arrival_dist.sample()\n\n            # Freeze this instance of this function in place until the inter-arrival time\n            # sampled above has elapsed\n            yield self.env.timeout(sampled_inter)\n\n    def attend_clinic(self, patient):\n        \"\"\"\n        A generator function that represents the pathway for a patient going through the clinic.\n\n        The patient object is passed in to the generator function so we can extract information\n        from / record information to it\n        \"\"\"\n        self.arrival = self.env.now\n\n        # ===== LOGGING FOR VIDIGI ANIMATION  ===== #\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': patient.priority,\n             'event_type': 'arrival_departure',\n             'event': 'arrival',\n             'time': self.env.now}\n        )\n        # ========================================= #\n\n        # request examination resource\n        start_wait = self.env.now\n\n        # ===== LOGGING FOR VIDIGI ANIMATION  ===== #\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': patient.priority,\n             'event': 'treatment_wait_begins',\n             'event_type': 'queue',\n             'time': self.env.now}\n        )\n        # ========================================= #\n\n        # Seize a treatment resource when available\n        # Note that we must pass in the patient priority\n        with self.treatment_cubicles.request(priority=patient.priority) as req:\n\n            treatment_resource = yield req\n\n            # record the waiting time for registration\n            self.wait_treat = self.env.now - start_wait\n\n            # ===== LOGGING FOR VIDIGI ANIMATION  ===== #\n            self.event_log.append(\n                {'patient': patient.identifier,\n                    'pathway': patient.priority,\n                    'event': 'treatment_begins',\n                    'event_type': 'resource_use',\n                    'time': self.env.now,\n                    'resource_id': treatment_resource.id_attribute\n                    }\n            )\n            # ========================================= #\n\n            # sample treatment duration\n            self.treat_duration = self.treat_dist.sample()\n            yield self.env.timeout(self.treat_duration)\n\n            # ===== LOGGING FOR VIDIGI ANIMATION  ===== #\n            self.event_log.append(\n                {'patient': patient.identifier,\n                    'pathway': patient.priority,\n                    'event': 'treatment_complete',\n                    'event_type': 'resource_use_end',\n                    'time': self.env.now,\n                    'resource_id': treatment_resource.id_attribute}\n            )\n            # ========================================= #\n\n\n        # total time in system\n        self.total_time = self.env.now - self.arrival\n\n        # ===== LOGGING FOR VIDIGI ANIMATION  ===== #\n        self.event_log.append(\n            {'patient': patient.identifier,\n            'pathway': patient.priority,\n            'event': 'depart',\n            'event_type': 'arrival_departure',\n            'time': self.env.now}\n        )\n        # ========================================= #\n\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_cubicle = self.results_df[\"Queue Time Cubicle\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        self.event_log = pd.DataFrame(self.event_log)\n\n        self.event_log[\"run\"] = self.run_number\n\n        return {'results': self.results_df, 'event_log': self.event_log}\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Arrivals\"] = [0]\n        self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n        self.all_event_logs = []\n\n    # Method to run a trial\n    def run_trial(self):\n        print(f\"{g.n_cubicles} nurses\")\n        print(\"\") ## Print a blank line\n\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            random.seed(run)\n\n            my_model = Model(run)\n            model_outputs = my_model.run()\n            patient_level_results = model_outputs[\"results\"]\n            event_log = model_outputs[\"event_log\"]\n\n            self.df_trial_results.loc[run] = [\n                len(patient_level_results),\n                my_model.mean_q_time_cubicle,\n            ]\n\n            # print(event_log)\n\n            self.all_event_logs.append(event_log)\n\n        self.all_event_logs = pd.concat(self.all_event_logs)\n\n\n\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\n4 nurses\n\n\n\n\nmy_trial.all_event_logs.head(50)\n\n\n\n\n\n\n\n\npatient\npathway\nevent_type\nevent\ntime\nresource_id\nrun\n\n\n\n\n0\n1\n2\narrival_departure\narrival\n0.000000\nNaN\n0\n\n\n1\n1\n2\nqueue\ntreatment_wait_begins\n0.000000\nNaN\n0\n\n\n2\n1\n2\nresource_use\ntreatment_begins\n0.000000\n1.0\n0\n\n\n3\n2\n2\narrival_departure\narrival\n3.399660\nNaN\n0\n\n\n4\n2\n2\nqueue\ntreatment_wait_begins\n3.399660\nNaN\n0\n\n\n5\n2\n2\nresource_use\ntreatment_begins\n3.399660\n2.0\n0\n\n\n6\n3\n2\narrival_departure\narrival\n8.497645\nNaN\n0\n\n\n7\n3\n2\nqueue\ntreatment_wait_begins\n8.497645\nNaN\n0\n\n\n8\n3\n2\nresource_use\ntreatment_begins\n8.497645\n3.0\n0\n\n\n9\n4\n2\narrival_departure\narrival\n8.596678\nNaN\n0\n\n\n10\n4\n2\nqueue\ntreatment_wait_begins\n8.596678\nNaN\n0\n\n\n11\n4\n2\nresource_use\ntreatment_begins\n8.596678\n4.0\n0\n\n\n12\n5\n2\narrival_departure\narrival\n8.608025\nNaN\n0\n\n\n13\n5\n2\nqueue\ntreatment_wait_begins\n8.608025\nNaN\n0\n\n\n14\n6\n2\narrival_departure\narrival\n11.359739\nNaN\n0\n\n\n15\n6\n2\nqueue\ntreatment_wait_begins\n11.359739\nNaN\n0\n\n\n16\n7\n2\narrival_departure\narrival\n19.509442\nNaN\n0\n\n\n17\n7\n2\nqueue\ntreatment_wait_begins\n19.509442\nNaN\n0\n\n\n18\n8\n2\narrival_departure\narrival\n22.877356\nNaN\n0\n\n\n19\n8\n2\nqueue\ntreatment_wait_begins\n22.877356\nNaN\n0\n\n\n20\n9\n2\narrival_departure\narrival\n26.653863\nNaN\n0\n\n\n21\n9\n2\nqueue\ntreatment_wait_begins\n26.653863\nNaN\n0\n\n\n22\n1\n2\nresource_use_end\ntreatment_complete\n40.317385\n1.0\n0\n\n\n23\n1\n2\narrival_departure\ndepart\n40.317385\nNaN\n0\n\n\n24\n5\n2\nresource_use\ntreatment_begins\n40.317385\n1.0\n0\n\n\n25\n10\n2\narrival_departure\narrival\n40.737793\nNaN\n0\n\n\n26\n10\n2\nqueue\ntreatment_wait_begins\n40.737793\nNaN\n0\n\n\n27\n2\n2\nresource_use_end\ntreatment_complete\n42.443230\n2.0\n0\n\n\n28\n2\n2\narrival_departure\ndepart\n42.443230\nNaN\n0\n\n\n29\n6\n2\nresource_use\ntreatment_begins\n42.443230\n2.0\n0\n\n\n30\n4\n2\nresource_use_end\ntreatment_complete\n48.809628\n4.0\n0\n\n\n31\n4\n2\narrival_departure\ndepart\n48.809628\nNaN\n0\n\n\n32\n7\n2\nresource_use\ntreatment_begins\n48.809628\n4.0\n0\n\n\n33\n3\n2\nresource_use_end\ntreatment_complete\n51.483457\n3.0\n0\n\n\n34\n3\n2\narrival_departure\ndepart\n51.483457\nNaN\n0\n\n\n35\n8\n2\nresource_use\ntreatment_begins\n51.483457\n3.0\n0\n\n\n36\n11\n2\narrival_departure\narrival\n71.026558\nNaN\n0\n\n\n37\n11\n2\nqueue\ntreatment_wait_begins\n71.026558\nNaN\n0\n\n\n38\n5\n2\nresource_use_end\ntreatment_complete\n77.447488\n1.0\n0\n\n\n39\n5\n2\narrival_departure\ndepart\n77.447488\nNaN\n0\n\n\n40\n9\n2\nresource_use\ntreatment_begins\n77.447488\n1.0\n0\n\n\n41\n6\n2\nresource_use_end\ntreatment_complete\n83.962251\n2.0\n0\n\n\n42\n6\n2\narrival_departure\ndepart\n83.962251\nNaN\n0\n\n\n43\n10\n2\nresource_use\ntreatment_begins\n83.962251\n2.0\n0\n\n\n44\n12\n2\narrival_departure\narrival\n87.458700\nNaN\n0\n\n\n45\n12\n2\nqueue\ntreatment_wait_begins\n87.458700\nNaN\n0\n\n\n46\n13\n2\narrival_departure\narrival\n87.465138\nNaN\n0\n\n\n47\n13\n2\nqueue\ntreatment_wait_begins\n87.465138\nNaN\n0\n\n\n48\n7\n2\nresource_use_end\ntreatment_complete\n95.498040\n4.0\n0\n\n\n49\n7\n2\narrival_departure\ndepart\n95.498040\nNaN\n0\n\n\n\n\n\n\n\n\nSTEP_SNAPSHOT_MAX = 45\nLIMIT_DURATION = g.sim_duration\nWRAP_QUEUES_AT = 15\n\n\nfull_patient_df = reshape_for_animations(\n    event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n    every_x_time_units=2,\n    entity_col_name=\"patient\",\n    step_snapshot_max=STEP_SNAPSHOT_MAX,\n    limit_duration=LIMIT_DURATION,\n    debug_mode=True\n    )\n\nfull_patient_df.head(15)\n\nIteration through time-unit-by-time-unit logs complete 12:00:08\nSnapshot df concatenation complete at 12:00:08\n\n\n\n\n\n\n\n\n\nindex\npatient\npathway\nevent_type\nevent\ntime\nresource_id\nrun\nrank\nsnapshot_time\nadditional\n\n\n\n\n0\n2\n1\n1\nresource_use\ntreatment_begins\n0.000000\n1.0\n1\n1.0\n0\nNaN\n\n\n1\n2\n1\n1\nresource_use\ntreatment_begins\n0.000000\n1.0\n1\n1.0\n2\nNaN\n\n\n2\n2\n1\n1\nresource_use\ntreatment_begins\n0.000000\n1.0\n1\n1.0\n4\nNaN\n\n\n3\n2\n1\n1\nresource_use\ntreatment_begins\n0.000000\n1.0\n1\n1.0\n6\nNaN\n\n\n4\n2\n1\n1\nresource_use\ntreatment_begins\n0.000000\n1.0\n1\n1.0\n8\nNaN\n\n\n5\n2\n1\n1\nresource_use\ntreatment_begins\n0.000000\n1.0\n1\n1.0\n10\nNaN\n\n\n6\n2\n1\n1\nresource_use\ntreatment_begins\n0.000000\n1.0\n1\n1.0\n12\nNaN\n\n\n7\n2\n1\n1\nresource_use\ntreatment_begins\n0.000000\n1.0\n1\n1.0\n14\nNaN\n\n\n8\n5\n2\n2\nresource_use\ntreatment_begins\n12.021043\n2.0\n1\n2.0\n14\nNaN\n\n\n9\n2\n1\n1\nresource_use\ntreatment_begins\n0.000000\n1.0\n1\n1.0\n16\nNaN\n\n\n10\n5\n2\n2\nresource_use\ntreatment_begins\n12.021043\n2.0\n1\n2.0\n16\nNaN\n\n\n11\n2\n1\n1\nresource_use\ntreatment_begins\n0.000000\n1.0\n1\n1.0\n18\nNaN\n\n\n12\n5\n2\n2\nresource_use\ntreatment_begins\n12.021043\n2.0\n1\n2.0\n18\nNaN\n\n\n13\n2\n1\n1\nresource_use\ntreatment_begins\n0.000000\n1.0\n1\n1.0\n20\nNaN\n\n\n14\n5\n2\n2\nresource_use\ntreatment_begins\n12.021043\n2.0\n1\n2.0\n20\nNaN\n\n\n\n\n\n\n\n\nevent_position_df = pd.DataFrame([\n                    {'event': 'arrival',\n                     'x':  50, 'y': 300,\n                     'label': \"Arrival\" },\n\n                    # Triage - minor and trauma\n                    {'event': 'treatment_wait_begins',\n                     'x':  205, 'y': 275,\n                     'label': \"Waiting for Treatment\"},\n\n                    {'event': 'treatment_begins',\n                     'x':  205, 'y': 175,\n                     'resource':'n_cubicles',\n                     'label': \"Being Treated\"},\n\n                    {'event': 'depart',\n                     'x':  270, 'y': 70,\n                     'label': \"Exit\"}\n\n                ])\n\n\nGenerate animation using the step-by-step functions\nUsing the three step-by-step functions allows us to intervene in the produced dataframe and manually take control of the icons in use.\nThis will allow us to show the high-priority patients with a unique icon so we can see their frequency and how they are handled in the final model.\n\nfull_patient_df_plus_pos = generate_animation_df(\n    full_entity_df=full_patient_df,\n    event_position_df=event_position_df,\n    entity_col_name=\"patient\",\n    wrap_queues_at=WRAP_QUEUES_AT,\n    step_snapshot_max=STEP_SNAPSHOT_MAX,\n    gap_between_entities=10,\n    gap_between_resources=10,\n    gap_between_resource_rows=30,\n    gap_between_queue_rows=30,\n    debug_mode=True\n    )\n\nfull_patient_df_plus_pos.sort_values(['patient', 'snapshot_time']).head(15)\n\nPlacement dataframe finished construction at 12:00:08\n\n\n\n\n\n\n\n\n\nindex\npatient\npathway\nevent_type\nevent\ntime\nresource_id\nrun\nrank\nsnapshot_time\nadditional\nx\ny_final\nlabel\nresource\nx_final\nrow\ny\nicon\n\n\n\n\n10186\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n0\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n10187\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n2\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n10188\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n4\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n10189\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n6\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n10190\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n8\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n10191\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n10\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n10192\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n12\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n10193\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n14\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n10194\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n16\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n10195\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n18\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n10196\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n20\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n10197\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n22\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n10198\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n24\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n10199\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n26\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n10200\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n28\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n\n\n\n\n\n\ndef show_priority_icon(row):\n            if \"more\" not in row[\"icon\"]:\n                if row[\"pathway\"] == 1:\n                        return \"🚨\"\n                else:\n                    return row[\"icon\"]\n            else:\n                return row[\"icon\"]\n\n\nfull_patient_df_plus_pos = full_patient_df_plus_pos.assign(\n            icon=full_patient_df_plus_pos.apply(show_priority_icon, axis=1)\n            )\n\n\nfull_patient_df_plus_pos.head(15)\n\n\n\n\n\n\n\n\nindex\npatient\npathway\nevent_type\nevent\ntime\nresource_id\nrun\nrank\nsnapshot_time\nadditional\nx\ny_final\nlabel\nresource\nx_final\nrow\ny\nicon\n\n\n\n\n0\n13\n5\n2\nqueue\ntreatment_wait_begins\n37.024768\nNaN\n1\n1.0\n38\nNaN\n205\n275.0\nWaiting for Treatment\nNaN\n205.0\n0.0\nNaN\n👩🏿‍🦱\n\n\n1\n13\n5\n2\nqueue\ntreatment_wait_begins\n37.024768\nNaN\n1\n1.0\n40\nNaN\n205\n275.0\nWaiting for Treatment\nNaN\n205.0\n0.0\nNaN\n👩🏿‍🦱\n\n\n2\n18\n5\n2\nresource_use\ndepart\n41.226014\n1.0\n1\n1.0\n74\nNaN\n270\n70.0\nExit\nNaN\n270.0\n0.0\nNaN\n👩🏿‍🦱\n\n\n3\n18\n5\n2\nresource_use\ntreatment_begins\n41.226014\n1.0\n1\n4.0\n42\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n👩🏿‍🦱\n\n\n4\n18\n5\n2\nresource_use\ntreatment_begins\n41.226014\n1.0\n1\n4.0\n44\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n👩🏿‍🦱\n\n\n5\n18\n5\n2\nresource_use\ntreatment_begins\n41.226014\n1.0\n1\n4.0\n46\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n👩🏿‍🦱\n\n\n6\n18\n5\n2\nresource_use\ntreatment_begins\n41.226014\n1.0\n1\n3.0\n48\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n👩🏿‍🦱\n\n\n7\n18\n5\n2\nresource_use\ntreatment_begins\n41.226014\n1.0\n1\n3.0\n50\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n👩🏿‍🦱\n\n\n8\n18\n5\n2\nresource_use\ntreatment_begins\n41.226014\n1.0\n1\n3.0\n52\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n👩🏿‍🦱\n\n\n9\n18\n5\n2\nresource_use\ntreatment_begins\n41.226014\n1.0\n1\n3.0\n54\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n👩🏿‍🦱\n\n\n10\n18\n5\n2\nresource_use\ntreatment_begins\n41.226014\n1.0\n1\n3.0\n56\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n👩🏿‍🦱\n\n\n11\n18\n5\n2\nresource_use\ntreatment_begins\n41.226014\n1.0\n1\n3.0\n58\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n👩🏿‍🦱\n\n\n12\n18\n5\n2\nresource_use\ntreatment_begins\n41.226014\n1.0\n1\n3.0\n60\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n👩🏿‍🦱\n\n\n13\n18\n5\n2\nresource_use\ntreatment_begins\n41.226014\n1.0\n1\n3.0\n62\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n👩🏿‍🦱\n\n\n14\n18\n5\n2\nresource_use\ntreatment_begins\n41.226014\n1.0\n1\n3.0\n64\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n👩🏿‍🦱\n\n\n\n\n\n\n\n\ngenerate_animation(\n        full_entity_df_plus_pos=full_patient_df_plus_pos.sort_values(['patient', 'snapshot_time']),\n        event_position_df= event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        debug_mode=True,\n        setup_mode=False,\n        include_play_button=True,\n        entity_icon_size=16,\n        resource_icon_size=20,\n        gap_between_resource_rows=30,\n        plotly_height=600,\n        frame_duration=800,\n        frame_transition_duration=200,\n        plotly_width=1000,\n        override_x_max=300,\n        override_y_max=500,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nOutput animation generation complete at 12:00:10\n\n\n        \n        \n        \n\n\n                                                    \n\n\n\n\nRerun, but using the all-in-one animation function (which will not show different priority icons)\n\nanimate_activity_log(\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        debug_mode=True,\n        setup_mode=False,\n        every_x_time_units=1,\n        include_play_button=True,\n        entity_icon_size=16,\n        resource_icon_size=20,\n        gap_between_entities=6,\n        gap_between_queue_rows=25,\n        gap_between_resource_rows=25,\n        plotly_height=600,\n        frame_duration=200,\n        plotly_width=1000,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=g.sim_duration,\n        wrap_queues_at=25,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nAnimation function called at 12:00:11\nIteration through time-unit-by-time-unit logs complete 12:00:15\nSnapshot df concatenation complete at 12:00:15\nReshaped animation dataframe finished construction at 12:00:15\nPlacement dataframe finished construction at 12:00:15\nOutput animation generation complete at 12:00:19\nTotal Time Elapsed: 7.77 seconds",
    "crumbs": [
      "SimPy Examples",
      "Using the VidigiPriorityStore to Simplify Model Code Changes with Priority Resources"
    ]
  },
  {
    "objectID": "examples/example_5_simplest_case_wrapped_resources/ex_5_simplest_case_wrapped_resource.html",
    "href": "examples/example_5_simplest_case_wrapped_resources/ex_5_simplest_case_wrapped_resource.html",
    "title": "Managing Higher Numbers of Resources with Resource Wrapping",
    "section": "",
    "text": "from examples.example_1_simplest_case.ex_1_model_classes_with_vidigi_logging import Trial, g\nfrom vidigi.animation import animate_activity_log\nimport pandas as pd\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\nimport os",
    "crumbs": [
      "SimPy Examples",
      "Managing Higher Numbers of Resources with Resource Wrapping"
    ]
  },
  {
    "objectID": "examples/example_5_simplest_case_wrapped_resources/ex_5_simplest_case_wrapped_resource.html#demonstrate-issues-with-wrapping-not-implemented",
    "href": "examples/example_5_simplest_case_wrapped_resources/ex_5_simplest_case_wrapped_resource.html#demonstrate-issues-with-wrapping-not-implemented",
    "title": "Managing Higher Numbers of Resources with Resource Wrapping",
    "section": "Demonstrate issues with wrapping not implemented",
    "text": "Demonstrate issues with wrapping not implemented\n\ng.sim_duration = 360\ng.n_cubicles = 30\ng.trauma_treat_mean = 120\ng.trauma_treat_var = 20\ng.arrival_rate = 3\n\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\n30 nurses\n\n\n\n\nmy_trial.all_event_logs.head(20)\n\n\n\n\n\n\n\n\npatient\npathway\nevent_type\nevent\ntime\nresource_id\nrun\n\n\n\n\n0\n1\nSimplest\narrival_departure\narrival\n0.000000\nNaN\n0\n\n\n1\n1\nSimplest\nqueue\ntreatment_wait_begins\n0.000000\nNaN\n0\n\n\n2\n1\nSimplest\nresource_use\ntreatment_begins\n0.000000\n1.0\n0\n\n\n3\n2\nSimplest\narrival_departure\narrival\n2.039796\nNaN\n0\n\n\n4\n2\nSimplest\nqueue\ntreatment_wait_begins\n2.039796\nNaN\n0\n\n\n5\n2\nSimplest\nresource_use\ntreatment_begins\n2.039796\n2.0\n0\n\n\n6\n3\nSimplest\narrival_departure\narrival\n5.098587\nNaN\n0\n\n\n7\n3\nSimplest\nqueue\ntreatment_wait_begins\n5.098587\nNaN\n0\n\n\n8\n3\nSimplest\nresource_use\ntreatment_begins\n5.098587\n3.0\n0\n\n\n9\n4\nSimplest\narrival_departure\narrival\n5.158007\nNaN\n0\n\n\n10\n4\nSimplest\nqueue\ntreatment_wait_begins\n5.158007\nNaN\n0\n\n\n11\n4\nSimplest\nresource_use\ntreatment_begins\n5.158007\n4.0\n0\n\n\n12\n5\nSimplest\narrival_departure\narrival\n5.164815\nNaN\n0\n\n\n13\n5\nSimplest\nqueue\ntreatment_wait_begins\n5.164815\nNaN\n0\n\n\n14\n5\nSimplest\nresource_use\ntreatment_begins\n5.164815\n5.0\n0\n\n\n15\n6\nSimplest\narrival_departure\narrival\n6.815844\nNaN\n0\n\n\n16\n6\nSimplest\nqueue\ntreatment_wait_begins\n6.815844\nNaN\n0\n\n\n17\n6\nSimplest\nresource_use\ntreatment_begins\n6.815844\n6.0\n0\n\n\n18\n7\nSimplest\narrival_departure\narrival\n11.705665\nNaN\n0\n\n\n19\n7\nSimplest\nqueue\ntreatment_wait_begins\n11.705665\nNaN\n0\n\n\n\n\n\n\n\n\nevent_position_df = pd.DataFrame([\n                    {'event': 'arrival',\n                     'x':  50, 'y': 300,\n                     'label': \"Arrival\" },\n\n                    # Triage - minor and trauma\n                    {'event': 'treatment_wait_begins',\n                     'x':  205, 'y': 275,\n                     'label': \"Waiting for Treatment\"},\n\n                    {'event': 'treatment_begins',\n                     'x':  205, 'y': 175,\n                     'resource':'n_cubicles',\n                     'label': \"Being Treated\"},\n\n                    {'event': 'depart',\n                     'x':  270, 'y': 70,\n                     'label': \"Exit\"}\n\n                ])\n\n\nanimate_activity_log(\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        debug_mode=True,\n        setup_mode=False,\n        every_x_time_units=1,\n        include_play_button=True,\n        entity_icon_size=20,\n        gap_between_entities=6,\n        gap_between_queue_rows=25,\n        gap_between_resource_rows=25,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=180,\n        wrap_queues_at=25,\n        wrap_resources_at=None,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nAnimation function called at 11:53:54\nIteration through time-unit-by-time-unit logs complete 11:53:54\nSnapshot df concatenation complete at 11:53:54\nReshaped animation dataframe finished construction at 11:53:55\nPlacement dataframe finished construction at 11:53:55\nOutput animation generation complete at 11:53:55\nTotal Time Elapsed: 1.66 seconds",
    "crumbs": [
      "SimPy Examples",
      "Managing Higher Numbers of Resources with Resource Wrapping"
    ]
  },
  {
    "objectID": "examples/example_5_simplest_case_wrapped_resources/ex_5_simplest_case_wrapped_resource.html#rerun-with-wrapped-resources",
    "href": "examples/example_5_simplest_case_wrapped_resources/ex_5_simplest_case_wrapped_resource.html#rerun-with-wrapped-resources",
    "title": "Managing Higher Numbers of Resources with Resource Wrapping",
    "section": "Rerun with wrapped resources",
    "text": "Rerun with wrapped resources\n\nanimate_activity_log(\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        debug_mode=True,\n        setup_mode=False,\n        every_x_time_units=1,\n        include_play_button=True,\n        entity_icon_size=20,\n        resource_icon_size=20,\n        gap_between_entities=6,\n        gap_between_queue_rows=25,\n        gap_between_resource_rows=25,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=180,\n        wrap_queues_at=25,\n        wrap_resources_at=15,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nAnimation function called at 11:53:56\nIteration through time-unit-by-time-unit logs complete 11:53:56\nSnapshot df concatenation complete at 11:53:57\nReshaped animation dataframe finished construction at 11:53:57\nPlacement dataframe finished construction at 11:53:57\nOutput animation generation complete at 11:53:57\nTotal Time Elapsed: 1.71 seconds",
    "crumbs": [
      "SimPy Examples",
      "Managing Higher Numbers of Resources with Resource Wrapping"
    ]
  },
  {
    "objectID": "examples/example_5_simplest_case_wrapped_resources/ex_5_simplest_case_wrapped_resource.html#running-this-with-a-much-larger-number-of-resources",
    "href": "examples/example_5_simplest_case_wrapped_resources/ex_5_simplest_case_wrapped_resource.html#running-this-with-a-much-larger-number-of-resources",
    "title": "Managing Higher Numbers of Resources with Resource Wrapping",
    "section": "Running this with a much larger number of resources",
    "text": "Running this with a much larger number of resources\nThis demonstrates that vidigi can cope with relatively high numbers of resources being tracked.\nLet’s envisage the bays as beds instead, and do a bit of a rough tweak to our existing model parameters to pretend that this is playing out over a period of days instead of minutes.\n\ng.n_cubicles = 200\ng.trauma_treat_mean = 3*24\ng.trauma_treat_var = 10*24\ng.arrival_rate = 0.2\n\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\n200 nurses\n\n\n\n\nevent_position_df = pd.DataFrame([\n                    {'event': 'arrival',\n                     'x':  5, 'y': 1250,\n                     'label': \"Arrival\" },\n\n                    # Triage - minor and trauma\n                    {'event': 'treatment_wait_begins',\n                     'x':  285, 'y': 790,\n                     'label': \"Waiting for&lt;br&gt;Bed\"}, # Note use of line break character must be &lt;br&gt; not \\n\n\n                    {'event': 'treatment_begins',\n                     'x':  285, 'y': 130,\n                     'resource':'n_cubicles',\n                     'label': \"In a Bed\"},\n\n                    {'event': 'depart',\n                     'x':  320, 'y': 30,\n                     'label': \"Exit\"}\n\n                ])\n\n\nanimate_activity_log(\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        debug_mode=True,\n        setup_mode=True,\n        every_x_time_units=1,\n        include_play_button=True,\n        entity_icon_size=12,\n        resource_icon_size=16,\n        gap_between_entities=10,\n        gap_between_resources=12,\n        gap_between_queue_rows=50,\n        gap_between_resource_rows=50,\n        plotly_height=700,\n        frame_duration=500,\n        plotly_width=1200,\n        override_x_max=350,\n        override_y_max=1350,\n        limit_duration=180,\n        wrap_queues_at=25,\n        wrap_resources_at=20,\n        step_snapshot_max=250,\n        time_display_units=\"d\",\n        simulation_time_unit=\"day\",\n        display_stage_labels=True,\n        custom_resource_icon=\"🛏️\"\n    )\n\nAnimation function called at 11:54:02\nIteration through time-unit-by-time-unit logs complete 11:54:03\nSnapshot df concatenation complete at 11:54:03\nReshaped animation dataframe finished construction at 11:54:04\nPlacement dataframe finished construction at 11:54:04\nOutput animation generation complete at 11:54:05\nTotal Time Elapsed: 2.32 seconds\n\n\n                                                    \n\n\n\nIncrease the number of beds and rerun\n\ng.n_cubicles = 300\ng.trauma_treat_mean = 5*24\ng.trauma_treat_var = 10*24\ng.arrival_rate = 0.2\n\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\n300 nurses\n\n\n\n\nevent_position_df = pd.DataFrame([\n                    {'event': 'arrival',\n                     'x':  5, 'y': 1900,\n                     'label': \"Arrival\" },\n\n                    # Triage - minor and trauma\n                    {'event': 'treatment_wait_begins',\n                     'x':  285, 'y': 1300,\n                     'label': \"Waiting for&lt;br&gt;Bed\"},\n\n                    {'event': 'treatment_begins',\n                     'x':  285, 'y': 130,\n                     'resource':'n_cubicles',\n                     'label': \"In a Bed\"},\n\n                    {'event': 'depart',\n                     'x':  320, 'y': 30,\n                     'label': \"Exit\"}\n\n                ])\n\n\nanimate_activity_log(\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        debug_mode=True,\n        setup_mode=False,\n        every_x_time_units=1,\n        include_play_button=True,\n        entity_icon_size=14,\n        resource_icon_size=14,\n        gap_between_entities=10,\n        gap_between_resources=13,\n        gap_between_resource_rows=70,\n        gap_between_queue_rows=70,\n        plotly_height=850,\n        frame_duration=500,\n        plotly_width=1200,\n        override_x_max=350,\n        override_y_max=2650,\n        limit_duration=180,\n        wrap_queues_at=25,\n        wrap_resources_at=20,\n        step_snapshot_max=425, # Make sure this is larger than the number of resources you have!\n        time_display_units=\"d\",\n        simulation_time_unit=\"day\",\n        display_stage_labels=True,\n        custom_resource_icon=\"🛏️\"\n    )\n\nAnimation function called at 11:54:10\nIteration through time-unit-by-time-unit logs complete 11:54:11\nSnapshot df concatenation complete at 11:54:11\nReshaped animation dataframe finished construction at 11:54:11\nPlacement dataframe finished construction at 11:54:11\nOutput animation generation complete at 11:54:12\nTotal Time Elapsed: 2.16 seconds\n\n\n                                                    \n\n\nWe can see that even with this many resources displayed at once, performance in this simple model is acceptable.",
    "crumbs": [
      "SimPy Examples",
      "Managing Higher Numbers of Resources with Resource Wrapping"
    ]
  },
  {
    "objectID": "examples/example_4_ciw/ex_4_ciw.html",
    "href": "examples/example_4_ciw/ex_4_ciw.html",
    "title": "A Simple Ciw Model",
    "section": "",
    "text": "Note that this example is written using ciw 2.x\nIt will not run with 3.x - but could theoretically be adapted to do so\nThe ‘logs’ object is the result of running\nsim_engine.get_all_records()\nHowever, note that while we run multiple replications, we only pass the records for a single replication to the event_log_from_ciw_recs function.\n\nThe underlying model code is from Monks, T., Harper, A., & Heather, A. (2023). Towards Sharing Tools, Artefacts, and Reproducible Simulation: a ciw model example (v1.0.1). Zenodo. https://doi.org/10.5281/zenodo.10051494\nSee here for the adaptation embedded within that repo: https://github.com/Bergam0t/ciw-example-animation/tree/main\n\n\nimport pandas as pd\n# Import the wrapper objects for model interaction.\nfrom examples.example_4_ciw.ex_4_ciw_model import Experiment, multiple_replications\nfrom vidigi.ciw import event_log_from_ciw_recs\nfrom vidigi.animation import animate_activity_log\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\nimport os\n\n\n\n\n\n\n\nView Imported Code for the ciw model\n\n\n\n\n\n'''\nCiW Implementation of the 111 call centre\nTime units of the simulation model are in minutes.\n'''\n# Imports\n\nimport numpy as np\nimport pandas as pd\nimport ciw\n\n# Module level variables, constants, and default values\n\nN_OPERATORS = 13\nN_NURSES = 9\nMEAN_IAT = 100.0 / 60.0\n\nCALL_LOW = 5.0\nCALL_MODE = 7.0\nCALL_HIGH = 10.0\n\nNURSE_CALL_LOW = 10.0\nNURSE_CALL_HIGH = 20.0\n\nCHANCE_CALLBACK = 0.4\nRESULTS_COLLECTION_PERIOD = 1000\n\n\n# Experiment class\nclass Experiment:\n    def __init__(self, n_operators=N_OPERATORS, n_nurses=N_NURSES,\n                 mean_iat=MEAN_IAT, call_low=CALL_LOW,\n                 call_mode=CALL_MODE, call_high=CALL_HIGH,\n                 chance_callback=CHANCE_CALLBACK,\n                 nurse_call_low=NURSE_CALL_LOW,\n                 nurse_call_high=NURSE_CALL_HIGH,\n                 random_seed=None):\n        self.n_operators = n_operators\n        self.n_nurses = n_nurses\n\n        self.arrival_dist = ciw.dists.Exponential(mean_iat)\n        self.call_dist = ciw.dists.Triangular(call_low, call_mode, call_high)\n        self.nurse_dist = ciw.dists.Uniform(nurse_call_low, nurse_call_high)\n\n        self.chance_callback = chance_callback\n\n        self.init_results_variables()\n\n    def init_results_variables(self):\n        self.results = {\n            'waiting_times': [],\n            'total_call_duration': 0.0,\n            'nurse_waiting_times': [],\n            'total_nurse_call_duration': 0.0,\n        }\n\n\n# Model code\n\ndef get_model(args):\n    '''\n    Build a CiW model using the arguments provided.\n    '''\n    network = ciw.create_network(\n        arrival_distributions=[args.arrival_dist, None],\n        service_distributions=[args.call_dist, args.nurse_dist],\n        routing=[[0.0, args.chance_callback], [0.0, 0.0]],\n        number_of_servers=[args.n_operators, args.n_nurses]\n    )\n    return network\n\n\n# Model wrapper functions\n\ndef single_run(experiment, rc_period=RESULTS_COLLECTION_PERIOD, random_seed=None):\n    run_results = {}\n\n    ciw.seed(random_seed)\n\n    model = get_model(experiment)\n\n    sim_engine = ciw.Simulation(model)\n\n    sim_engine.simulate_until_max_time(rc_period)\n\n    recs = sim_engine.get_all_records()\n\n    op_servicetimes = [r.service_time for r in recs if r.node == 1]\n    nurse_servicetimes = [r.service_time for r in recs if r.node == 2]\n\n    op_waits = [r.waiting_time for r in recs if r.node == 1]\n    nurse_waits = [r.waiting_time for r in recs if r.node == 2]\n\n    run_results['01_mean_waiting_time'] = np.mean(op_waits)\n    run_results['02_operator_util'] = (\n        sum(op_servicetimes) / (rc_period * experiment.n_operators)\n    ) * 100.0\n    run_results['03_mean_nurse_waiting_time'] = np.mean(nurse_waits)\n    run_results['04_nurse_util'] = (\n        sum(nurse_servicetimes) / (rc_period * experiment.n_nurses)\n    ) * 100.0\n\n    return run_results, recs\n\n\ndef multiple_replications(experiment, rc_period=RESULTS_COLLECTION_PERIOD, n_reps=5):\n    results = []\n    logs = []\n\n    for rep in range(n_reps):\n        run_result, log = single_run(experiment, rc_period)\n        results.append(run_result)\n        logs.append(log)\n\n    df_results = pd.DataFrame(results)\n    df_results.index = np.arange(1, len(df_results) + 1)\n    df_results.index.name = 'rep'\n\n    return df_results, logs\n\n\n\n\nN_OPERATORS = 18\nN_NURSES = 9\nRESULTS_COLLECTION_PERIOD = 1000\n\nuser_experiment = Experiment(n_operators=N_OPERATORS,\n                             n_nurses=N_NURSES,\n                             chance_callback=0.4)\n\n# run multiple replications\nresults, logs = multiple_replications(user_experiment, n_reps=10)\n\nWhile we’ve done multiple replications, for the purpose of the animation we want only a single set of logs, so we will extract those from the logs variable we created.\n\n# the 'logs' object contains a list, where each entry is the recs object for that run\nlogs_run_1 = logs[0]\n\nprint(len(logs_run_1))\n\n2277\n\n\n\n# let's print all of the outputs for a single individual\n[print(log) for log in logs_run_1 if log.id_number==500]\n\nRecord(id_number=500, customer_class='Customer', original_customer_class='Customer', node=1, arrival_date=285.15199278675664, waiting_time=0.0, service_start_date=285.15199278675664, service_time=8.53886189681026, service_end_date=293.6908546835669, time_blocked=0.0, exit_date=293.6908546835669, destination=2, queue_size_at_arrival=14, queue_size_at_departure=9, server_id=2, record_type='service')\nRecord(id_number=500, customer_class='Customer', original_customer_class='Customer', node=2, arrival_date=293.6908546835669, waiting_time=49.99518525413794, service_start_date=343.68603993770483, service_time=15.877553023839369, service_end_date=359.5635929615442, time_blocked=0.0, exit_date=359.5635929615442, destination=-1, queue_size_at_arrival=40, queue_size_at_departure=45, server_id=4, record_type='service')\n\n\n[None, None]\n\n\nUnlike SimPy, where we have to manually add our event logs at various points, we instead can make use of the event_log_from_ciw_recs helper function from vidigi.utils to automatically reshape ciw logs into the correct format for vidigi to work with.\nFor each node, we pass in an appropriate name. Vidigi will use these and append ’_begins’ and ’_ends’, as well as calculating arrivals and departures from the model and creating resource IDs to allow it to correctly show the utilisation of a resource at each step.\n\n# let's now try turning this into an event log\nevent_log_test = event_log_from_ciw_recs(logs_run_1, node_name_list=[\"operator\", \"nurse\"])\n\nevent_log_test.head(25)\n\n\n\n\n\n\n\n\nentity_id\npathway\nevent_type\nevent\ntime\nresource_id\n\n\n\n\n0\n1\nModel\narrival_departure\narrival\n0.217233\nNaN\n\n\n1\n1\nModel\nqueue\noperator_wait_begins\n0.217233\nNaN\n\n\n2\n1\nModel\nresource_use\noperator_begins\n0.217233\n1.0\n\n\n3\n1\nModel\nresource_use\noperator_ends\n9.223846\n1.0\n\n\n4\n1\nModel\nqueue\nnurse_wait_begins\n9.223846\nNaN\n\n\n5\n1\nModel\nresource_use\nnurse_begins\n9.223846\n2.0\n\n\n6\n1\nModel\nresource_use\nnurse_ends\n20.429835\n2.0\n\n\n7\n1\nModel\narrival_departure\ndepart\n20.429835\nNaN\n\n\n8\n2\nModel\narrival_departure\narrival\n0.876985\nNaN\n\n\n9\n2\nModel\nqueue\noperator_wait_begins\n0.876985\nNaN\n\n\n10\n2\nModel\nresource_use\noperator_begins\n0.876985\n2.0\n\n\n11\n2\nModel\nresource_use\noperator_ends\n7.146672\n2.0\n\n\n12\n2\nModel\nqueue\nnurse_wait_begins\n7.146672\nNaN\n\n\n13\n2\nModel\nresource_use\nnurse_begins\n7.146672\n1.0\n\n\n14\n2\nModel\nresource_use\nnurse_ends\n18.146884\n1.0\n\n\n15\n2\nModel\narrival_departure\ndepart\n18.146884\nNaN\n\n\n16\n3\nModel\narrival_departure\narrival\n2.301595\nNaN\n\n\n17\n3\nModel\nqueue\noperator_wait_begins\n2.301595\nNaN\n\n\n18\n3\nModel\nresource_use\noperator_begins\n2.301595\n3.0\n\n\n19\n3\nModel\nresource_use\noperator_ends\n10.313719\n3.0\n\n\n20\n3\nModel\narrival_departure\ndepart\n10.313719\nNaN\n\n\n21\n4\nModel\narrival_departure\narrival\n2.806043\nNaN\n\n\n22\n4\nModel\nqueue\noperator_wait_begins\n2.806043\nNaN\n\n\n23\n4\nModel\nresource_use\noperator_begins\n2.806043\n4.0\n\n\n24\n4\nModel\nresource_use\noperator_ends\n10.160622\n4.0\n\n\n\n\n\n\n\nNow we need to create a suitable class to pass in the resource numbers to the animation function.\n\n# Create a suitable class to pass in the resource numbers to the animation function\nclass model_params():\n    def __init__(self):\n        self.n_operators = N_OPERATORS\n        self.n_nurses = N_NURSES\n\nparams = model_params()\n\nprint(f\"Number of operators: {params.n_operators}\")\nprint(f\"Number of nurses: {params.n_nurses}\")\n\nNumber of operators: 18\nNumber of nurses: 9\n\n\nLike with SimPy, we need to tell vidigi where to put each step on our plot. We will refer to the names we used - so as we named our nodes ‘operator’ and ‘nurse’, we will want\n\narrival\noperator_wait_begins (to show queueing for the operator)\noperator_begins (to show resource use of the operator)\nnurse_wait_begins (to show queuing for the nurse after finishing being seen by the operator)\nnurse_begins (to show resource use of the nurse)\n\nFor the _begins steps, which relat to resource use, we will also pass in a name that relates to the number of resources we need, which we defined in our model_params class above.\nSo, for the operator_begins step, for example, we tell t to look for n_operators, whch is one of the parameters in our model_params class. We pass the params class into the animation function.\n\n# Create required event_position_df for vidigi animation\nevent_position_df = pd.DataFrame([\n                    {'event': 'arrival',\n                     'x':  30, 'y': 350,\n                     'label': \"Arrival\"},\n\n                    {'event': 'operator_wait_begins',\n                     'x':  205, 'y': 270,\n                     'label': \"Waiting for Operator\"},\n\n                    {'event': 'operator_begins',\n                     'x':  210, 'y': 210,\n                     'resource':'n_operators',\n                     'label': \"Speaking to operator\"},\n\n                    {'event': 'nurse_wait_begins',\n                     'x':  205, 'y': 110,\n                     'label': \"Waiting for Nurse\"},\n\n                    {'event': 'nurse_begins',\n                     'x':  210, 'y': 50,\n                     'resource':'n_nurses',\n                     'label': \"Speaking to Nurse\"},\n\n                    {'event': 'depart',\n                     'x':  270, 'y': 10,\n                     'label': \"Exit\"}\n\n                ])\n\nevent_position_df\n\n\n\n\n\n\n\n\nevent\nx\ny\nlabel\nresource\n\n\n\n\n0\narrival\n30\n350\nArrival\nNaN\n\n\n1\noperator_wait_begins\n205\n270\nWaiting for Operator\nNaN\n\n\n2\noperator_begins\n210\n210\nSpeaking to operator\nn_operators\n\n\n3\nnurse_wait_begins\n205\n110\nWaiting for Nurse\nNaN\n\n\n4\nnurse_begins\n210\n50\nSpeaking to Nurse\nn_nurses\n\n\n5\nexit\n270\n10\nExit\nNaN\n\n\n\n\n\n\n\nFinally, we can create the animation.\n\n# Create animation\nparams = model_params()\n\nanimate_activity_log(\n        event_log=event_log_test,\n        event_position_df=event_position_df,\n        scenario=model_params(),\n        debug_mode=True,\n        setup_mode=False,\n        every_x_time_units=1,\n        include_play_button=True,\n        entity_icon_size=20,\n        gap_between_entities=8,\n        gap_between_queue_rows=25,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=300,\n        limit_duration=RESULTS_COLLECTION_PERIOD,\n        wrap_queues_at=25,\n        wrap_resources_at=50,\n        step_snapshot_max=75,\n        time_display_units=\"dhm\",\n        display_stage_labels=True,\n    )\n\nAnimation function called at 15:52:26\nIteration through time-unit-by-time-unit logs complete 15:52:31\nSnapshot df concatenation complete at 15:52:31\nReshaped animation dataframe finished construction at 15:52:31\nPlacement dataframe finished construction at 15:52:31\nOutput animation generation complete at 15:52:35\nTotal Time Elapsed: 9.56 seconds",
    "crumbs": [
      "Ciw Examples",
      "A Simple Ciw Model"
    ]
  },
  {
    "objectID": "examples/example_2_branching_multistep/ex_2_branching_multistep_case.html",
    "href": "examples/example_2_branching_multistep/ex_2_branching_multistep_case.html",
    "title": "Animation of a SimPy Model with Branching and Multiple Steps",
    "section": "",
    "text": "from examples.example_2_branching_multistep.ex_2_model_classes import Trial, g\nfrom vidigi.animation import animate_activity_log\nfrom vidigi.utils import create_event_position_df, EventPosition\nimport pandas as pd\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\nimport os\nmy_trial = Trial()\n\nmy_trial.run_trial()\nmy_trial.all_event_logs.head(50)\n\n\n\n\n\n\n\n\npatient\npathway\nevent\nevent_type\ntime\nresource_id\nrun\n\n\n\n\n0\n1\nShared\narrival\narrival_departure\n3.285355\nNaN\n0\n\n\n1\n1\nNon-Trauma\ntriage_wait_begins\nqueue\n3.285355\nNaN\n0\n\n\n2\n1\nNon-Trauma\ntriage_begins\nresource_use\n3.285355\n1.0\n0\n\n\n3\n2\nShared\narrival\narrival_departure\n3.289691\nNaN\n0\n\n\n4\n2\nNon-Trauma\ntriage_wait_begins\nqueue\n3.289691\nNaN\n0\n\n\n5\n2\nNon-Trauma\ntriage_begins\nresource_use\n3.289691\n2.0\n0\n\n\n6\n1\nNon-Trauma\ntriage_complete\nresource_use_end\n7.364946\n1.0\n0\n\n\n7\n1\nNon-Trauma\nMINORS_registration_wait_begins\nqueue\n7.364946\nNaN\n0\n\n\n8\n1\nNon-Trauma\nMINORS_registration_begins\nresource_use\n7.364946\n1.0\n0\n\n\n9\n2\nNon-Trauma\ntriage_complete\nresource_use_end\n9.407274\n2.0\n0\n\n\n10\n2\nNon-Trauma\nMINORS_registration_wait_begins\nqueue\n9.407274\nNaN\n0\n\n\n11\n2\nNon-Trauma\nMINORS_registration_begins\nresource_use\n9.407274\n2.0\n0\n\n\n12\n1\nNon-Trauma\nMINORS_registration_complete\nresource_use_end\n15.418481\n1.0\n0\n\n\n13\n1\nNon-Trauma\nMINORS_examination_wait_begins\nqueue\n15.418481\nNaN\n0\n\n\n14\n1\nNon-Trauma\nMINORS_examination_begins\nresource_use\n15.418481\n1.0\n0\n\n\n15\n2\nNon-Trauma\nMINORS_registration_complete\nresource_use_end\n17.104670\n2.0\n0\n\n\n16\n2\nNon-Trauma\nMINORS_examination_wait_begins\nqueue\n17.104670\nNaN\n0\n\n\n17\n2\nNon-Trauma\nMINORS_examination_begins\nresource_use\n17.104670\n2.0\n0\n\n\n18\n1\nNon-Trauma\nMINORS_examination_complete\nresource_use_end\n31.636252\n1.0\n0\n\n\n19\n1\nShared\ndepart\narrival_departure\n31.636252\nNaN\n0\n\n\n20\n2\nNon-Trauma\nMINORS_examination_complete\nresource_use_end\n32.875857\n2.0\n0\n\n\n21\n2\nNon-Trauma\nrequires_treatment\nattribute_assigned\n32.875857\nNaN\n0\n\n\n22\n2\nNon-Trauma\nMINORS_treatment_wait_begins\nqueue\n32.875857\nNaN\n0\n\n\n23\n2\nNon-Trauma\nMINORS_treatment_begins\nresource_use\n32.875857\n1.0\n0\n\n\n24\n3\nShared\narrival\narrival_departure\n33.426168\nNaN\n0\n\n\n25\n3\nNon-Trauma\ntriage_wait_begins\nqueue\n33.426168\nNaN\n0\n\n\n26\n3\nNon-Trauma\ntriage_begins\nresource_use\n33.426168\n1.0\n0\n\n\n27\n3\nNon-Trauma\ntriage_complete\nresource_use_end\n33.545008\n1.0\n0\n\n\n28\n3\nNon-Trauma\nMINORS_registration_wait_begins\nqueue\n33.545008\nNaN\n0\n\n\n29\n3\nNon-Trauma\nMINORS_registration_begins\nresource_use\n33.545008\n1.0\n0\n\n\n30\n4\nShared\narrival\narrival_departure\n37.900548\nNaN\n0\n\n\n31\n4\nNon-Trauma\ntriage_wait_begins\nqueue\n37.900548\nNaN\n0\n\n\n32\n4\nNon-Trauma\ntriage_begins\nresource_use\n37.900548\n2.0\n0\n\n\n33\n4\nNon-Trauma\ntriage_complete\nresource_use_end\n37.914164\n2.0\n0\n\n\n34\n4\nNon-Trauma\nMINORS_registration_wait_begins\nqueue\n37.914164\nNaN\n0\n\n\n35\n4\nNon-Trauma\nMINORS_registration_begins\nresource_use\n37.914164\n2.0\n0\n\n\n36\n3\nNon-Trauma\nMINORS_registration_complete\nresource_use_end\n42.359504\n1.0\n0\n\n\n37\n3\nNon-Trauma\nMINORS_examination_wait_begins\nqueue\n42.359504\nNaN\n0\n\n\n38\n3\nNon-Trauma\nMINORS_examination_begins\nresource_use\n42.359504\n3.0\n0\n\n\n39\n4\nNon-Trauma\nMINORS_registration_complete\nresource_use_end\n45.938325\n2.0\n0\n\n\n40\n4\nNon-Trauma\nMINORS_examination_wait_begins\nqueue\n45.938325\nNaN\n0\n\n\n41\n4\nNon-Trauma\nMINORS_examination_begins\nresource_use\n45.938325\n1.0\n0\n\n\n42\n2\nNon-Trauma\nMINORS_treatment_complete\nresource_use_end\n46.278797\n1.0\n0\n\n\n43\n2\nShared\ndepart\narrival_departure\n46.278797\nNaN\n0\n\n\n44\n5\nShared\narrival\narrival_departure\n51.770459\nNaN\n0\n\n\n45\n5\nNon-Trauma\ntriage_wait_begins\nqueue\n51.770459\nNaN\n0\n\n\n46\n5\nNon-Trauma\ntriage_begins\nresource_use\n51.770459\n1.0\n0\n\n\n47\n5\nNon-Trauma\ntriage_complete\nresource_use_end\n55.072516\n1.0\n0\n\n\n48\n5\nNon-Trauma\nMINORS_registration_wait_begins\nqueue\n55.072516\nNaN\n0\n\n\n49\n5\nNon-Trauma\nMINORS_registration_begins\nresource_use\n55.072516\n1.0\n0\nevent_position_df = create_event_position_df([\n    EventPosition(event='arrival', x=10, y=250, label=\"Arrival\"),\n\n    # Triage - minor and trauma\n    EventPosition(event='triage_wait_begins', x=160, y=375, label=\"Waiting for&lt;br&gt;Triage\"),\n    EventPosition(event='triage_begins', x=160, y=315, resource='n_triage', label=\"Being Triaged\"),\n\n    # Minors (non-trauma) pathway\n    EventPosition(event='MINORS_registration_wait_begins', x=300, y=145, label=\"Waiting for&lt;br&gt;Registration\"),\n    EventPosition(event='MINORS_registration_begins', x=300, y=85, resource='n_reg', label='Being&lt;br&gt;Registered'),\n\n    EventPosition(event='MINORS_examination_wait_begins', x=465, y=145, label=\"Waiting for&lt;br&gt;Examination\"),\n    EventPosition(event='MINORS_examination_begins', x=465, y=85, resource='n_exam', label=\"Being&lt;br&gt;Examined\"),\n\n    EventPosition(event='MINORS_treatment_wait_begins', x=630, y=145, label=\"Waiting for&lt;br&gt;Treatment\"),\n    EventPosition(event='MINORS_treatment_begins', x=630, y=85, resource='n_cubicles_non_trauma_treat', label=\"Being&lt;br&gt;Treated\"),\n\n    # Trauma pathway\n    EventPosition(event='TRAUMA_stabilisation_wait_begins', x=300, y=560, label=\"Waiting for&lt;br&gt;Stabilisation\"),\n    EventPosition(event='TRAUMA_stabilisation_begins', x=300, y=490, resource='n_trauma', label=\"Being&lt;br&gt;Stabilised\"),\n\n    EventPosition(event='TRAUMA_treatment_wait_begins', x=630, y=560, label=\"Waiting for&lt;br&gt;Treatment\"),\n    EventPosition(event='TRAUMA_treatment_begins', x=630, y=490, resource='n_cubicles_trauma_treat', label=\"Being&lt;br&gt;Treated\"),\n\n    EventPosition(event='depart', x=670, y=330, label=\"Exit\")\n])",
    "crumbs": [
      "SimPy Examples",
      "Animation of a SimPy Model with Branching and Multiple Steps"
    ]
  },
  {
    "objectID": "examples/example_2_branching_multistep/ex_2_branching_multistep_case.html#setup_mode-true",
    "href": "examples/example_2_branching_multistep/ex_2_branching_multistep_case.html#setup_mode-true",
    "title": "Animation of a SimPy Model with Branching and Multiple Steps",
    "section": "setup_mode = True",
    "text": "setup_mode = True\nsetup_mode allows us to see how the coordinates of our plot relate to the positioning of our background image, allowing us to more accurately place our entities.\n\nanimate_activity_log(\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        debug_mode=True,\n        setup_mode=True,\n        every_x_time_units=5,\n        include_play_button=True,\n        gap_between_entities=11,\n        gap_between_resources=15,\n        gap_between_resource_rows=30,\n        gap_between_queue_rows=30,\n        plotly_height=600,\n        plotly_width=1000,\n        override_x_max=700,\n        override_y_max=675,\n        entity_icon_size=10,\n        resource_icon_size=13,\n        text_size=15,\n        wrap_queues_at=10,\n        step_snapshot_max=20,\n        limit_duration=g.sim_duration,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_2_branching_multistep/Full%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nAnimation function called at 11:55:37\nIteration through time-unit-by-time-unit logs complete 11:55:37\nSnapshot df concatenation complete at 11:55:37\nReshaped animation dataframe finished construction at 11:55:37\nPlacement dataframe finished construction at 11:55:37\nOutput animation generation complete at 11:55:38\nTotal Time Elapsed: 1.74 seconds",
    "crumbs": [
      "SimPy Examples",
      "Animation of a SimPy Model with Branching and Multiple Steps"
    ]
  },
  {
    "objectID": "examples/example_2_branching_multistep/ex_2_branching_multistep_case.html#setup_mode-false",
    "href": "examples/example_2_branching_multistep/ex_2_branching_multistep_case.html#setup_mode-false",
    "title": "Animation of a SimPy Model with Branching and Multiple Steps",
    "section": "setup_mode = False",
    "text": "setup_mode = False\nWe can then rerun our plot with setup_mode=False to remove the grid lines and axis tick marks.\n\nanimate_activity_log(\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        debug_mode=True,\n        setup_mode=False,\n        every_x_time_units=5,\n        include_play_button=True,\n        gap_between_entities=11,\n        gap_between_resources=15,\n        gap_between_resource_rows=30,\n        gap_between_queue_rows=30,\n        plotly_height=600,\n        plotly_width=1000,\n        override_x_max=700,\n        override_y_max=675,\n        entity_icon_size=10,\n        resource_icon_size=13,\n        text_size=15,\n        wrap_queues_at=10,\n        step_snapshot_max=20,\n        limit_duration=g.sim_duration,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_2_branching_multistep/Full%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nAnimation function called at 11:55:39\nIteration through time-unit-by-time-unit logs complete 11:55:40\nSnapshot df concatenation complete at 11:55:40\nReshaped animation dataframe finished construction at 11:55:40\nPlacement dataframe finished construction at 11:55:40\nOutput animation generation complete at 11:55:40\nTotal Time Elapsed: 1.46 seconds",
    "crumbs": [
      "SimPy Examples",
      "Animation of a SimPy Model with Branching and Multiple Steps"
    ]
  },
  {
    "objectID": "examples/example_17_resourceless_larger_queues/resourceless_longer_queues.html",
    "href": "examples/example_17_resourceless_larger_queues/resourceless_longer_queues.html",
    "title": "Ways of visualising larger queues",
    "section": "",
    "text": "While vidigi provides a simple way to see the size of larger queues (via the ‘+ x more’ text that appears when the snapshot max is exceeded), this is not particularly visually intuitive for understanding the magnitude of the different queues that are building up.\nWe could use the synchronised subplot approach from the Additional Synchronised Traces - Orthopaedic Ward - Hospital Efficiency Project example or the gas station example, but when we have multiple steps it could still be challenging to quickly get a sense of where the queues are as your users will have to look across at different parts of the page, and it can be quite a cumbersome thing to add in.\nInstead, it would be better to be able to quickly get a sense of queue size directly next to the relevant step. This poses some challenges in vidigi and there are some limitations - but it is possible!\nSome of what is shown in this example is planned to be incorporated into the package as an official alternative to the ‘+ x more’ snapshot as part of release 1.1.0. However, seeing under the hood will hopefully help you adapt this approach for your own more complex animations.\nWe’ll be working with some of the outputs from the first ‘resourceless’ animation example - the mental health appointment booking model.\nBy the end of that model, we have some queues with as few as 28 people waiting, and some with as high as 462! But because of the way it’s displayed, it’s not easy to get a sense of that.\n\nLet’s kick off with our imports. We’ll be using the separate functions so we can make some changes to the dataframes that get produced along the way.\n\nimport pandas as pd\nimport numpy as np\nimport re\nfrom vidigi.prep import reshape_for_animations, generate_animation_df\nfrom vidigi.animation import generate_animation\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\nWARM_UP = 60 * 1\nRESULTS_COLLECTION = 90 * 1\n\nWe’ve saved the event log produced by the mental health model, so let’s import it here.\n\nevent_log_df = pd.read_csv(\"as-is.csv\")\n\nWe kick off with a pretty normal call of reshape_for_animations, other than setting the step_snapshot_max to be far higher than what is usually seen, and ensuring it’s so high that the model queue will never reach this level (ensuring we get every entity at every stage).\n\nfull_patient_df = reshape_for_animations(\n        event_log_df,\n        entity_col_name=\"patient\",\n        limit_duration=WARM_UP+RESULTS_COLLECTION,\n        every_x_time_units=1,\n        step_snapshot_max=9999999,\n        )\n\n# Remove the warm-up period from the event log\nfull_patient_df = full_patient_df[full_patient_df[\"snapshot_time\"] &gt;= WARM_UP]\n\nNow, for only the stage we want to display as bars instead of individual entities, we will count the total number of patients queueuing at that stage.\nWe also need to give each event within this new dataframe a consistent entity ID across all snapshot_times so it will animate correctly.\n\nreshaped_df = full_patient_df.groupby(['snapshot_time', 'event', 'event_type'])['patient'].count().reset_index()\n\nreshaped_df = reshaped_df[(reshaped_df[\"event\"].str.contains(\"appointment_booked_waiting\")) | reshaped_df[\"event\"].str.contains(\"referred_out\")]\n\nevent_id_map = {event: idx for idx, event in enumerate(reshaped_df['event'].unique())}\n\nreshaped_df['entity_id'] = reshaped_df['event'].map(event_id_map)\nreshaped_df['entity_id'] = reshaped_df['entity_id'].apply(lambda x: f\"BAR{x}\")\nreshaped_df['time'] = reshaped_df['snapshot_time']\n\nreshaped_df = reshaped_df.rename(columns={'patient': 'patient_count'})\n\nreshaped_df.head(40)\n\n\n\n\n\n\n\n\nsnapshot_time\nevent\nevent_type\npatient_count\nentity_id\ntime\n\n\n\n\n0\n60\nappointment_booked_waiting_0\nqueue\n61\nBAR0\n60\n\n\n1\n60\nappointment_booked_waiting_1\nqueue\n9\nBAR1\n60\n\n\n2\n60\nappointment_booked_waiting_10\nqueue\n7\nBAR2\n60\n\n\n3\n60\nappointment_booked_waiting_2\nqueue\n139\nBAR3\n60\n\n\n4\n60\nappointment_booked_waiting_3\nqueue\n52\nBAR4\n60\n\n\n5\n60\nappointment_booked_waiting_4\nqueue\n23\nBAR5\n60\n\n\n6\n60\nappointment_booked_waiting_5\nqueue\n114\nBAR6\n60\n\n\n7\n60\nappointment_booked_waiting_6\nqueue\n61\nBAR7\n60\n\n\n8\n60\nappointment_booked_waiting_7\nqueue\n34\nBAR8\n60\n\n\n9\n60\nappointment_booked_waiting_8\nqueue\n78\nBAR9\n60\n\n\n10\n60\nappointment_booked_waiting_9\nqueue\n212\nBAR10\n60\n\n\n22\n60\nreferred_out_0\nqueue\n6\nBAR11\n60\n\n\n23\n60\nreferred_out_2\nqueue\n3\nBAR12\n60\n\n\n24\n60\nreferred_out_3\nqueue\n1\nBAR13\n60\n\n\n25\n60\nreferred_out_4\nqueue\n1\nBAR14\n60\n\n\n26\n60\nreferred_out_6\nqueue\n1\nBAR15\n60\n\n\n27\n60\nreferred_out_7\nqueue\n1\nBAR16\n60\n\n\n28\n60\nreferred_out_8\nqueue\n4\nBAR17\n60\n\n\n29\n60\nreferred_out_9\nqueue\n7\nBAR18\n60\n\n\n30\n61\nappointment_booked_waiting_0\nqueue\n69\nBAR0\n61\n\n\n31\n61\nappointment_booked_waiting_1\nqueue\n9\nBAR1\n61\n\n\n32\n61\nappointment_booked_waiting_10\nqueue\n8\nBAR2\n61\n\n\n33\n61\nappointment_booked_waiting_2\nqueue\n148\nBAR3\n61\n\n\n34\n61\nappointment_booked_waiting_3\nqueue\n56\nBAR4\n61\n\n\n35\n61\nappointment_booked_waiting_4\nqueue\n23\nBAR5\n61\n\n\n36\n61\nappointment_booked_waiting_5\nqueue\n117\nBAR6\n61\n\n\n37\n61\nappointment_booked_waiting_6\nqueue\n66\nBAR7\n61\n\n\n38\n61\nappointment_booked_waiting_7\nqueue\n36\nBAR8\n61\n\n\n39\n61\nappointment_booked_waiting_8\nqueue\n81\nBAR9\n61\n\n\n40\n61\nappointment_booked_waiting_9\nqueue\n219\nBAR10\n61\n\n\n42\n61\nreferred_out_0\nqueue\n3\nBAR11\n61\n\n\n43\n61\nreferred_out_2\nqueue\n3\nBAR12\n61\n\n\n44\n61\nreferred_out_7\nqueue\n1\nBAR16\n61\n\n\n45\n61\nreferred_out_8\nqueue\n1\nBAR17\n61\n\n\n46\n61\nreferred_out_9\nqueue\n5\nBAR18\n61\n\n\n47\n62\nappointment_booked_waiting_0\nqueue\n74\nBAR0\n62\n\n\n48\n62\nappointment_booked_waiting_1\nqueue\n10\nBAR1\n62\n\n\n49\n62\nappointment_booked_waiting_10\nqueue\n8\nBAR2\n62\n\n\n50\n62\nappointment_booked_waiting_2\nqueue\n153\nBAR3\n62\n\n\n51\n62\nappointment_booked_waiting_3\nqueue\n58\nBAR4\n62\n\n\n\n\n\n\n\nOPTIONAL - but recommend.\nLet’s ensure that there’s a count of patients referred out at every point in time. This will ensure we don’t end up with the counts appearing and disappearing across the course of the animation.\n\n# 1a. Extract unique snapshot_times\nsnapshot_times = reshaped_df['snapshot_time'].unique()\n\n# 1b. Extract unique 'referred_out' event values only\nreferred_out_events = reshaped_df.loc[reshaped_df['event'].str.startswith('referred_out'), 'event'].unique()\n\n# 2. Create a MultiIndex of all combinations of snapshot_time and referred_out_events\nfull_index = pd.MultiIndex.from_product(\n    [snapshot_times, referred_out_events],\n    names=['snapshot_time', 'event']\n)\n\n# 3. Set index of the df to ['snapshot_time', 'event'] to facilitate reindexing\ndf_referred = reshaped_df.set_index(['snapshot_time', 'event'])\n\n# 4. Reindex to full index, filling missing rows with patient_count = 0\ndf_referred = df_referred.reindex(full_index).reset_index()\n\n# 5. For the new rows where patient_count was filled, fill missing columns like event_type, entity_id, time\ndf_referred['patient_count'] = df_referred['patient_count'].fillna(0)\ndf_referred['event_type'] ='queue'\ndf_referred['time'] = df_referred['snapshot_time']\n\n# Build a dictionary mapping each referred_out event to its corresponding entity_id\nevent_to_entity = reshaped_df.loc[\n    reshaped_df['event'].str.startswith('referred_out'),\n    ['event', 'entity_id']\n].drop_duplicates().set_index('event')['entity_id'].to_dict()\n\n# Assign using map\ndf_referred['entity_id'] = df_referred['event'].map(event_to_entity)\n\n# 6. Join this back into our dataframe\nfinal_count_df = pd.concat([\n    reshaped_df[reshaped_df['event'].str.contains(\"appointment_booked_waiting\")],\n    df_referred\n])\n\nWe then join this back to the original dataframe, ensuring we first get rid of the entity-level rows for the stage we’ve just done the counts for.\n\nfull_patient_df = pd.concat(\n    [full_patient_df[(~full_patient_df[\"event\"].str.contains(\"appointment_booked_waiting\")) &\n                     (~full_patient_df[\"event\"].str.contains(\"referred_out\"))].rename(columns={\"patient\": \"entity_id\"}),\n    final_count_df],\n    ignore_index=True\n)\n\n# If we don't fill the NA values with a float number, we encounter issues later where certain actions can't be performed due to the data type of missing values.\nfull_patient_df[\"patient_count\"] = full_patient_df[\"patient_count\"].fillna(0.0)\n\nfull_patient_df = full_patient_df.sort_values([\"snapshot_time\", \"time\", \"entity_id\"])\n\nNow let’s read in our entity positioning dataframe and carry on with the animation steps.\n\nevent_position_df = pd.read_csv(\"as-is_event_position_df.csv\")\n\n# We just use this line to slightly modify the position of one set of our events\nevent_position_df['x'] = event_position_df.apply(\n    lambda row: row['x'] - 120\n    if \"appointment_booked_waiting\" in row['event']\n    else row['x'],  # fallback to original value\n    axis=1\n)\n\nevent_position_df\n\n\n\n\n\n\n\n\nevent\ny\nx\nlabel\nclinic\n\n\n\n\n0\nappointment_booked_waiting_0\n870.0\n505\nBooked into&lt;br&gt;clinic 0 🟠\n0.0\n\n\n1\nappointment_booked_waiting_1\n790.0\n505\nBooked into&lt;br&gt;clinic 1 🟡\n1.0\n\n\n2\nappointment_booked_waiting_2\n710.0\n505\nBooked into&lt;br&gt;clinic 2 🟢\n2.0\n\n\n3\nappointment_booked_waiting_3\n630.0\n505\nBooked into&lt;br&gt;clinic 3 🔵\n3.0\n\n\n4\nappointment_booked_waiting_4\n550.0\n505\nBooked into&lt;br&gt;clinic 4 🟣\n4.0\n\n\n5\nappointment_booked_waiting_5\n470.0\n505\nBooked into&lt;br&gt;clinic 5 🟤\n5.0\n\n\n6\nappointment_booked_waiting_6\n390.0\n505\nBooked into&lt;br&gt;clinic 6 ⚫\n6.0\n\n\n7\nappointment_booked_waiting_7\n310.0\n505\nBooked into&lt;br&gt;clinic 7 ⚪\n7.0\n\n\n8\nappointment_booked_waiting_8\n230.0\n505\nBooked into&lt;br&gt;clinic 8 🔶\n8.0\n\n\n9\nappointment_booked_waiting_9\n150.0\n505\nBooked into&lt;br&gt;clinic 9 🔷\n9.0\n\n\n10\nappointment_booked_waiting_10\n70.0\n505\nBooked into&lt;br&gt;clinic 10 🟩\n10.0\n\n\n11\nhave_appointment_0\n870.0\n850\nAttending appointment&lt;br&gt;at clinic 0\nNaN\n\n\n12\nhave_appointment_1\n790.0\n850\nAttending appointment&lt;br&gt;at clinic 1\nNaN\n\n\n13\nhave_appointment_2\n710.0\n850\nAttending appointment&lt;br&gt;at clinic 2\nNaN\n\n\n14\nhave_appointment_3\n630.0\n850\nAttending appointment&lt;br&gt;at clinic 3\nNaN\n\n\n15\nhave_appointment_4\n550.0\n850\nAttending appointment&lt;br&gt;at clinic 4\nNaN\n\n\n16\nhave_appointment_5\n470.0\n850\nAttending appointment&lt;br&gt;at clinic 5\nNaN\n\n\n17\nhave_appointment_6\n390.0\n850\nAttending appointment&lt;br&gt;at clinic 6\nNaN\n\n\n18\nhave_appointment_7\n310.0\n850\nAttending appointment&lt;br&gt;at clinic 7\nNaN\n\n\n19\nhave_appointment_8\n230.0\n850\nAttending appointment&lt;br&gt;at clinic 8\nNaN\n\n\n20\nhave_appointment_9\n150.0\n850\nAttending appointment&lt;br&gt;at clinic 9\nNaN\n\n\n21\nhave_appointment_10\n70.0\n850\nAttending appointment&lt;br&gt;at clinic 10\nNaN\n\n\n22\nreferred_out_0\n870.0\n125\nReferred Out From &lt;br&gt;clinic 0\nNaN\n\n\n23\nreferred_out_1\n790.0\n125\nReferred Out From &lt;br&gt;clinic 1\nNaN\n\n\n24\nreferred_out_2\n710.0\n125\nReferred Out From &lt;br&gt;clinic 2\nNaN\n\n\n25\nreferred_out_3\n630.0\n125\nReferred Out From &lt;br&gt;clinic 3\nNaN\n\n\n26\nreferred_out_4\n550.0\n125\nReferred Out From &lt;br&gt;clinic 4\nNaN\n\n\n27\nreferred_out_5\n470.0\n125\nReferred Out From &lt;br&gt;clinic 5\nNaN\n\n\n28\nreferred_out_6\n390.0\n125\nReferred Out From &lt;br&gt;clinic 6\nNaN\n\n\n29\nreferred_out_7\n310.0\n125\nReferred Out From &lt;br&gt;clinic 7\nNaN\n\n\n30\nreferred_out_8\n230.0\n125\nReferred Out From &lt;br&gt;clinic 8\nNaN\n\n\n31\nreferred_out_9\n150.0\n125\nReferred Out From &lt;br&gt;clinic 9\nNaN\n\n\n32\nreferred_out_10\n70.0\n125\nReferred Out From &lt;br&gt;clinic 10\nNaN\n\n\n\n\n\n\n\n\nfull_df_plus_pos = generate_animation_df(\n                full_entity_df=full_patient_df,\n                entity_col_name=\"entity_id\",\n                event_position_df=event_position_df,\n                wrap_queues_at=25,\n                step_snapshot_max=9999999,\n                gap_between_entities=20,\n                gap_between_queue_rows=15,\n                debug_mode=True\n        )\n\nPlacement dataframe finished construction at 17:53:58\n\n\nWe’re now going to define a new function that helps us to swap out the counts for an interpretable bar.\n\ndef ascii_queue_icon(count, max_count, bar_length=10, filled_char=\"█\", empty_char=\"░\", count_only=False):\n    \"\"\"\n    Returns an ASCII progress bar string representing the queue length.\n\n    Args:\n        count (int): The current patient count.\n        max_count (int): The maximum patient count in the data.\n        bar_length (int): Total length of the bar in characters.\n        filled_char (str): Character to use for filled segments.\n        empty_char (str): Character to use for empty segments.\n\n    Returns:\n        str: ASCII progress bar string.\n    \"\"\"\n    if count_only:\n        if isinstance(count, str):\n            return count\n        else:\n            return f\"{count:.0f}\"\n    else:\n        if max_count == 0:\n            return empty_char * bar_length  # avoid division by zero\n\n        if not np.isnan(count):\n            filled_len = int(round(bar_length * count / max_count))\n            bar = filled_char * filled_len + empty_char * (bar_length - filled_len)\n            return f\"[{bar}] {count:.0f}\"\n\nLet’s now add this into our dataframe.\n\nfull_df_plus_pos['patient_cumulative'] = full_df_plus_pos.sort_values('snapshot_time').groupby(['event'])['patient_count'].cumsum()\nfull_df_plus_pos['patient_cumulative_count_display'] = full_df_plus_pos.apply(\n    lambda row: f\"{row['patient_cumulative']:.0f} (+{row['patient_count']:.0f})\",  # fallback to original value\n    axis=1\n)\n\n\n# Calculate max patient count only from relevant events\nmax_count = full_df_plus_pos.loc[\n    full_df_plus_pos['event'].str.contains(\"appointment_booked_waiting\"), 'patient_count'\n].max()\n\n# Update the icon column conditionally\nfull_df_plus_pos['icon'] = full_df_plus_pos.apply(\n    lambda row: ascii_queue_icon(row['patient_count'], max_count, 20)\n    if \"appointment_booked_waiting\" in row['event']\n    else row['icon'],  # fallback to original value\n    axis=1\n)\n\nfull_df_plus_pos['icon'] = full_df_plus_pos.apply(\n    lambda row: ascii_queue_icon(row['patient_cumulative_count_display'], max_count, count_only=True)\n    if \"referred_out\" in row['event']\n    else row['icon'],  # fallback to original value\n    axis=1\n)\n\n# Also move the icons over a bit\nfull_df_plus_pos['x_final'] = full_df_plus_pos.apply(\n    lambda row: row['x_final'] - 100\n    if \"appointment_booked_waiting\" in row['event']\n    else row['x_final'],  # fallback to original value\n    axis=1\n)\n\nfull_df_plus_pos['x_final'] = full_df_plus_pos.apply(\n    lambda row: row['x_final'] - 50\n    if \"referred\" in row['event']\n    else row['x_final'],  # fallback to original value\n    axis=1\n)\n\nFrom the sample below, we can see some examples of what the icon will now look like.\n\nfull_df_plus_pos[full_df_plus_pos[\"event\"].str.contains(\"appointment_booked_waiting\")]\n\n\n\n\n\n\n\n\nindex\nentity_id\npathway\nevent_type\nevent\nhome_clinic\ntime\nbooked_clinic\nwait\nevent_original\n...\nx\nlabel\nclinic\nx_final\nrow\ny\nicon\nopacity\npatient_cumulative\npatient_cumulative_count_display\n\n\n\n\n0\nNaN\nBAR0\nNaN\nqueue\nappointment_booked_waiting_0\nNaN\n60\nNaN\nNaN\nNaN\n...\n505.0\nBooked into&lt;br&gt;clinic 0 🟠\n0.0\n405.0\n0.0\nNaN\n[███░░░░░░░░░░░░░░░░░] 61\n1.0\n61.0\n61 (+61)\n\n\n1\nNaN\nBAR0\nNaN\nqueue\nappointment_booked_waiting_0\nNaN\n61\nNaN\nNaN\nNaN\n...\n505.0\nBooked into&lt;br&gt;clinic 0 🟠\n0.0\n405.0\n0.0\nNaN\n[███░░░░░░░░░░░░░░░░░] 69\n1.0\n130.0\n130 (+69)\n\n\n2\nNaN\nBAR0\nNaN\nqueue\nappointment_booked_waiting_0\nNaN\n62\nNaN\nNaN\nNaN\n...\n505.0\nBooked into&lt;br&gt;clinic 0 🟠\n0.0\n405.0\n0.0\nNaN\n[███░░░░░░░░░░░░░░░░░] 74\n1.0\n204.0\n204 (+74)\n\n\n3\nNaN\nBAR0\nNaN\nqueue\nappointment_booked_waiting_0\nNaN\n63\nNaN\nNaN\nNaN\n...\n505.0\nBooked into&lt;br&gt;clinic 0 🟠\n0.0\n405.0\n0.0\nNaN\n[███░░░░░░░░░░░░░░░░░] 73\n1.0\n277.0\n277 (+73)\n\n\n4\nNaN\nBAR0\nNaN\nqueue\nappointment_booked_waiting_0\nNaN\n64\nNaN\nNaN\nNaN\n...\n505.0\nBooked into&lt;br&gt;clinic 0 🟠\n0.0\n405.0\n0.0\nNaN\n[███░░░░░░░░░░░░░░░░░] 73\n1.0\n350.0\n350 (+73)\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n996\nNaN\nBAR10\nNaN\nqueue\nappointment_booked_waiting_9\nNaN\n146\nNaN\nNaN\nNaN\n...\n505.0\nBooked into&lt;br&gt;clinic 9 🔷\n9.0\n405.0\n0.0\nNaN\n[███████████████████░] 455\n1.0\n28610.0\n28610 (+455)\n\n\n997\nNaN\nBAR10\nNaN\nqueue\nappointment_booked_waiting_9\nNaN\n147\nNaN\nNaN\nNaN\n...\n505.0\nBooked into&lt;br&gt;clinic 9 🔷\n9.0\n405.0\n0.0\nNaN\n[████████████████████] 461\n1.0\n29071.0\n29071 (+461)\n\n\n998\nNaN\nBAR10\nNaN\nqueue\nappointment_booked_waiting_9\nNaN\n148\nNaN\nNaN\nNaN\n...\n505.0\nBooked into&lt;br&gt;clinic 9 🔷\n9.0\n405.0\n0.0\nNaN\n[████████████████████] 468\n1.0\n29539.0\n29539 (+468)\n\n\n999\nNaN\nBAR10\nNaN\nqueue\nappointment_booked_waiting_9\nNaN\n149\nNaN\nNaN\nNaN\n...\n505.0\nBooked into&lt;br&gt;clinic 9 🔷\n9.0\n405.0\n0.0\nNaN\n[████████████████████] 463\n1.0\n30002.0\n30002 (+463)\n\n\n1000\nNaN\nBAR10\nNaN\nqueue\nappointment_booked_waiting_9\nNaN\n150\nNaN\nNaN\nNaN\n...\n505.0\nBooked into&lt;br&gt;clinic 9 🔷\n9.0\n405.0\n0.0\nNaN\n[████████████████████] 463\n1.0\n30465.0\n30465 (+463)\n\n\n\n\n1001 rows × 24 columns\n\n\n\nWith this done, we can generate our animation!\n\ngenerate_animation(\n        full_entity_df_plus_pos=full_df_plus_pos,\n        event_position_df=event_position_df,\n        scenario=None,\n        plotly_height=800,\n        plotly_width=1000,\n        override_x_max=1000,\n        override_y_max=1000,\n        entity_icon_size=10,\n        text_size=10,\n        include_play_button=True,\n        add_background_image=None,\n        display_stage_labels=True,\n        time_display_units=\"d\",\n        simulation_time_unit=\"days\",\n        start_date=\"2022-06-27\",\n        setup_mode=False,\n        frame_duration=1500, #milliseconds\n        frame_transition_duration=1000, #milliseconds\n        debug_mode=False\n    )\n\n        \n        \n        \n\n\n                                                    \n\n\nNote that the flow of the patients to their actual appointments is somewhat unintuitive. One simple option is to remove the play button option, which means users can only scrub. This removes any frame interpolation, leading to a more interpretable plot.\n\ngenerate_animation(\n        full_entity_df_plus_pos=full_df_plus_pos,\n        event_position_df=event_position_df,\n        scenario=None,\n        plotly_height=800,\n        plotly_width=1000,\n        override_x_max=1000,\n        override_y_max=1000,\n        entity_icon_size=10,\n        text_size=10,\n        include_play_button=False,   # CHANGED\n        add_background_image=None,\n        display_stage_labels=True,\n        time_display_units=\"d\",\n        simulation_time_unit=\"days\",\n        start_date=\"2022-06-27\",\n        setup_mode=False,\n        # frame_duration=1500, #milliseconds\n        # frame_transition_duration=1000, #milliseconds\n        debug_mode=False\n    )\n\nError changing frame duration\nError changing frame transition duration\n\n\n                                                    \n\n\nWe can achieve something similar while not losing the play button by turning the play button back on and setting the frame transition duration to 0.\n\ngenerate_animation(\n        full_entity_df_plus_pos=full_df_plus_pos,\n        event_position_df=event_position_df,\n        scenario=None,\n        plotly_height=800,\n        plotly_width=1000,\n        override_x_max=1000,\n        override_y_max=1000,\n        entity_icon_size=10,\n        text_size=10,\n        include_play_button=True,\n        add_background_image=None,\n        display_stage_labels=True,\n        time_display_units=\"d\",\n        simulation_time_unit=\"days\",\n        start_date=\"2022-06-27\",\n        setup_mode=False,\n        frame_duration=1500, #milliseconds\n        frame_transition_duration=0, #milliseconds   # CHANGED\n        debug_mode=False\n    )\n\n                                                    \n\n\nNow, in this particular example, it perhaps doesn’t feel like we’re getting a huge amount more information than we would from any old animated bar chart.\nSo let’s add the final LOS of each individual at the point they attend the clinic, and whether they were a priority patient.\n\ndef show_priority_icon(row):\n    if \"have_appointment\" in row[\"event\"]:\n        if int(row[\"pathway\"]) == 2:\n            return \"🚨\"\n        else:\n            return row[\"icon\"]\n    else:\n        return row[\"icon\"]\n\ndef add_los_to_icon(row):\n    if \"have_appointment\" in row[\"event\"]:\n        return f'{row[\"icon\"]}&lt;br&gt;{int(row[\"wait\"])}'\n    else:\n        return row[\"icon\"]\n\n\nfull_df_plus_pos = full_df_plus_pos.assign(\n    icon=full_df_plus_pos.apply(show_priority_icon, axis=1)\n    )\n\nfull_df_plus_pos = full_df_plus_pos.assign(\n    icon=full_df_plus_pos.apply(add_los_to_icon, axis=1)\n    )\n\n\ngenerate_animation(\n        full_entity_df_plus_pos=full_df_plus_pos,\n        event_position_df=event_position_df,\n        scenario=None,\n        plotly_height=800,\n        plotly_width=1200,\n        override_x_max=1000,\n        override_y_max=1000,\n        entity_icon_size=10,\n        text_size=10,\n        include_play_button=True,\n        add_background_image=None,\n        display_stage_labels=True,\n        time_display_units=\"d\",\n        simulation_time_unit=\"days\",\n        start_date=\"2022-06-27\",\n        setup_mode=False,\n        frame_duration=1000, #milliseconds\n        frame_transition_duration=0, #milliseconds   # CHANGED\n        debug_mode=False\n    )\n\n                                                    \n\n\nValues below the individuals show the wait time in days.\nPriority patients are identified with a 🚨 symbol. These patients will be moved to the front of the booking queue.\n\nExploring experimental alternative 1: Replacing ‘x more’ with ascii count bar\n\ndef ascii_queue_icon(icon, count, max_count, bar_length=10, filled_char=\"█\", empty_char=\"░\", count_only=False):\n    \"\"\"\n    Returns an ASCII progress bar string representing the queue length.\n\n    Args:\n        icon (str): The current icon\n        count (int): The current patient count.\n        max_count (int): The maximum patient count in the data.\n        bar_length (int): Total length of the bar in characters.\n        filled_char (str): Character to use for filled segments.\n        empty_char (str): Character to use for empty segments.\n\n    Returns:\n        str: ASCII progress bar string.\n    \"\"\"\n    if max_count == 0:\n        return empty_char * bar_length  # avoid division by zero\n\n    if not np.isnan(count):\n        if count_only:\n            return f\"{count:.0f}\"\n        else:\n            if \"more\" in icon:\n                filled_len = int(round(bar_length * count / max_count))\n                bar = filled_char * filled_len + empty_char * (bar_length - filled_len)\n                return f\"[{bar}] + {count:.0f} more\"\n            else:\n                return icon\n\n\n    else:\n        return \"\"\n\n\nevent_log_df = pd.read_csv(\"as-is.csv\")\nfull_patient_df = reshape_for_animations(\n        event_log_df,\n        entity_col_name=\"patient\",\n        limit_duration=WARM_UP+RESULTS_COLLECTION,\n        every_x_time_units=1,\n        step_snapshot_max=10,\n        )\n\n# Remove the warm-up period from the event log\nfull_patient_df = full_patient_df[full_patient_df[\"snapshot_time\"] &gt;= WARM_UP]\n\nevent_position_df = pd.read_csv(\"as-is_event_position_df.csv\")\n\nevent_position_df['x'] = event_position_df.apply(\n    lambda row: row['x'] - 70\n    if \"appointment_booked_waiting\" in row['event']\n    else row['x'],  # fallback to original value\n    axis=1\n)\n\nfull_df_plus_pos = generate_animation_df(\n                full_entity_df=full_patient_df,\n                entity_col_name=\"patient\",\n                event_position_df=event_position_df,\n                wrap_queues_at=10,\n                step_snapshot_max=50,\n                gap_between_entities=15,\n                gap_between_queue_rows=20,\n                debug_mode=True\n        )\n\nfull_df_plus_pos['patient_count'] = full_df_plus_pos.apply(\n    lambda row: int(re.search(r'\\d+', row['icon'])[0])\n    if \"more\" in row['icon']\n    else 0,\n    axis=1\n)\n\nmax_count = max(full_df_plus_pos['patient_count'])\n\nPlacement dataframe finished construction at 17:54:06\n\n\n\n# Update the icon column conditionally\nfull_df_plus_pos['icon'] = full_df_plus_pos.apply(\n    lambda row: ascii_queue_icon(row['icon'], row['patient_count'], max_count, 10)\n    if \"appointment_booked_waiting\" in row['event']\n    else row['icon'],  # fallback to original value\n    axis=1\n)\n\n# Also move the icon over a bit\nfull_df_plus_pos['x_final'] = full_df_plus_pos.apply(\n    lambda row: row['x_final'] - 100\n    if \"appointment_booked_waiting\" in row['event']\n    else row['x_final'],  # fallback to original value\n    axis=1\n)\n\n\ngenerate_animation(\n        full_entity_df_plus_pos=full_df_plus_pos,\n        event_position_df=event_position_df,\n        entity_col_name=\"patient\",\n        scenario=None,\n        plotly_height=1000,\n        plotly_width=1000,\n        override_x_max=1000,\n        override_y_max=1000,\n        entity_icon_size=10,\n        text_size=10,\n        include_play_button=True,\n        add_background_image=None,\n        display_stage_labels=True,\n        time_display_units=\"d\",\n        simulation_time_unit=\"days\",\n        start_date=\"2022-06-27\",\n        setup_mode=False,\n        frame_duration=1500, #milliseconds\n        frame_transition_duration=1000, #milliseconds\n        debug_mode=False\n    )\n\n                                                    \n\n\nLet’s again try setting our frame duration to 0.\n\ngenerate_animation(\n        full_entity_df_plus_pos=full_df_plus_pos,\n        event_position_df=event_position_df,\n        entity_col_name=\"patient\",\n        scenario=None,\n        plotly_height=1000,\n        plotly_width=1000,\n        override_x_max=1000,\n        override_y_max=1000,\n        entity_icon_size=10,\n        text_size=10,\n        include_play_button=True,\n        add_background_image=None,\n        display_stage_labels=True,\n        time_display_units=\"d\",\n        simulation_time_unit=\"days\",\n        start_date=\"2022-06-27\",\n        setup_mode=False,\n        frame_duration=1500, #milliseconds\n        frame_transition_duration=30, #milliseconds\n        debug_mode=False\n    )",
    "crumbs": [
      "SimPy Examples",
      "Ways of visualising larger queues"
    ]
  },
  {
    "objectID": "examples/example_15_gas_station_refuelling/gas_station.html",
    "href": "examples/example_15_gas_station_refuelling/gas_station.html",
    "title": "Visualising a more complex status alongside entity icons - gas station with individual fuel tank level",
    "section": "",
    "text": "from vidigi.utils import EventPosition, create_event_position_df\nfrom vidigi.prep import reshape_for_animations, generate_animation_df\nfrom vidigi.animation import generate_animation, animate_activity_log\nimport pandas as pd\nimport os\nimport random\nfrom plotly.subplots import make_subplots\nimport plotly.io as pio\nimport plotly.graph_objects as go\nimport plotly.express as px\npio.renderers.default = \"notebook\"\n# Define positions for animation\nevent_positions = create_event_position_df([\n    EventPosition(event='arrival', x=0, y=350, label=\"Entrance\"),\n    EventPosition(event='pump_queue_wait_begins', x=400, y=350, label=\"Queue\"),\n    EventPosition(event='payment_begins', x=340, y=175, resource='num_pumps',\n                  label=\"Pumping Gas\"),\n    EventPosition(event='pumping_begins', x=340, y=175, resource='num_pumps',\n                  label=\"Pumping Gas\"),\n    EventPosition(event='calling_truck', x=140, y=50,\n                  label=\"Calling Truck\"),\n        EventPosition(event='refuelling', x=340, y=50,\n                  label=\"Truck Filling Tank\"),\n    EventPosition(event='depart', x=250, y=50, label=\"Exit\")\n])\n\nclass Params:\n    def __init__(self):\n        self.num_pumps = 2\n\nicon_list = [ \"🚗\", \"🚙\", \"🚓\",\n            \"🚗\", \"🚙\", \"🏍️\", \"🏍️\",\n            \"🚗\", \"🚙\", \"🚑\",\n            \"🚗\", \"🚙\", \"🛻\",\n            \"🚗\", \"🚙\", \"🚛\",\n            \"🚗\", \"🚙\", \"🚕\",\n            \"🚗\", \"🚙\", \"🚒\",\n            \"🚗\", \"🚙\", \"🚑\"]\n\nrandom.shuffle(icon_list)\nevent_log_df = pd.read_csv(\"gas_station_log.csv\")\nSTEP_SNAPSHOT_MAX = 6\nLIMIT_DURATION = 60*60*3\nWRAP_QUEUES_AT = 3\nfull_entity_df = reshape_for_animations(\n    event_log=event_log_df,\n    every_x_time_units=5,\n    step_snapshot_max=STEP_SNAPSHOT_MAX,\n    limit_duration=LIMIT_DURATION,\n    debug_mode=True\n    )\n\nfull_entity_df_plus_pos = generate_animation_df(\n    full_entity_df=full_entity_df,\n    event_position_df=event_positions,\n    wrap_queues_at=WRAP_QUEUES_AT,\n    step_snapshot_max=STEP_SNAPSHOT_MAX,\n    gap_between_entities=150,\n    gap_between_resources=180,\n    gap_between_queue_rows=150,\n    # gap_between_resource_rows=60,\n    debug_mode=True,\n    custom_entity_icon_list=icon_list\n    )\n\nIteration through time-unit-by-time-unit logs complete 17:55:30\nSnapshot df concatenation complete at 17:55:30\nPlacement dataframe finished construction at 17:55:30\ndef build_fuel_bar(value, max_value=50, length=10):\n    \"\"\"Create an ASCII bar to show fuel level.\"\"\"\n    try:\n        if value is None or (isinstance(value, float) and (value != value)):  # check for None or NaN\n            proportion = 0\n        else:\n            proportion = min(max(value / max_value, 0), 1)\n    except Exception:\n        proportion = 0  # fallback\n\n    filled = int(proportion * length)\n    empty = length - filled\n    filled_icon = \"█\"\n    empty_icon = \"░\"\n    return \"[\" + filled_icon * filled + empty_icon * empty + \"]\"\ndef custom_icon_rules(row):\n    icon = row.get(\"icon\", \"\")\n    entity_id = row.get(\"entity_id\", \"\")\n    event = row.get(\"event\", \"\")\n    fuel_level_start = row.get(\"fuel_level_start\", None)  # Only for cars\n\n    if \"more\" not in str(icon):\n        if isinstance(entity_id, str):\n            if \"Truck\" in entity_id:\n                return \"🚚 Truck is refilling the tank...\"\n            elif \"Call\" in entity_id:\n                return \"☎️ Calling Truck!\"\n            elif \"Car\" in entity_id:\n                bar = \"\"\n                if (event == \"arrival\" or event == \"pump_queue_wait_begins\") and fuel_level_start is not None:\n                    bar = \" \" + build_fuel_bar(fuel_level_start)\n                    return icon + \"&lt;br&gt;\" + bar + \"&lt;br&gt;&lt;br&gt;\"\n                elif event == \"payment_begins\" and fuel_level_start is not None:\n                    bar = \" \" + build_fuel_bar(fuel_level_start)\n                    return icon+ \"&lt;br&gt;\" + bar + \"&lt;br&gt; Paying\"\n                elif event == \"pumping_begins\" and fuel_level_start is not None:\n                    arrival_time = row[\"time\"]\n                    elapsed = max(float(row[\"snapshot_time\"]) - float(arrival_time), 0)\n                    current_fuel = min(fuel_level_start + elapsed * 1, 50)\n                    bar = \" \" + build_fuel_bar(current_fuel)\n                    return icon+ \"&lt;br&gt;\" + bar + \"&lt;br&gt; Pumping\"\n                elif event == \"departure\" or event == \"pumping_ends\":\n                    bar = \" \" + build_fuel_bar(50)  # Car is full when it leaves\n                    return icon+ \"&lt;br&gt;\" + bar + \"&lt;br&gt; &lt;br&gt;\"\n\n\n            else:\n                return icon\n    return icon\n\n\nfull_entity_df_plus_pos = full_entity_df_plus_pos.assign(\n            icon=full_entity_df_plus_pos.apply(custom_icon_rules, axis=1)\n            )\nfig = generate_animation(\n        full_entity_df_plus_pos=full_entity_df_plus_pos.sort_values(['entity_id', 'snapshot_time']),\n        event_position_df= event_positions,\n        scenario=Params(),\n        simulation_time_unit=\"seconds\",\n        plotly_height=900,\n        plotly_width=1200,\n        override_x_max=500,\n        override_y_max=750,\n        entity_icon_size=30,\n        gap_between_resources=180,\n        display_stage_labels=False,\n        # resource_opacity=1,\n        resource_opacity=0,\n        setup_mode=False,\n        # custom_resource_icon=\"⛽\",\n        resource_icon_size=40,\n        add_background_image=\"https://raw.githubusercontent.com/hsma-tools/vidigi/refs/heads/main/examples/example_15_gas_station_refuelling/gas_station.png\",\n        background_image_opacity=1, # New parameter in 1.1.0\n        overflow_text_color=\"white\", # New parameter in 1.1.0\n        start_time=\"09:00:00\",\n        time_display_units=\"%H:%M:%S\",\n        debug_mode=True,\n        frame_duration=100,\n        frame_transition_duration=100\n    )\n\nfig\n\nOutput animation generation complete at 17:55:39\nfuel_level_change_df = event_log_df[(event_log_df[\"event_type\"]==\"fuel_level_change\") &\n                                    (event_log_df[\"time\"] % 5 == 0) &\n                                    (event_log_df[\"time\"] &lt; LIMIT_DURATION)]\n\npx.bar(fuel_level_change_df, x=\"entity_id\", y=\"value\", animation_frame=\"time\", range_y=[0,400])",
    "crumbs": [
      "SimPy Examples",
      "Visualising a more complex status alongside entity icons - gas station with individual fuel tank level"
    ]
  },
  {
    "objectID": "examples/example_15_gas_station_refuelling/gas_station.html#explore-incorporating-the-fuel-level-bar-plot-as-an-additional-synchronised-plot",
    "href": "examples/example_15_gas_station_refuelling/gas_station.html#explore-incorporating-the-fuel-level-bar-plot-as-an-additional-synchronised-plot",
    "title": "Visualising a more complex status alongside entity icons - gas station with individual fuel tank level",
    "section": "Explore incorporating the fuel level bar plot as an additional synchronised plot",
    "text": "Explore incorporating the fuel level bar plot as an additional synchronised plot\n\n## Same as before, but increase the height to give space for some of it to be taken up by the bar plot later\n\nfig = generate_animation(\n        full_entity_df_plus_pos=full_entity_df_plus_pos.sort_values(['entity_id', 'snapshot_time']),\n        event_position_df= event_positions,\n        scenario=Params(),\n        simulation_time_unit=\"seconds\",\n        plotly_height=1000,\n        plotly_width=1200,\n        override_x_max=500,\n        override_y_max=750,\n        entity_icon_size=30,\n        gap_between_resources=180,\n        display_stage_labels=False,\n        # resource_opacity=1,\n        resource_opacity=0,\n        setup_mode=False,\n        # custom_resource_icon=\"⛽\",\n        resource_icon_size=40,\n        add_background_image=\"https://raw.githubusercontent.com/hsma-tools/vidigi/refs/heads/main/examples/example_15_gas_station_refuelling/gas_station.png\",\n        background_image_opacity=1, # New parameter in 1.1.0\n        overflow_text_color=\"white\", # New parameter in 1.1.0\n        start_time=\"09:00:00\",\n        time_display_units=\"%H:%M:%S\",\n        debug_mode=True,\n        frame_duration=100,\n        frame_transition_duration=100\n    )\n\nOutput animation generation complete at 17:55:53\n\n\n\n# Set up the desired subplot layout\nROWS = 2\n\nsp = make_subplots(\n    rows=ROWS,\n    cols=1,\n    row_heights=[0.75, 0.25],\n    vertical_spacing=0.05,\n    subplot_titles=(\n        \"\", # Original Animation\n        \"Station Tank Fuel Level\", # Fuel Tank Level\n        )\n    )\n\n# Overwrite the domain of our original x and y axis with domain from the new axis\nfig.layout['xaxis']['domain'] = sp.layout['xaxis']['domain']\nfig.layout['yaxis']['domain'] = sp.layout['yaxis']['domain']\n\nfor i in range(2, ROWS+1):\n\n    # Add in the attributes for the secondary axis from our subplot\n    fig.layout[f'xaxis{i}'] = sp.layout[f'xaxis{i}']\n    fig.layout[f'yaxis{i}'] = sp.layout[f'yaxis{i}']\n\nfig._grid_ref = sp._grid_ref\n\n\n# First, extract the trace containing the resource icons\n# icon_trace = fig.data[1]\n\n# Now keep our figure data as just the initial trace.\nfig.data = (fig.data[0],)\n\n# 1. RESOURCE ICONS TRACE\n# Readd the resource icons trace in a consistent manner\n# Confusingly, when we start messing with the naimation frames, we lose the resource icon trace\n# even though it appeared fine until this point - so we have to handle it here\n# fig.add_trace(icon_trace)\n\n# 2. BAR PLOT ON SECONDARY AXIS (animated barplot in subplot)\n# Initialize with a single point and assign it to subplot axes (x2/y2)\n\n# Get unique time points\ntime_points = fuel_level_change_df[\"time\"].unique()\n\n# Initial frame (first time point)\ninitial_time = time_points[0]\ninitial_df = fuel_level_change_df[fuel_level_change_df[\"time\"] == initial_time]\n\n# Create the initial bar trace\n\nfig.add_trace(go.Bar(\n    x=[fuel_level_change_df[\"entity_id\"].values[0]],\n    y=[fuel_level_change_df[\"value\"].values[0]],\n    showlegend=False\n    # We place it in our new subplot using the following line\n), row=2, col=1)\n\n                                                    \n\n\n\n# # Now ensure we tell it which traces we are animating\n# # (as per https://chart-studio.plotly.com/~empet/15243/animating-traces-in-subplotsbr/#/)\nfor i, frame in enumerate(fig.frames):\n    # Your original frame.data\n    # This will be a tuple\n    # We'll ensure we only take the first entry\n    # original_data = (frame.data[0], )\n\n    original_data = frame.data\n\n    # The new data you want to add for this specific frame\n    new_data = (\n        # 0: resource icons\n        # icon_trace,\n\n        go.Bar(\n            x= [fuel_level_change_df.sort_values('time')['entity_id'].values[i]],\n            y= [fuel_level_change_df.sort_values('time')['value'].values[i]]\n        ) ,  # This needs to be a tuple even if we're only adding a single additional trace, hence the comma\n    )\n\n    frame.data = original_data + new_data\n\n\nfig",
    "crumbs": [
      "SimPy Examples",
      "Visualising a more complex status alongside entity icons - gas station with individual fuel tank level"
    ]
  },
  {
    "objectID": "examples/example_14_carwash/carwash.html",
    "href": "examples/example_14_carwash/carwash.html",
    "title": "Examples from Outside of Healthcare: Carwash",
    "section": "",
    "text": "This is one of the examples provided in the simpy documentation, with vidigi logging added.\nhttps://simpy.readthedocs.io/en/latest/examples/carwash.html\nfrom vidigi.animation import animate_activity_log\nfrom vidigi.utils import EventPosition, create_event_position_df\nimport pandas as pd\nimport os\nimport random\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\n# Define positions for animation\nevent_positions = create_event_position_df([\n    EventPosition(event='arrival', x=0, y=350, label=\"Entrance\"),\n    EventPosition(event='carwash_queue_wait_begins', x=350, y=200, label=\"Queue\"),\n    EventPosition(event='carwashing_begins', x=340, y=100, resource='num_carwashes',\n                  label=\"Being Washed\"),\n    EventPosition(event='depart', x=250, y=50, label=\"Exit\")\n])\n\nclass Params:\n    def __init__(self):\n        self.num_carwashes = 2\n\nicon_list = [ \"🚗\", \"🚙\", \"🚓\",\n            \"🚗\", \"🚙\", \"🏎️\",\n            \"🚗\", \"🚙\", \"🚚\",\n            \"🚗\", \"🚙\", \"🛻\",\n            \"🚗\", \"🚙\", \"🚛\",\n            \"🚗\", \"🚙\", \"🚕\",\n            \"🚗\", \"🚙\", \"🚒\",\n            \"🚗\", \"🚙\", \"🚑\"]\n\nrandom.shuffle(icon_list)\nNote that this animation uses several new parameters introduced in v1.1.0 of vidigi.\n# Create animation\ndef generate_carwash_animation(event_log_df):\n    return animate_activity_log(\n        event_log=event_log_df,\n        event_position_df=event_positions,\n        scenario=Params(),\n        every_x_time_units=1,\n        plotly_height=800,\n        plotly_width=800,\n        override_x_max=400,\n        override_y_max=400,\n        limit_duration=60*8,\n        entity_icon_size=50,\n        gap_between_entities=50,\n        gap_between_resources=180,\n        display_stage_labels=False,\n        wrap_queues_at=7,\n        step_snapshot_max=7*3,\n        gap_between_queue_rows=60,\n        custom_entity_icon_list=icon_list,\n        resource_opacity=0,\n        setup_mode=False,\n        add_background_image=\"https://raw.githubusercontent.com/hsma-tools/vidigi/refs/heads/main/examples/example_14_carwash/carwash_bg.png\",\n        background_image_opacity=1, # New parameter in 1.1.0\n        overflow_text_color=\"white\", # New parameter in 1.1.0\n        start_time=\"09:00:00\",\n        time_display_units=\"day_clock\"\n    )",
    "crumbs": [
      "SimPy Examples",
      "Examples from Outside of Healthcare: Carwash"
    ]
  },
  {
    "objectID": "examples/example_14_carwash/carwash.html#run-with-a-short-inter-arrival-time-to-force-queues-to-build-up",
    "href": "examples/example_14_carwash/carwash.html#run-with-a-short-inter-arrival-time-to-force-queues-to-build-up",
    "title": "Examples from Outside of Healthcare: Carwash",
    "section": "Run with a short inter-arrival time to force queues to build up",
    "text": "Run with a short inter-arrival time to force queues to build up\n\n# Display log\ngenerate_carwash_animation(pd.read_csv(\"logs_2_machines_2_IAT.csv\"))",
    "crumbs": [
      "SimPy Examples",
      "Examples from Outside of Healthcare: Carwash"
    ]
  },
  {
    "objectID": "examples/example_14_carwash/carwash.html#run-with-the-standard-inter-arrival-time-from-the-simpy-documentation",
    "href": "examples/example_14_carwash/carwash.html#run-with-the-standard-inter-arrival-time-from-the-simpy-documentation",
    "title": "Examples from Outside of Healthcare: Carwash",
    "section": "Run with the standard inter-arrival time from the simpy documentation",
    "text": "Run with the standard inter-arrival time from the simpy documentation\n\n# Display log\ngenerate_carwash_animation(pd.read_csv(\"logs_2_machines_7_IAT.csv\"))",
    "crumbs": [
      "SimPy Examples",
      "Examples from Outside of Healthcare: Carwash"
    ]
  },
  {
    "objectID": "examples/example_13_additional_synchronised_traces_method_1/synchronised_traces.html",
    "href": "examples/example_13_additional_synchronised_traces_method_1/synchronised_traces.html",
    "title": "Additional Synchronised Traces - Orthopaedic Ward - Hospital Efficiency Project",
    "section": "",
    "text": "This is the orthopaedic surgery model developed as part of the hospital efficiency project.\noriginal model author = Harper, Alison and Monks, Thomas\nlicense = MIT\ntitle = Hospital Efficiency Project Orthopaedic Planning Model Discrete-Event Simulation\nurl = https://github.com/AliHarp/HEP\nIt has been used as a test case here to allow the development and testing of several key features of the event log animations:\n\nadding of logging to a model from scratch\nensuring the requirement to use simpy stores instead of simpy resources doesn’t prevent the uses of certain common modelling patterns (in this case, conditional logic where patients will leave the system if a bed is not available within a specified period of time)\ndisplaying different icons for different classes of patients\ndisplaying custom resource icons\ndisplaying additional static information as part of the icon (in this case, whether the client’s discharge is delayed)\ndisplaying information that updates with each animation step as part of the icon (in this case, the LoS of the patient at each time point)\n\n\nimport time\nimport pandas as pd\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom examples.example_13_additional_synchronised_traces_method_1.simulation_execution_functions import multiple_replications\nfrom examples.example_13_additional_synchronised_traces_method_1.model_classes import Scenario, Schedule\nfrom vidigi.prep import reshape_for_animations, generate_animation_df\nfrom vidigi.animation import generate_animation\nfrom plotly.subplots import make_subplots\n\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\n\nTRACE = True\ndebug_mode=True\n\nschedule = Schedule()\n\n4 theatres\n5 day/week\nEach theatre has three sessions per day:\nMorning: 1 revision OR 2 primary\nAfternoon: 1 revision OR 2 primary\nEvening: 1 primary\n40 ring-fenced beds for recovery from these operations\n\n(pd.DataFrame.from_dict(schedule.sessions_per_weekday, orient=\"index\")\n        .rename(columns={0: \"Sessions\"}).merge(\n\n        pd.DataFrame.from_dict(schedule.theatres_per_weekday, orient=\"index\")\n            .rename(columns={0: \"Theatre Capacity\"}),\n            left_index=True, right_index=True\n\n        ).merge(\n\n        pd.DataFrame.from_dict(schedule.allocation, orient=\"index\"),\n        left_index=True, right_index=True\n\n        ))\n\n\n\n\n\n\n\n\nSessions\nTheatre Capacity\n0\n1\n2\n\n\n\n\nMonday\n3\n4\n2P_or_1R\n2P_or_1R\n1P\n\n\nTuesday\n3\n4\n2P_or_1R\n2P_or_1R\n1P\n\n\nWednesday\n3\n4\n2P_or_1R\n2P_or_1R\n1P\n\n\nThursday\n3\n4\n2P_or_1R\n2P_or_1R\n1P\n\n\nFriday\n3\n4\n2P_or_1R\n2P_or_1R\n1P\n\n\nSaturday\n0\n0\nNone\nNone\nNone\n\n\nSunday\n0\n0\nNone\nNone\nNone\n\n\n\n\n\n\n\n\nn_beds = 35\n\nprimary_hip_los = 4.4\n\nprimary_knee_los = 4.7\n\nrevision_hip_los = 6.9\n\nrevision_knee_los = 7.2\n\nunicompart_knee_los = 2.9\n\nlos_delay = 16.5\nlos_delay_sd = 15.2\n\nprop_delay = 0.076\n\nreplications = 30\nruntime = 60\nwarmup=7\n\nargs = Scenario(schedule=schedule,\n                primary_hip_mean_los=primary_hip_los,\n                primary_knee_mean_los=primary_knee_los,\n                revision_hip_mean_los=revision_hip_los,\n                revision_knee_mean_los=revision_knee_los,\n                unicompart_knee_mean_los=unicompart_knee_los,\n                prob_ward_delay=prop_delay,\n                n_beds=n_beds,\n                delay_post_los_mean=los_delay,\n                delay_post_los_sd=los_delay_sd\n                )\n\n\nresults = multiple_replications(\n                return_detailed_logs=True,\n                scenario=args,\n                n_reps=replications,\n                results_collection=runtime\n            )\n\n\n\n\n# Join the event log with a list of patients to add a column that will determine\n# the icon set used for a patient (in this case, we want to distinguish between the\n# knee/hip patients)\nevent_log = results[4]\nevent_log = event_log[event_log['rep'] == 1].copy()\nevent_log['patient'] = event_log['patient'].astype('str') + event_log['pathway']\n\nprimary_patients = results[2]\nprimary_patients = primary_patients[primary_patients['rep'] == 1]\nprimary_patients['patient class'] = primary_patients['patient class'].str.title()\nprimary_patients['ID'] = primary_patients['ID'].astype('str') + primary_patients['patient class']\n\nrevision_patients = results[3]\nrevision_patients = revision_patients[revision_patients['rep'] == 1]\nrevision_patients['patient class'] = revision_patients['patient class'].str.title()\nrevision_patients['ID'] = revision_patients['ID'].astype('str') + revision_patients['patient class']\n\nfull_log_with_patient_details = event_log.merge(pd.concat([primary_patients, revision_patients]),\n                                                    how=\"left\",\n                                                left_on=[\"patient\", \"pathway\"],\n                                                right_on=[\"ID\", \"patient class\"]).reset_index(drop=True).drop(columns=\"ID\")\n\npid_table = full_log_with_patient_details[['patient']].drop_duplicates().reset_index(drop=True).reset_index(drop=False).rename(columns={'index': 'pid'})\n\nfull_log_with_patient_details = full_log_with_patient_details.merge(pid_table, how='left', on='patient').drop(columns='patient').rename(columns={'pid':'patient'})\n\nC:\\Users\\Sammi\\AppData\\Local\\Temp\\ipykernel_49316\\503693668.py:54: SettingWithCopyWarning:\n\n\nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\nC:\\Users\\Sammi\\AppData\\Local\\Temp\\ipykernel_49316\\503693668.py:55: SettingWithCopyWarning:\n\n\nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\nC:\\Users\\Sammi\\AppData\\Local\\Temp\\ipykernel_49316\\503693668.py:59: SettingWithCopyWarning:\n\n\nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\nC:\\Users\\Sammi\\AppData\\Local\\Temp\\ipykernel_49316\\503693668.py:60: SettingWithCopyWarning:\n\n\nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\n\n\n\n\nevent_position_df = pd.DataFrame([\n            # {'event': 'arrival', 'x':  10, 'y': 250, 'label': \"Arrival\" },\n\n            # Triage - minor and trauma\n            {'event': 'enter_queue_for_bed',\n                'x':  300, 'y': 600, 'label': \"Waiting for&lt;br&gt;Availability of&lt;br&gt;Bed to be Confirmed&lt;br&gt;Before Surgery\" },\n\n            {'event': 'no_bed_available',\n                'x':  800, 'y': 600, 'label': \"No Bed&lt;br&gt;Available:&lt;br&gt;Surgery Cancelled\" },\n\n            {'event': 'post_surgery_stay_begins',\n                'x':  850, 'y': 220, 'resource':'n_beds', 'label': \"In Bed:&lt;br&gt;Recovering from&lt;br&gt;Surgery\" },\n\n            {'event': 'discharged_after_stay',\n                'x':  770, 'y': 50, 'label': \"Discharged from Hospital&lt;br&gt;After Recovery\"}\n            # {'event': 'exit',\n            #  'x':  670, 'y': 100, 'label': \"Exit\"}\n\n            ])\n\n\nfull_patient_df = reshape_for_animations(full_log_with_patient_details,\n                                         entity_col_name=\"patient\",\n                                            every_x_time_units=1,\n                                            limit_duration=runtime,\n                                            step_snapshot_max=50,\n                                            debug_mode=debug_mode\n                                            )\n\nif debug_mode:\n    print(f'Reshaped animation dataframe finished construction at {time.strftime(\"%H:%M:%S\", time.localtime())}')\n\nIteration through time-unit-by-time-unit logs complete 12:30:40\nSnapshot df concatenation complete at 12:30:40\nReshaped animation dataframe finished construction at 12:30:41\n\n\n\nfull_patient_df_plus_pos = generate_animation_df(\n                            full_entity_df=full_patient_df,\n                            entity_col_name=\"patient\",\n                            event_position_df=event_position_df,\n                            wrap_queues_at=20,\n                            wrap_resources_at=40,\n                            step_snapshot_max=50,\n                            gap_between_entities=20,\n                            gap_between_resources=20,\n                            gap_between_queue_rows=175,\n                            gap_between_resource_rows=175,\n                            debug_mode=debug_mode\n                    )\n\nPlacement dataframe finished construction at 12:30:41\n\n\n\ndef set_icon(row):\n    if row[\"surgery type\"] == \"p_knee\":\n        return \"🦵&lt;br&gt;1️⃣&lt;br&gt; \"\n    elif row[\"surgery type\"] == \"r_knee\":\n        return \"🦵&lt;br&gt;♻️&lt;br&gt; \"\n    elif row[\"surgery type\"] == \"p_hip\":\n        return \"🕺&lt;br&gt;1️⃣&lt;br&gt; \"\n    elif row[\"surgery type\"] == \"r_hip\":\n        return \"🕺&lt;br&gt;♻️&lt;br&gt; \"\n    elif row[\"surgery type\"] == \"uni_knee\":\n        return \"🦵&lt;br&gt;✳️&lt;br&gt; \"\n    else:\n        return f\"CHECK&lt;br&gt;{row['icon']}\"\n\nfull_patient_df_plus_pos = full_patient_df_plus_pos.assign(icon=full_patient_df_plus_pos.apply(set_icon, axis=1))\n\n# TODO: Check why this doesn't seem to be working quite right for the 'discharged after stay'\n# step. e.g. 194Primary is discharged on 28th July showing a LOS of 1 but prior to this shows a LOS of 9.\ndef add_los_to_icon(row):\n    if row[\"event\"] == \"post_surgery_stay_begins\":\n        return f'{row[\"icon\"]}&lt;br&gt;&lt;br&gt;{row[\"snapshot_time\"]-row[\"time\"]:.0f}'\n    elif row[\"event\"] == \"discharged_after_stay\":\n        return f'{row[\"icon\"]}&lt;br&gt;{row[\"los\"]:.0f}'\n    else:\n        return row[\"icon\"]\n\nfull_patient_df_plus_pos = full_patient_df_plus_pos.assign(icon=full_patient_df_plus_pos.apply(add_los_to_icon, axis=1))\n\n\ndef indicate_delay_via_icon(row):\n    if row[\"delayed discharge\"] is True:\n        return f'{row[\"icon\"]}&lt;br&gt;*'\n    else:\n        return f'{row[\"icon\"]}&lt;br&gt; '\n\nfull_patient_df_plus_pos = full_patient_df_plus_pos.assign(icon=full_patient_df_plus_pos.apply(indicate_delay_via_icon, axis=1))\n\ncancelled_due_to_no_bed_available = len(full_log_with_patient_details[full_log_with_patient_details['event'] == \"no_bed_available\"][\"patient\"].unique())\ntotal_patients = len(full_log_with_patient_details[\"patient\"].unique())\n\ncancelled_perc = cancelled_due_to_no_bed_available/total_patients\n\n# st.markdown(f\"Surgeries cancelled due to no bed being available in time: {cancelled_perc:.2%} ({cancelled_due_to_no_bed_available} of {total_patients})\")\n\n# st.markdown(\n#     \"\"\"\n#     **Key**:\n\n#     🦵1️⃣: Primary Knee\n\n#     🦵♻️: Revision Knee\n\n#     🕺1️⃣: Primary Hip\n\n#     🕺♻️: Revision Hip\n\n#     🦵✳️: Primary Unicompartment Knee\n\n#     An asterisk (*) indicates that the patient has a delayed discharge from the ward.\n\n#     The numbers below patients indicate their length of stay.\n\n#     Note that the \"No Bed Available: Surgery Cancelled\" and \"Discharged from Hospital after Recovery\" stages in the animation are lagged by one day.\n#     For example, on the 2nd of July, this will show the patients who had their surgery cancelled on 1st July or were discharged on 1st July.\n#     These steps are included to make it easier to understand the destinations of different clients, but due to the size of the simulation step shown (1 day) it is difficult to demonstrate this differently.\n#     \"\"\"\n# )\n\n\ncounts_not_avail = full_patient_df_plus_pos[full_patient_df_plus_pos['event']=='no_bed_available'][['snapshot_time','patient']].groupby('snapshot_time').agg('count')\ncounts_not_avail = counts_not_avail.reset_index().merge(full_patient_df_plus_pos[['snapshot_time']].drop_duplicates(), how='right').sort_values('snapshot_time')\ncounts_not_avail['patient'] = counts_not_avail['patient'].fillna(0)\ncounts_not_avail['running_total'] = counts_not_avail['patient'].cumsum()\n\ncounts_not_avail = counts_not_avail.reset_index(drop=True)\n\ncounts_not_avail\n\n\n\n\n\n\n\n\nsnapshot_time\npatient\nrunning_total\n\n\n\n\n0\n0\n0.0\n0.0\n\n\n1\n1\n0.0\n0.0\n\n\n2\n2\n0.0\n0.0\n\n\n3\n3\n8.0\n8.0\n\n\n4\n4\n12.0\n20.0\n\n\n...\n...\n...\n...\n\n\n56\n56\n0.0\n305.0\n\n\n57\n57\n0.0\n305.0\n\n\n58\n58\n8.0\n313.0\n\n\n59\n59\n12.0\n325.0\n\n\n60\n60\n10.0\n335.0\n\n\n\n\n61 rows × 3 columns\n\n\n\n\n\ncounts_ops_completed = full_patient_df_plus_pos[full_patient_df_plus_pos['event']=='post_surgery_stay_begins'][['snapshot_time','patient']].drop_duplicates('patient').groupby('snapshot_time').agg('count')\ncounts_ops_completed = counts_ops_completed.reset_index().merge(full_patient_df_plus_pos[['snapshot_time']].drop_duplicates(), how='right').sort_values('snapshot_time')\ncounts_ops_completed['patient'] = counts_ops_completed['patient'].fillna(0)\ncounts_ops_completed['running_total'] = counts_ops_completed['patient'].cumsum()\n\ncounts_ops_completed = counts_ops_completed.reset_index(drop=True)\n\ncounts_ops_completed\n\n\n\n\n\n\n\n\nsnapshot_time\npatient\nrunning_total\n\n\n\n\n0\n0\n15.0\n15.0\n\n\n1\n1\n17.0\n32.0\n\n\n2\n2\n5.0\n37.0\n\n\n3\n3\n3.0\n40.0\n\n\n4\n4\n5.0\n45.0\n\n\n...\n...\n...\n...\n\n\n56\n56\n12.0\n359.0\n\n\n57\n57\n4.0\n363.0\n\n\n58\n58\n6.0\n369.0\n\n\n59\n59\n4.0\n373.0\n\n\n60\n60\n7.0\n380.0\n\n\n\n\n61 rows × 3 columns\n\n\n\n\ncounts_not_avail = counts_not_avail.merge(counts_ops_completed.rename(columns={'running_total':'completed'}), how=\"left\", on=\"snapshot_time\")\ncounts_not_avail['perc_slots_lost'] = counts_not_avail['running_total'] / (counts_not_avail['running_total'] + counts_not_avail['completed'])\n\ncounts_not_avail = counts_not_avail.reset_index(drop=True)\n\ncounts_not_avail\n\n\n\n\n\n\n\n\nsnapshot_time\npatient_x\nrunning_total\npatient_y\ncompleted\nperc_slots_lost\n\n\n\n\n0\n0\n0.0\n0.0\n15.0\n15.0\n0.000000\n\n\n1\n1\n0.0\n0.0\n17.0\n32.0\n0.000000\n\n\n2\n2\n0.0\n0.0\n5.0\n37.0\n0.000000\n\n\n3\n3\n8.0\n8.0\n3.0\n40.0\n0.166667\n\n\n4\n4\n12.0\n20.0\n5.0\n45.0\n0.307692\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n56\n56\n0.0\n305.0\n12.0\n359.0\n0.459337\n\n\n57\n57\n0.0\n305.0\n4.0\n363.0\n0.456587\n\n\n58\n58\n8.0\n313.0\n6.0\n369.0\n0.458944\n\n\n59\n59\n12.0\n325.0\n4.0\n373.0\n0.465616\n\n\n60\n60\n10.0\n335.0\n7.0\n380.0\n0.468531\n\n\n\n\n61 rows × 6 columns\n\n\n\n\nfig = generate_animation(\n        full_entity_df_plus_pos=full_patient_df_plus_pos,\n        entity_col_name=\"patient\",\n        event_position_df=event_position_df,\n        scenario=args,\n        plotly_height=750,\n        plotly_width=1000,\n        override_x_max=1000,\n        override_y_max=700,\n        entity_icon_size=11,\n        resource_icon_size=13,\n        text_size=14,\n        wrap_resources_at=40,\n        gap_between_resources=20,\n        include_play_button=True,\n        add_background_image=None,\n        # we want the stage labels, but due to a bug\n        # when we add in additional animated traces later,\n        # they will disappear - so better to leave them out here\n        # and then re-add them manually\n        display_stage_labels=True,\n        custom_resource_icon=\"🛏️\",\n        time_display_units=\"d\",\n        simulation_time_unit=\"days\",\n        start_date=\"2022-06-27\",\n        setup_mode=False,\n        frame_duration=1500, #milliseconds\n        frame_transition_duration=1000, #milliseconds\n        debug_mode=False\n    )\n\nfig\n\n        \n        \n        \n\n\n                                                    \n\n\n\n# Set up the desired subplot layout\nROWS = 4\n\nsp = make_subplots(\n    rows=ROWS,\n    cols=1,\n    row_heights=[0.75, 0.05, 0.05, 0.15],\n    vertical_spacing=0.05,\n    subplot_titles=(\n        \"\", # Original Animation\n        \"\", # Completed Operations\n        \"\", # Lost Slot Cumulative Counts\n        \"\" # Daily Lost Slots Plot\n        )\n    )\n\n# Overwrite the domain of our original x and y axis with domain from the new axis\nfig.layout['xaxis']['domain'] = sp.layout['xaxis']['domain']\nfig.layout['yaxis']['domain'] = sp.layout['yaxis']['domain']\n\nfor i in range(2, ROWS+1):\n\n    # Add in the attributes for the secondary axis from our subplot\n    fig.layout[f'xaxis{i}'] = sp.layout[f'xaxis{i}']\n    fig.layout[f'yaxis{i}'] = sp.layout[f'yaxis{i}']\n\n# Final key step - copy over the _grid_ref attribute\n# This isn't meant to be something we modify but it's an essential\n# part of the subplot code because otherwise plotly doesn't truly know\n# how the different subplots are arranged and referenced\nfig._grid_ref = sp._grid_ref\n\nfig.update_layout(\n    xaxis2=dict(\n        showgrid=False,\n        zeroline=False,\n        showline=False,\n        showticklabels=False,\n    ),\n    yaxis2=dict(\n        showgrid=False,\n        zeroline=False,\n        showline=False,\n        showticklabels=False,\n    ),\n    xaxis3=dict(\n        showgrid=False,\n        zeroline=False,\n        showline=False,\n        showticklabels=False,\n    ),\n    yaxis3=dict(\n        showgrid=False,\n        zeroline=False,\n        showline=False,\n        showticklabels=False,\n    ),\n    xaxis4=dict(\n        showticklabels=False\n    )\n)\n\n                                                    \n\n\n\nprint(len(fig.data))\n\n3\n\n\n\n#####################################################\n# Adding additional animation traces\n#####################################################\n\n#####################################################\n# Initialize static and animated traces\n#####################################################\n\n## First, add each trace so it will show up initially\n\n# Plotly requires that all traces that will appear in animation frames are first\n# defined in `fig.data`. Otherwise, they appear to \"fly in\" from undefined positions,\n# or exhibit flickering due to missing interpolation references.\n\n# We add each trace in order, with placeholder data and correct styling,\n# so the animation engine has full knowledge of the traces from the outset.\n\n# Due to issues detailed in the following SO threads, it's essential to initialize the traces\n# outside of the frames argument else they will not show up at all (or show up intermittently)\n# https://stackoverflow.com/questions/69867334/multiple-traces-per-animation-frame-in-plotly\n# https://stackoverflow.com/questions/69367344/plotly-animating-a-variable-number-of-traces-in-each-frame-in-r\n# TODO: More explanation and investigation needed of why sometimes traces do and don't show up after being added in\n# via this method. Behaviour seems very inconsistent and not always logical (e.g. order you put traces in to the later\n# loop sometimes seems to make a difference but sometimes doesn't; making initial trace transparent sometimes seems to\n# stop it showing up when added in the frames but not always; sometimes the initial trace doesn't disappear).\n\n# First, extract the trace containing the resource icons\nposition_label_trace = fig.data[1]\nicon_trace = fig.data[2]\n\n# Now keep our figure data as just the initial trace.\nfig.data = (fig.data[0],)\n\n# 1. BED ICONS TRACE\n# Readd the bed icons trace in a consistent manner\n# Confusingly, when we start messing with the naimation frames, we lose the bed/resource icon trace\n# even though it appeared fine until this point - so we have to handle it here\nfig.add_trace(icon_trace)\n\nprint(f\"Length after adding bed trace: {len(fig.data)}\")\n\n# 2. EVENT LABELS (static position text, but added dynamically per frame to avoid disappearing)\n# This is a similar thing to the fig labels - except we never added them in the first place!\n# Add trace for the event labels (as these get lost from the animation once we start trying to add other things in,\n# so need manually re-adding)\n# fig.add_trace(go.Scatter(\n#         x=[pos+10 for pos in event_position_df['x'].to_list()],\n#         y=event_position_df['y'].to_list(),\n#         mode=\"text\",\n#         name=\"\",\n#         text=event_position_df['label'].to_list(),\n#         textposition=\"middle right\",\n#         hoverinfo='none'\n#     ))\n\nfig.add_trace(position_label_trace)\n\n# Finally, match the font size for the position labels\nfig.data[-1].textfont.size\n\nprint(f\"Length after adding 'position labels:' trace: {len(fig.data)}\")\n\n# 3. OPERATIONS COMPLETED TEXT (animated text annotation)\n# Add animated text trace that gives running total of operations completed\nfig.add_trace(go.Scatter(\n                x=[5],\n                y=[10],\n                # text=\"\",\n                text=f\"Operations Completed: {int(counts_ops_completed['running_total'][0])}\",\n                mode='text',\n                textposition=\"middle left\",\n                textfont=dict(size=20),\n                # opacity=0,\n                showlegend=False,\n                xaxis=\"x2\",\n                yaxis=\"y2\"\n        ), row=2, col=1)\n\nprint(f\"Length after adding 'operations completed:' trace: {len(fig.data)}\")\n\n# 4. SLOTS LOST TEXT (animated text annotation)\n# Add animated trace giving running total of slots lost and percentage of total slots this represents\nfig.add_trace(go.Scatter(\n    x=[5],\n    y=[10],\n    # text=\"\",\n    text=f\"Total slots lost: {int(counts_not_avail['running_total'][0])} ({counts_not_avail['perc_slots_lost'][0]:.1%})\",\n    mode='text',\n    textfont=dict(size=20),\n    # opacity=0,\n    showlegend=False,\n    textposition=\"middle left\",\n    xaxis=\"x3\",\n    yaxis=\"y3\"\n), row=3, col=1)\n\nprint(f\"Length after adding 'slots lost:' trace: {len(fig.data)}\")\n\n\n# # 5. LINE PLOT ON SECONDARY AXIS (animated line in subplot)\n# Initialize with a single point and assign it to subplot axes (x2/y2)\nfig.add_trace(go.Scatter(\n    x=[counts_not_avail['snapshot_time'].iloc[0]],\n    y=[counts_not_avail['patient_x'].iloc[0]],\n    mode=\"lines\",\n    line=dict(color=\"rgba(255,0,0,1)\"),  # semi-transparent initial\n    showlegend=False,\n    name=\"slots_lost_line\",\n    xaxis=\"x4\",\n    yaxis=\"y4\"\n    # We place it in our new subplot using the following line\n), row=4, col=1)\n\n\n# Add an initial trace to our secondary line chart\nfig.add_trace(go.Scatter(\n    x=counts_not_avail['snapshot_time'],\n    y=counts_not_avail['patient_x'],\n    mode='lines',\n    showlegend=False,\n    # name='line',\n    opacity=0.2,\n    xaxis=\"x4\",\n    yaxis=\"y4\"\n    # We place it in our new subplot using the following line\n), row=4, col=1)\n\nprint(f\"Length after adding additional line plot trace: {len(fig.data)}\")\n\nLength after adding bed trace: 2\nLength after adding 'position labels:' trace: 3\nLength after adding 'operations completed:' trace: 4\nLength after adding 'slots lost:' trace: 5\nLength after adding additional line plot trace: 7\n\n\n\n\n##########################################################\n# Define animation frames: one per simulation time step\n##########################################################\n\n##########################################################\n# Now we need to add our traces to each individual frame\n##########################################################\n# IMPORTANT: To work correctly, these need to be provided in the same order as the traces above\n\n# This includes:\n# 0: bed icons\n# 1: event labels\n# 2: operations completed text\n# 3: slots lost text\n# 4: time series line in subplot\n\n# # Now ensure we tell it which traces we are animating\n# # (as per https://chart-studio.plotly.com/~empet/15243/animating-traces-in-subplotsbr/#/)\nfor i, frame in enumerate(fig.frames):\n    # Your original frame.data\n    # This will be a tuple\n    # We'll ensure we only take the first entry\n    # original_data = (frame.data[0], )\n\n    original_data = frame.data\n\n    # if i == 5:\n    #     print(original_data)\n\n    # The new data you want to add for this specific frame\n    new_data = (\n        # 0: bed icons\n        icon_trace,\n\n        # 1: Position labels\n        go.Scatter(\n            x=[pos+10 for pos in event_position_df['x'].to_list()],\n            y=event_position_df['y'].to_list(),\n            mode=\"text\",\n            text=event_position_df['label'].to_list(),\n            textposition=\"middle right\",\n            hoverinfo='none',\n            showlegend=False,\n        ),\n\n        # 2: Slots used/operations occurred\n        go.Scatter(\n            x=[5],\n            y=[10],\n            text=f\"Operations Completed: {int(counts_ops_completed.sort_values('snapshot_time')['running_total'][i])}\",\n            mode='text',\n            textposition=\"middle left\",\n            textfont=dict(size=20),\n            showlegend=False,\n            xaxis='x2',\n            yaxis='y2'\n        ),\n\n        # 3: Slots lost\n        go.Scatter(\n            x=[5],\n            y=[10],\n            text=f\"Total slots lost: {int(counts_not_avail.sort_values('snapshot_time')['running_total'][i])} ({counts_not_avail.sort_values('snapshot_time')['perc_slots_lost'][i]:.1%})\",\n            mode='text',\n            textfont=dict(size=20),\n            textposition=\"middle left\",\n            showlegend=False,\n            xaxis='x3',\n            yaxis='y3'\n        ),\n\n        # 4: Line subplot\n        go.Scatter(\n            x=counts_not_avail.sort_values('snapshot_time')['snapshot_time'][0: i+1].values,\n            y=counts_not_avail.sort_values('snapshot_time')['patient_x'][0: i+1].values,\n            mode=\"lines\",\n            showlegend=False,\n            name=\"line_subplot\",\n            line=dict(color=\"rgba(255,0,0,1)\"),  # semi-transparent initial\n            xaxis='x4',\n            yaxis='y4'\n        ),\n    )\n\n    # print(f\"Type of new data: {type(new_data)}\")\n\n    # Combine the original frame data with your new data\n    frame.data = original_data + new_data\n\n    # if i == 5:\n    #     print(frame.data)\n\n    # print(f\"Type of final frame data: {type(frame.data)}\")\n\n# Finally, match the font size for the position labels\nfig.data[2].textfont.size\n\nfig\n\n                                                    \n\n\n\n# After modifying the data in all frames, now correctly set the 'traces' property.\n\n# Get the total number of animated traces from the first (now updated) frame.\nnum_total_traces = len(fig.frames[0].data)\n\n# Create the list of indices that all traces will be mapped to.\n# This should be [0, 1, 2, ..., n-1] where n is the total number of animated traces.\ntrace_indices = list(range(num_total_traces))\n\n# Apply this correct list of indices to every frame.\nfor frame in fig.frames:\n    frame.traces = trace_indices\n\n\nfig",
    "crumbs": [
      "SimPy Examples",
      "Additional Synchronised Traces - Orthopaedic Ward - Hospital Efficiency Project"
    ]
  },
  {
    "objectID": "examples/example_11_resourceless_animation/ex_11_resourceless.html",
    "href": "examples/example_11_resourceless_animation/ex_11_resourceless.html",
    "title": "Mental Health - Appointment Booking Model",
    "section": "",
    "text": "Sometimes you may want to display models without having a clear concept of a ‘resource’ that you track.\nIn this case, vidigi can cope perfectly fine with just having ‘queue’ steps implemented.\nIn this instance, this model looks at a simple mental health pathway. Here, we are only concerned with the booking of an initial appointment. Each clinician has a certain number of slots available per day, but the number of available slots varies significantly across the course of the week for each individual clinician. Changing the available resources over the course of a simulation is not currently supported - though you could demonstrate resources being ‘unavailable’ by blocking them for a certain duration with an icon indicating unavailability. In this case, where the focus is on the buildup of queues,\nThis example also shows the automatic generation of the appropriate number of event positioning entries, which would support the use of the animation in a front-end where the number of clinicains could be varied.\nBy default, the model uses an appointment book with some slots held back for high-priority patients. Each patient in the default scenario can only go to their ‘home’/most local clinic.\nHowever, it is possible to switch to other scenarios - a ‘pooling’ system where patients can choose between one of several linked clinics in their local area (with the assumption that they will choose the clinic of the group with the soonest available appointment) - the pooling system described above, but with no slots held back for high-priority patients (i.e. no ‘carve-out’)\nimport pandas as pd\nimport math\nfrom examples.example_11_resourceless_animation.model_classes import Scenario, generate_seed_vector\nfrom examples.example_11_resourceless_animation.simulation_execution_functions import single_run\nfrom vidigi.prep import reshape_for_animations, generate_animation_df\nfrom vidigi.animation import generate_animation\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\nshifts = pd.read_csv(\"data/shifts.csv\")\n# if scenario_choice == \"As-is\" or scenario_choice == \"With Pooling\":\n# prop_carve_out = [0.0, 0.9, 0.15, 0.01]\nprop_carve_out = 0.15\n\n#depending on settings and CPU this model takes around 15-20 seconds to run\nRESULTS_COLLECTION = 90 * 1\n\n# We use a warm-up period\n# because the model starts up empty which doesn't reflect reality\nWARM_UP = 60 * 1\nRUN_LENGTH = RESULTS_COLLECTION + WARM_UP\n\n# Set up the scenario for the model to run.\nscenarios = {}\n\nscenarios['as-is'] = Scenario(\n    RUN_LENGTH,\n    WARM_UP,\n    prop_carve_out=prop_carve_out,\n    seeds=generate_seed_vector(),\n    slots_file=shifts\n    )\n\nscenarios['pooled'] = Scenario(\n    RUN_LENGTH,\n    WARM_UP,\n    prop_carve_out=prop_carve_out,\n    pooling=True,\n    seeds=generate_seed_vector(),\n    slots_file=shifts\n    )\n\nscenarios['no_carve_out'] = Scenario(\n    RUN_LENGTH,\n    WARM_UP,\n    pooling=True,\n    prop_carve_out=0.0,\n    seeds=generate_seed_vector(),\n    slots_file=shifts\n    )\n\nclinic_lkup_df = pd.DataFrame([\n    {'clinic': 0, 'icon': \"🟠\"},\n    {'clinic': 1, 'icon': \"🟡\"},\n    {'clinic': 2, 'icon': \"🟢\"},\n    {'clinic': 3, 'icon': \"🔵\"},\n    {'clinic': 4, 'icon': \"🟣\"},\n    {'clinic': 5, 'icon': \"🟤\"},\n    {'clinic': 6, 'icon': \"⚫\"},\n    {'clinic': 7, 'icon': \"⚪\"},\n    {'clinic': 8, 'icon': \"🔶\"},\n    {'clinic': 9, 'icon': \"🔷\"},\n    {'clinic': 10, 'icon': \"🟩\"}\n])\n\n\ndef show_home_clinic(row):\n        if \"more\" not in row[\"icon\"]:\n            if row[\"home_clinic\"] == 0:\n                return \"🟠\"\n            if row[\"home_clinic\"] == 1:\n                return \"🟡\"\n            if row[\"home_clinic\"] == 2:\n                return \"🟢\"\n            if row[\"home_clinic\"] == 3:\n                return \"🔵\"\n            if row[\"home_clinic\"] == 4:\n                return \"🟣\"\n            if row[\"home_clinic\"] == 5:\n                return \"🟤\"\n            if row[\"home_clinic\"] == 6:\n                return \"⚫\"\n            if row[\"home_clinic\"] == 7:\n                return \"⚪\"\n            if row[\"home_clinic\"] == 8:\n                return \"🔶\"\n            if row[\"home_clinic\"] == 9:\n                return \"🔷\"\n            if row[\"home_clinic\"] == 10:\n                return \"🟩\"\n            else:\n                return row[\"icon\"]\n        else:\n            return row[\"icon\"]\n\ndef show_priority_icon(row):\n    if \"more\" not in row[\"icon\"]:\n        if row[\"pathway\"] == 2:\n            return \"🚨\"\n        else:\n            return row[\"icon\"]\n    else:\n        return row[\"icon\"]\n\ndef add_los_to_icon(row):\n    if row[\"event_original\"] == \"have_appointment\":\n        return f'{row[\"icon\"]}&lt;br&gt;{int(row[\"wait\"])}'\n    else:\n        return row[\"icon\"]\ndef generate_scenario_results(scenario):\n    results_all, results_low, results_high, event_log = single_run(scenarios[scenario])\n    event_log_df = pd.DataFrame(event_log)\n    event_log_df['event_original'] = event_log_df['event']\n    event_log_df['event'] = event_log_df.apply(lambda x: f\"{x['event']}{f'_{int(x.booked_clinic)}' if pd.notna(x['booked_clinic']) else ''}\", axis=1)\n    event_log.to_csv(f\"{scenario}.csv\")\n\n    full_patient_df = reshape_for_animations(\n        event_log_df,\n        entity_col_name=\"patient\",\n        limit_duration=WARM_UP+180,\n        every_x_time_units=1,\n        step_snapshot_max=50,\n        )\n\n    # Remove the warm-up period from the event log\n    full_patient_df = full_patient_df[full_patient_df[\"snapshot_time\"] &gt;= WARM_UP]\n\n    clinics =  [x for x in event_log_df['booked_clinic'].sort_values().unique().tolist() if not math.isnan(x)]\n\n    clinic_waits = [{'event': f'appointment_booked_waiting_{int(clinic)}',\n        'y':  950-(clinic+1)*80,\n        'x': 625,\n        'label': f\"Booked into&lt;br&gt;clinic {int(clinic)}\",\n        'clinic': int(clinic)}\n        for clinic in clinics]\n\n    clinic_attends = [{'event': f'have_appointment_{int(clinic)}',\n        'y':  950-(clinic+1)*80,\n        'x': 850,\n        'label': f\"Attending appointment&lt;br&gt;at clinic {int(clinic)}\"}\n        for clinic in clinics]\n\n    event_position_df = pd.concat([pd.DataFrame(clinic_waits),(pd.DataFrame(clinic_attends))])\n\n    referred_out = [{'event': f'referred_out_{int(clinic)}',\n        'y':  950-(clinic+1)*80,\n        'x': 125,\n        'label': f\"Referred Out From &lt;br&gt;clinic {int(clinic)}\"}\n        for clinic in clinics]\n\n    event_position_df = pd.concat([event_position_df,(pd.DataFrame(referred_out))])\n\n    if scenario == \"pooled\" or \"no_carve_out\":\n        event_position_df = event_position_df.merge(clinic_lkup_df, how=\"left\")\n        event_position_df[\"label\"] = event_position_df.apply(\n            lambda x: f\"{x['label']} {x['icon']}\" if pd.notna(x['icon']) else x['label'],\n            axis=1\n            )\n        event_position_df = event_position_df.drop(columns=\"icon\")\n\n    event_position_df.drop(columns=\"clinic\")\n\n    full_patient_df_plus_pos = generate_animation_df(\n                    full_entity_df=full_patient_df,\n                    entity_col_name=\"patient\",\n                    event_position_df=event_position_df,\n                    wrap_queues_at=25,\n                    step_snapshot_max=50,\n                    gap_between_entities=15,\n                    gap_between_queue_rows=15,\n                    debug_mode=True\n            )\n\n    return full_patient_df, full_patient_df_plus_pos, event_position_df",
    "crumbs": [
      "SimPy Examples",
      "Mental Health - Appointment Booking Model"
    ]
  },
  {
    "objectID": "examples/example_11_resourceless_animation/ex_11_resourceless.html#scenario-1---as-is",
    "href": "examples/example_11_resourceless_animation/ex_11_resourceless.html#scenario-1---as-is",
    "title": "Mental Health - Appointment Booking Model",
    "section": "Scenario 1 - As-is",
    "text": "Scenario 1 - As-is\n\nfull_patient_df, full_patient_df_plus_pos, event_position_df = generate_scenario_results(\n    'as-is'\n    )\n\nPlacement dataframe finished construction at 12:09:23\n\n\n\ndef generate_clinic_animation(final_df):\n    fig = generate_animation(\n        full_entity_df_plus_pos=final_df,\n        event_position_df=event_position_df,\n        scenario=None,\n        entity_col_name=\"patient\",\n        plotly_height=800,\n        plotly_width=1000,\n        override_x_max=1000,\n        override_y_max=1000,\n        entity_icon_size=10,\n        text_size=10,\n        include_play_button=True,\n        add_background_image=None,\n        display_stage_labels=True,\n        time_display_units=\"d\",\n        simulation_time_unit=\"days\",\n        start_date=\"2022-06-27\",\n        setup_mode=False,\n        frame_duration=1500, #milliseconds\n        frame_transition_duration=1000, #milliseconds\n        debug_mode=False\n    )\n\n    return fig\n\n    #TODO\n    # Add in additional trace that shows the number of available slots per day\n    # using the slot df\n\n    #TODO\n    # Pooled booking version where being in non-home clinic makes you one colour\n    # and home clinic makes you another\n\n    #TODO\n    # Investigate adding a priority attribute to event log\n    # that can be considered when ranking queues if present\n\n\ngenerate_clinic_animation(full_patient_df_plus_pos).show()",
    "crumbs": [
      "SimPy Examples",
      "Mental Health - Appointment Booking Model"
    ]
  },
  {
    "objectID": "examples/example_11_resourceless_animation/ex_11_resourceless.html#with-pooling",
    "href": "examples/example_11_resourceless_animation/ex_11_resourceless.html#with-pooling",
    "title": "Mental Health - Appointment Booking Model",
    "section": "With Pooling",
    "text": "With Pooling\n\nfull_patient_df, full_patient_df_plus_pos, event_position_df = generate_scenario_results('pooled')\n\nPlacement dataframe finished construction at 12:09:33\n\n\n\nfull_patient_df_plus_pos = full_patient_df_plus_pos.assign(\n    icon=full_patient_df_plus_pos.apply(show_home_clinic, axis=1)\n    )\n\nfull_patient_df_plus_pos = full_patient_df_plus_pos.assign(\n    icon=full_patient_df_plus_pos.apply(show_priority_icon, axis=1)\n    )\n\nfull_patient_df_plus_pos = full_patient_df_plus_pos.assign(\n    icon=full_patient_df_plus_pos.apply(add_los_to_icon, axis=1)\n    )\n\n\ngenerate_clinic_animation(full_patient_df_plus_pos).show()",
    "crumbs": [
      "SimPy Examples",
      "Mental Health - Appointment Booking Model"
    ]
  },
  {
    "objectID": "examples/example_11_resourceless_animation/ex_11_resourceless.html#with-pooling---no-carve-out",
    "href": "examples/example_11_resourceless_animation/ex_11_resourceless.html#with-pooling---no-carve-out",
    "title": "Mental Health - Appointment Booking Model",
    "section": "With Pooling - No Carve-out",
    "text": "With Pooling - No Carve-out\n\nfull_patient_df, full_patient_df_plus_pos, event_position_df = generate_scenario_results('no_carve_out')\n\nPlacement dataframe finished construction at 12:09:46\n\n\n\nfull_patient_df_plus_pos = full_patient_df_plus_pos.assign(\n    icon=full_patient_df_plus_pos.apply(show_home_clinic, axis=1)\n    )\n\nfull_patient_df_plus_pos = full_patient_df_plus_pos.assign(\n    icon=full_patient_df_plus_pos.apply(show_priority_icon, axis=1)\n    )\n\nfull_patient_df_plus_pos = full_patient_df_plus_pos.assign(\n    icon=full_patient_df_plus_pos.apply(add_los_to_icon, axis=1)\n    )\n\n\ngenerate_clinic_animation(full_patient_df_plus_pos).show()",
    "crumbs": [
      "SimPy Examples",
      "Mental Health - Appointment Booking Model"
    ]
  },
  {
    "objectID": "examples/example_10_advanced_ciw/ex_10_ciw.html",
    "href": "examples/example_10_advanced_ciw/ex_10_ciw.html",
    "title": "A More Complex Ciw Example with Backgrounds",
    "section": "",
    "text": "import pandas as pd\n# Import the wrapper objects for model interaction.\nfrom examples.example_10_advanced_ciw.ex_10_ciw_model import N\nfrom vidigi.ciw import event_log_from_ciw_recs\nfrom vidigi.utils import EventPosition, create_event_position_df\nfrom vidigi.animation import animate_activity_log\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\nimport os\nimport ciw\n\n\n\n\n\n\n\nView Imported Code for the ciw model\n\n\n\n\n\nimport ciw\n\n# From https://ciw.readthedocs.io/en/latest/Tutorial/tutorial_ii.html\n\nN = ciw.create_network(\n\n    arrival_distributions=[ciw.dists.Exponential(rate=0.3 / 60),\n\n                           ciw.dists.Exponential(rate=0.2 / 60),\n\n                           None],\n\n    service_distributions=[ciw.dists.Exponential(rate=2.0 / 60),\n\n                           ciw.dists.Exponential(rate=1.4 / 60),\n\n                           ciw.dists.Exponential(rate=1.0 / 60)],\n\n    routing=[[0.0, 0.3, 0.7],\n\n             [0.0, 0.0, 1.0],\n\n             [0.0, 0.0, 0.0]],\n\n    number_of_servers=[1, 2, 2]\n\n)\n\n\n\n\nciw.seed(42)\n\nQ = ciw.Simulation(N)\n\nRESULTS_COLLECTION_PERIOD = 180 * 60 # 180 minutes x 60 seconds\n\nQ.simulate_until_max_time(RESULTS_COLLECTION_PERIOD)\n\nrecs = Q.get_all_records()\n\npd.DataFrame(recs).sort_values(['id_number', 'service_start_date']).head(20)\n\n\n\n\n\n\n\n\nid_number\ncustomer_class\noriginal_customer_class\nnode\narrival_date\nwaiting_time\nservice_start_date\nservice_time\nservice_end_date\ntime_blocked\nexit_date\ndestination\nqueue_size_at_arrival\nqueue_size_at_departure\nserver_id\nrecord_type\n\n\n\n\n0\n1\nCustomer\nCustomer\n2\n7.598652\n0.000000\n7.598652\n13.783888\n21.382540\n0.0\n21.382540\n3\n0\n0\n1\nservice\n\n\n1\n1\nCustomer\nCustomer\n3\n21.382540\n0.000000\n21.382540\n67.750381\n89.132921\n0.0\n89.132921\n-1\n0\n0\n1\nservice\n\n\n6\n2\nCustomer\nCustomer\n2\n83.374507\n0.000000\n83.374507\n95.455204\n178.829712\n0.0\n178.829712\n3\n0\n0\n1\nservice\n\n\n7\n2\nCustomer\nCustomer\n3\n178.829712\n0.000000\n178.829712\n53.388522\n232.218234\n0.0\n232.218234\n-1\n1\n1\n1\nservice\n\n\n2\n3\nCustomer\nCustomer\n2\n110.660229\n0.000000\n110.660229\n23.487693\n134.147921\n0.0\n134.147921\n3\n1\n2\n2\nservice\n\n\n3\n3\nCustomer\nCustomer\n3\n134.147921\n0.000000\n134.147921\n13.301500\n147.449421\n0.0\n147.449421\n-1\n0\n1\n1\nservice\n\n\n4\n4\nCustomer\nCustomer\n2\n119.735282\n14.412639\n134.147921\n1.152617\n135.300539\n0.0\n135.300539\n3\n2\n1\n2\nservice\n\n\n5\n4\nCustomer\nCustomer\n3\n135.300539\n0.000000\n135.300539\n47.239755\n182.540294\n0.0\n182.540294\n-1\n1\n1\n2\nservice\n\n\n16\n5\nCustomer\nCustomer\n2\n193.750291\n0.000000\n193.750291\n71.045918\n264.796209\n0.0\n264.796209\n3\n0\n1\n1\nservice\n\n\n17\n5\nCustomer\nCustomer\n3\n264.796209\n0.000000\n264.796209\n216.972911\n481.769120\n0.0\n481.769120\n-1\n1\n0\n2\nservice\n\n\n12\n6\nCustomer\nCustomer\n2\n195.706281\n0.000000\n195.706281\n70.241394\n265.947675\n0.0\n265.947675\n3\n1\n0\n2\nservice\n\n\n13\n6\nCustomer\nCustomer\n3\n265.947675\n30.320583\n296.268259\n48.183165\n344.451423\n0.0\n344.451423\n-1\n2\n2\n1\nservice\n\n\n8\n7\nCustomer\nCustomer\n1\n204.012057\n0.000000\n204.012057\n12.476853\n216.488910\n0.0\n216.488910\n3\n0\n0\n1\nservice\n\n\n9\n7\nCustomer\nCustomer\n3\n216.488910\n0.000000\n216.488910\n24.622136\n241.111046\n0.0\n241.111046\n-1\n1\n1\n2\nservice\n\n\n10\n8\nCustomer\nCustomer\n1\n237.809311\n0.000000\n237.809311\n2.919980\n240.729291\n0.0\n240.729291\n3\n0\n0\n1\nservice\n\n\n11\n8\nCustomer\nCustomer\n3\n240.729291\n0.000000\n240.729291\n55.538968\n296.268259\n0.0\n296.268259\n-1\n1\n2\n1\nservice\n\n\n14\n9\nCustomer\nCustomer\n1\n258.153048\n0.000000\n258.153048\n49.371898\n307.524946\n0.0\n307.524946\n3\n0\n0\n1\nservice\n\n\n15\n9\nCustomer\nCustomer\n3\n307.524946\n36.926477\n344.451423\n57.821772\n402.273196\n0.0\n402.273196\n-1\n2\n1\n1\nservice\n\n\n20\n10\nCustomer\nCustomer\n1\n519.821134\n0.000000\n519.821134\n59.351398\n579.172532\n0.0\n579.172532\n2\n0\n0\n1\nservice\n\n\n21\n10\nCustomer\nCustomer\n2\n579.172532\n1.027521\n580.200053\n4.563164\n584.763217\n0.0\n584.763217\n3\n2\n1\n2\nservice\n\n\n\n\n\n\n\n\nevent_log = event_log_from_ciw_recs(\n    recs,\n    node_name_list=[\"cold_food\", \"hot_food\", \"till\"]\n    )\n\nevent_log[event_log[\"entity_id\"]==13]\n\n\n\n\n\n\n\n\nentity_id\npathway\nevent_type\nevent\ntime\nresource_id\n\n\n\n\n99\n13\nModel\narrival_departure\narrival\n671.604123\nNaN\n\n\n100\n13\nModel\nqueue\nhot_food_wait_begins\n671.604123\nNaN\n\n\n101\n13\nModel\nresource_use\nhot_food_begins\n671.604123\n1.0\n\n\n102\n13\nModel\nresource_use_end\nhot_food_ends\n684.914665\n1.0\n\n\n103\n13\nModel\nqueue\ntill_wait_begins\n684.914665\nNaN\n\n\n104\n13\nModel\nresource_use\ntill_begins\n684.914665\n1.0\n\n\n105\n13\nModel\nresource_use_end\ntill_ends\n741.277635\n1.0\n\n\n106\n13\nModel\narrival_departure\ndepart\n741.277635\nNaN\n\n\n\n\n\n\n\n\n# Create a suitable class to pass in the resource numbers to the animation function\nclass model_params():\n    def __init__(self):\n        self.cold_food_servers = 1\n        self.hot_food_servers = 2\n        self.tills = 2\n\nparams = model_params()\n\n\n# # Create required event_position_df for vidigi animation\n# event_position_df = pd.DataFrame([\n#                     {'event': 'arrival',\n#                      'x':  30, 'y': 550,\n#                      'label': \"Arrival\"},\n\n#                     {'event': 'cold_food_wait_begins',\n#                      'x':  200, 'y': 510,\n#                      'label': \"Waiting for Cold Food\"},\n\n#                     {'event': 'cold_food_begins',\n#                      'x':  210, 'y': 370,\n#                      'resource':'cold_food_servers',\n#                      'label': \"Being Served Cold Food\"},\n\n#                     {'event': 'hot_food_wait_begins',\n#                      'x':  505, 'y': 510,\n#                      'label': \"Waiting for Hot Food\"},\n\n#                     {'event': 'hot_food_begins',\n#                      'x':  505, 'y': 370,\n#                      'resource':'hot_food_servers',\n#                      'label': \"Being Served Hot Food\"},\n\n#                     {'event': 'till_wait_begins',\n#                      'x':  350, 'y': 170,\n#                      'label': \"Waiting for Till\"},\n\n#                     {'event': 'till_begins',\n#                      'x':  350, 'y': 120,\n#                      'resource':'tills',\n#                      'label': \"Being Served at Till\"},\n\n#                     {'event': 'depart',\n#                      'x':  600, 'y': 10,\n#                      'label': \"Exit\"}\n\n#                 ])\n\n# event_position_df\n\nevent_position_df = create_event_position_df( [\n    EventPosition(event='arrival', x=30, y=550, label=\"Arrival\"),\n    EventPosition(event='cold_food_wait_begins', x=200, y=510, label=\"Waiting for Cold Food\"),\n    EventPosition(event='cold_food_begins', x=210, y=370, resource='cold_food_servers', label=\"Being Served Cold Food\"),\n    EventPosition(event='hot_food_wait_begins', x=505, y=510, label=\"Waiting for Hot Food\"),\n    EventPosition(event='hot_food_begins', x=505, y=370, resource='hot_food_servers', label=\"Being Served Hot Food\"),\n    EventPosition(event='till_wait_begins', x=350, y=170, label=\"Waiting for Till\"),\n    EventPosition(event='till_begins', x=350, y=120, resource='tills', label=\"Being Served at Till\"),\n    EventPosition(event='depart', x=600, y=10, label=\"Exit\")\n]\n)\n\n\n# Create animation\nparams = model_params()\n\nanimate_activity_log(\n        event_log=event_log,\n        event_position_df=event_position_df,\n        scenario=model_params(),\n        simulation_time_unit=\"seconds\",\n        time_display_units=\"dhms\",\n        debug_mode=True,\n        setup_mode=False,\n        every_x_time_units=5, # 20 seconds\n        include_play_button=True,\n        entity_icon_size=20,\n        gap_between_entities=15,\n        gap_between_queue_rows=25,\n        gap_between_resources=30,\n        plotly_height=525,\n        frame_duration=200,\n        frame_transition_duration=600,\n        plotly_width=900,\n        override_x_max=700,\n        override_y_max=600,\n        limit_duration=RESULTS_COLLECTION_PERIOD,\n        wrap_queues_at=25,\n        wrap_resources_at=50,\n        step_snapshot_max=75,\n        start_time=\"12:00:00\",\n        text_size=20,\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_10_advanced_ciw/cafe_floorplan.drawio%20(1).png\"\n    )\n\nAnimation function called at 15:19:45\nIteration through time-unit-by-time-unit logs complete 15:19:49\nSnapshot df concatenation complete at 15:19:50\nReshaped animation dataframe finished construction at 15:19:50\nPlacement dataframe finished construction at 15:19:50\nOutput animation generation complete at 15:19:57\nTotal Time Elapsed: 12.62 seconds",
    "crumbs": [
      "Ciw Examples",
      "A More Complex Ciw Example with Backgrounds"
    ]
  },
  {
    "objectID": "examples/example_12_resourceless_with_back_and_forth/ex_12_resourceless_advanced.html",
    "href": "examples/example_12_resourceless_with_back_and_forth/ex_12_resourceless_advanced.html",
    "title": "More Resourceless Queues - Community Service Repeat Appointment Booking Model with Variable Follow-ups",
    "section": "",
    "text": "import math\n# Packages for data manipulation\nimport numpy as np\nimport pandas as pd\n# Packages for graphing\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n# Model functions\nfrom examples.example_12_resourceless_with_back_and_forth.model_classes import Scenario, generate_seed_vector\nfrom examples.example_12_resourceless_with_back_and_forth.simulation_execution_functions import single_run\n# Animation functions\nfrom vidigi.prep import reshape_for_animations, generate_animation_df\nfrom vidigi.animation import generate_animation\n\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\nThis model is designed to mimic a simple community-based appointment service where clients have an initial appointment and then a variable number of follow-ups over an extended period of time.\nA client can have their first referral with any clinician - in practice, whoever has capacity and the soonest appointment - but all follow-on appointments will be with the same clinician.\nInstead of using simpy resources, an appointment book is set up. The model looks for an appointment that meets criteria, then books this in, reducing the available slots as appropriate. This allows for continuity of care in a way that is more difficult to achieve with a simpy resource, as well as allowing finer control over the number of appointments a clinician can undertake in a day.\nNote that some issues seem to be present with the caseload calculations, leading to some unexpected behaviour within the model over time.\nThe default is to aim to have as many people on caseload as you have maximum theoretical slots. This can be adjusted up or down to see the impact of changing the policy.\nNote that low intensity patients in this model take up 0.5 slots. High intensity patients take up 1 slot.\nnumber_of_clinicians = 8\n\nCASELOAD_TARGET_MULTIPLIER = 1.3\n\n# caseload_default_adjusted = pd.concat(\n#             [shifts.sum(),\n#             np.floor(shifts.sum() * CASELOAD_TARGET_MULTIPLIER)],\n#             axis=1\n#             )\n\n# caseload_default_adjusted.columns = [\"Default Caseload (Total Slots Per Week)\",\n#                                         \"Adjusted Caseload\"]\n\nANNUAL_DEMAND = 700\n\nPROP_HIGH_PRIORITY = 0.03\n\nWARM_UP = 60\n\nRESULTS_COLLECTION = 180\n\nRUN_LENGTH = RESULTS_COLLECTION + WARM_UP\n\nPROP_REFERRED_OUT = 0.12\n\nSEED = 42\n\nPROP_HIGH_PRIORITY_ONGOING_APPOINTMENTS = 0.95\n\nPROP_LOW_PRIORITY_ONGOING_APPOINTMENTS = 0.8\n\n# What proportion of people initially graded as *high*\n# priority go on to have high intensity therapy?\nPROP_HIGH_PRIORITY_HIGH_INTENSITY = 0.7\n# What proportion of people initially graded as *low*\n# priority go on to have high intensity therapy?\nPROP_LOW_PRIORITY_HIGH_INTENSITY = 0.2\n\nMEAN_FOLLOW_UPS_HIGH_INTENSITY = 10\nMEAN_FOLLOW_UPS_LOW_INTENSITY = 6\n\nSD_FOLLOW_UPS_HIGH_INTENSITY = 18\nSD_FOLLOW_UPS_HIGH_INTENSITY = SD_FOLLOW_UPS_HIGH_INTENSITY/3\nSD_FOLLOW_UPS_LOW_INTENSITY = 9\nSD_FOLLOW_UPS_LOW_INTENSITY = SD_FOLLOW_UPS_LOW_INTENSITY/3\n\nscenarios = {}\nWe define the parameters of the clinics in csv files.\nshifts = (pd.read_csv(\"data/shifts.csv\")\n           .iloc[:,:number_of_clinicians])\n\nshifts\n\n\n\n\n\n\n\n\nclinic_1\nclinic_2\nclinic_3\nclinic_4\nclinic_5\nclinic_6\nclinic_7\nclinic_8\n\n\n\n\n0\n0\n5\n4\n4\n0\n5\n3\n3\n\n\n1\n0\n3\n5\n4\n5\n5\n3\n3\n\n\n2\n4\n3\n5\n5\n3\n5\n4\n3\n\n\n3\n4\n5\n2\n1\n5\n5\n3\n3\n\n\n4\n4\n0\n1\n0\n5\n4\n3\n1\n\n\n5\n5\n0\n0\n0\n3\n0\n0\n0\n\n\n6\n0\n5\n0\n3\n0\n0\n0\n0\ncaseload = (pd.read_csv(\"data/caseload.csv\")\n            .iloc[:,:number_of_clinicians+1])\n\ncaseload\n\n\n\n\n\n\n\n\nUnnamed: 0\nclinic_1\nclinic_2\nclinic_3\nclinic_4\nclinic_5\nclinic_6\nclinic_7\nclinic_8\n\n\n\n\n0\ncurrent_caseload\n0\n0\n0\n0\n0\n0\n0\n0\nreferrals = (pd.read_csv(\"data/referrals.csv\")\n                .iloc[:number_of_clinicians])\n\nreferrals\n\n\n\n\n\n\n\n\nclinic\nprop\nreferred_out\ndna\n\n\n\n\n0\n1\n1.0\n0.120\n0.20\n\n\n1\n2\n0.0\n0.428\n0.25\n\n\n2\n3\n0.0\n0.489\n0.25\n\n\n3\n4\n0.0\n0.296\n0.20\n\n\n4\n5\n0.0\n0.275\n0.23\n\n\n5\n6\n0.0\n0.091\n0.21\n\n\n6\n7\n0.0\n0.162\n0.24\n\n\n7\n8\n0.0\n0.129\n0.17\npooling = (pd.read_csv(\"data/partial_pooling.csv\")\n            .iloc[:number_of_clinicians,:number_of_clinicians+1])\n\n\n\nscenarios['pooled'] = Scenario(RUN_LENGTH,\n                                       WARM_UP,\n                                      #  prop_carve_out=prop_carve_out,\n                                       seeds=generate_seed_vector(SEED),\n                                       slots_file=shifts,\n                                       pooling_file=pooling,\n                                       existing_caseload_file=caseload,\n                                       demand_file=referrals,\n                                       caseload_multiplier=CASELOAD_TARGET_MULTIPLIER,\n                                       prop_high_priority=PROP_HIGH_PRIORITY,\n                                       prop_high_priority_ongoing_appointments=PROP_HIGH_PRIORITY_ONGOING_APPOINTMENTS,\n                                       prop_low_priority_ongoing_appointments=PROP_LOW_PRIORITY_ONGOING_APPOINTMENTS,\n                                       prop_high_priority_assessed_high_intensity=PROP_HIGH_PRIORITY_HIGH_INTENSITY,\n                                       prop_low_priority_assessed_high_intensity=PROP_LOW_PRIORITY_HIGH_INTENSITY,\n                                       mean_follow_ups_high_intensity=MEAN_FOLLOW_UPS_HIGH_INTENSITY,\n                                       sd_follow_ups_high_intensity=SD_FOLLOW_UPS_HIGH_INTENSITY,\n                                       mean_follow_ups_low_intensity=MEAN_FOLLOW_UPS_LOW_INTENSITY,\n                                       sd_follow_ups_low_intensity=SD_FOLLOW_UPS_LOW_INTENSITY,\n                                       annual_demand=ANNUAL_DEMAND,\n                                       prop_referred_out=PROP_REFERRED_OUT)\n# Run the model and unpack the outputs\nresults_all, results_low, results_high, event_log, \\\nbookings, available_slots, daily_caseload_snapshots, \\\ndaily_waiting_for_booking_snapshots, \\\ndaily_arrivals = single_run(args = scenarios['pooled'])\nevent_log_df = pd.DataFrame(event_log)\n\nevent_log_df['event_original'] = event_log_df['event']\nevent_log_df['event'] = event_log_df.apply(\n    lambda x: f\"{x['event']}{f'_{int(x.booked_clinic)}'if pd.notna(x['booked_clinic']) and x['event'] != 'waiting_appointment_to_be_scheduled' else ''}\",\n    axis=1\n    )\n\nfull_patient_df = reshape_for_animations(event_log_df,\n                                         entity_col_name=\"patient\",\n                                            limit_duration=WARM_UP+RESULTS_COLLECTION,\n                                            every_x_time_units=1,\n                                            step_snapshot_max=30)\n\n# Remove the warm-up period from the event log\nfull_patient_df = full_patient_df[full_patient_df[\"snapshot_time\"] &gt;= WARM_UP]\nWe will automatically create a reasonable positioning dataframe that reflects the number of available clinicians.\n#####################################################\n# Create the positioning dataframe for the animation\n#####################################################\n\n# Create a list of clinics\nclinics =  [x for x\n            in event_log_df['booked_clinic'].sort_values().unique().tolist()\n            if not math.isnan(x)]\n\n# Create a column of positions for people waiting for their initial appointment with the clinic\nclinic_waits = [{'event': f'appointment_booked_waiting_{int(clinic)}',\n    'y':  950-(clinic+1)*80,\n    'x': 360,\n    'label': f\"Booked for&lt;br&gt;assessment with&lt;br&gt;clinician {int(clinic)}\",\n    'clinic': int(clinic)}\n    for clinic in clinics]\n\n# Create a column of positions for people having an appointment with the clinic\nclinic_attends = [{'event': f'have_appointment_{int(clinic)}',\n    'y':  950-(clinic+1)*80,\n    'x': 625,\n    'label': f\"Attending appointment&lt;br&gt;with clinician {int(clinic)}\"}\n    for clinic in clinics]\n\n# Join these dataframes\nevent_position_df = pd.concat(\n    [pd.DataFrame(clinic_waits),\n        (pd.DataFrame(clinic_attends))\n        ])\n\n# Create a column of positions for people who are put on a waiting list before being given their future\n# appointment\nwait_for_booking = [{\n    'event': 'waiting_appointment_to_be_scheduled',\n    'y':  150,\n    'x': 325,\n    'label': \"Waiting to be&lt;br&gt;scheduled with &lt;br&gt;clinician \"\n    }]\n\nevent_position_df = pd.concat([event_position_df,(pd.DataFrame(wait_for_booking))])\n\n# Create a column of positions for people being referred to another service (triaged as inappropriate\n# for this service after their initial referral and before an appointment is booked)\nreferred_out = [{\n    'event': 'referred_out',\n    'y':  150,\n    'x': 625,\n    'label': \"Referred Out:&lt;br&gt;Unsuitable for Service\"\n    }]\n\nevent_position_df = pd.concat([event_position_df,(pd.DataFrame(referred_out))])\n\n# Create a column of positions for people who have had their initial appointment and are now waiting for a\n# booked follow-up appointment to take place\nfollow_up_waiting = [{\n    'event': f'follow_up_appointment_booked_waiting_{int(clinic)}',\n    'y':  950-(clinic+1)*80,\n    'x': 1000,\n    'label': f\"On books - awaiting &lt;br&gt;next appointment&lt;br&gt;with clinician {int(clinic)}\"\n    } for clinic in clinics]\n\nevent_position_df = pd.concat([event_position_df,(pd.DataFrame(follow_up_waiting))])\n\nevent_position_df = event_position_df.drop(columns=\"clinic\")\nfull_patient_df_plus_pos = generate_animation_df(\n                            full_entity_df=full_patient_df,\n                            entity_col_name=\"patient\",\n                            event_position_df=event_position_df,\n                            wrap_queues_at=15,\n                            step_snapshot_max=30,\n                            gap_between_entities=15,\n                            gap_between_queue_rows=15,\n                            debug_mode=True\n                    )\n\nPlacement dataframe finished construction at 12:15:03\ndef show_priority_icon(row):\n            if \"more\" not in row[\"icon\"]:\n                if row[\"pathway\"] == 2:\n                    return \"🚨\"\n                else:\n                    return f\"{row['icon']}\"\n            else:\n                return row[\"icon\"]\n\ndef add_los_to_icon(row):\n    if row[\"event_original\"] == \"have_appointment\":\n        return f'{row[\"icon\"]}&lt;br&gt;{int(row[\"wait\"])}'\n    else:\n        return row[\"icon\"]\nfull_patient_df_plus_pos = full_patient_df_plus_pos.assign(\n            icon=full_patient_df_plus_pos.apply(show_priority_icon, axis=1)\n            )\n\nfig = generate_animation(\n    full_entity_df_plus_pos=full_patient_df_plus_pos,\n    event_position_df=event_position_df,\n    entity_col_name=\"patient\",\n    scenario=None,\n    plotly_height=900,\n    plotly_width=1000,\n    override_x_max=1200,\n    override_y_max=1000,\n    entity_icon_size=10,\n    text_size=10,\n    include_play_button=True,\n    add_background_image=None,\n    display_stage_labels=True,\n    time_display_units=\"d\",\n    simulation_time_unit=\"days\",\n    start_date=\"2022-06-27\",\n    setup_mode=False,\n    frame_duration=1500, #milliseconds\n    frame_transition_duration=1000, #milliseconds\n    debug_mode=False\n)\n\nfig",
    "crumbs": [
      "SimPy Examples",
      "More Resourceless Queues - Community Service Repeat Appointment Booking Model with Variable Follow-ups"
    ]
  },
  {
    "objectID": "examples/example_12_resourceless_with_back_and_forth/ex_12_resourceless_advanced.html#making-additional-plots-from-the-event-log",
    "href": "examples/example_12_resourceless_with_back_and_forth/ex_12_resourceless_advanced.html#making-additional-plots-from-the-event-log",
    "title": "More Resourceless Queues - Community Service Repeat Appointment Booking Model with Variable Follow-ups",
    "section": "Making additional plots from the event log",
    "text": "Making additional plots from the event log\nWe can also use the event log to make a wide range of additional plots for exploring our model. Here are just a few examples for this particular system.\n\ndaily_position_counts = []\n\nfor day in range(RUN_LENGTH):\n    # First limit to anyone who hasn't left the system yet\n    # Get a list of all people who have departed on or before the day\n    # of interest as we can then remove them from the dataframe\n    # at the next step\n    departed = event_log_df[\n        (event_log_df[\"time\"] &lt;= day) &\n        (event_log_df[\"event\"] == \"depart\")][\"patient\"].tolist()\n    # Filter down to events that have occurred at or before this day\n    upto_now = event_log_df[(event_log_df[\"time\"] &lt;= day)\n                            & (event_log_df[\"event\"] != \"arrival\")\n                            & (~event_log_df[\"patient\"].isin(departed))]\n    # Now take the latest event for each person\n    latest_event_upto_now = upto_now.sort_values(\"time\").groupby(\"patient\").tail(1)\n    for event_type in event_log_df[\"event_original\"].unique():\n        snapshot_count = len(latest_event_upto_now[(latest_event_upto_now[\"event_original\"] == event_type)])\n        daily_position_counts.append(\n            {\"day\": day,\n            \"event\": event_type,\n            \"count\": snapshot_count}\n        )\n\ndaily_position_counts = pd.DataFrame(daily_position_counts)\n\n\nfig_daily_position_counts = px.line(daily_position_counts[(daily_position_counts[\"event\"] == \"waiting_appointment_to_be_scheduled\") |\n                            (daily_position_counts[\"event\"] == \"appointment_booked_waiting\") |\n                            (daily_position_counts[\"event\"] == \"follow_up_appointment_booked_waiting\")  |\n                            (daily_position_counts[\"event\"] == \"have_appointment\")],\n    x=\"day\",\n    y=\"count\",\n    color=\"event\"\n)\nfig_daily_position_counts.update_layout(legend=dict(\n    orientation=\"h\",\n    yanchor=\"bottom\",\n    y=1.02,\n    xanchor=\"right\",\n    x=1\n))\n\nfig_daily_position_counts\n\n                                                    \n\n\n\narrival_depart_df = event_log_df[(event_log_df[\"event\"] == \"arrival\") |\n                                      (event_log_df[\"event\"] == \"depart\")][[\"time\", \"event\"]].value_counts().reset_index(drop=False).sort_values('time')\n\narrival_depart_df_pivot = arrival_depart_df.pivot(index=\"time\", columns=\"event\", values=\"count\")\narrival_depart_df_pivot[\"difference (arrival-depart) - positive is more more arriving than departing\"] = arrival_depart_df_pivot[\"arrival\"] - arrival_depart_df_pivot[\"depart\"]\n\narrival_depart_balance_fig = px.scatter(\n        arrival_depart_df,\n        x=\"time\",\n        y=\"count\",\n        color=\"event\",\n        trendline=\"rolling\",\n        color_discrete_sequence=['#636EFA', '#EF553B'],\n        opacity=0.1,\n        trendline_options=dict(window=100)\n    )\n\narrival_depart_balance_fig\n\n                                                    \n\n\n\nassessment_booking_waits = (event_log_df\n                      .dropna(subset='assessment_booking_wait')\n                      .drop_duplicates(subset='patient')\n                      [['time','pathway', 'assessment_booking_wait']]\n                      )\n\npx.box(\n                      assessment_booking_waits,\n                      y=\"assessment_booking_wait\", x=\"pathway\", color=\"pathway\"\n                          )\n\n                                                    \n\n\n\npx.line(\n                      assessment_booking_waits,\n                      y=\"assessment_booking_wait\", x=\"time\", color=\"pathway\", line_group=\"pathway\"\n                    )\n\n                                                    \n\n\n\npx.box(\n                event_log_df\n                .dropna(subset='wait')\n                .drop_duplicates(subset='patient')[['pathway', 'wait']],\n                y=\"wait\", x=\"pathway\", color=\"pathway\"\n                    )\n\n                                                    \n\n\n\npx.line(\n                      event_log_df\n                      .dropna(subset='wait')\n                      .drop_duplicates(subset='patient')[['time','pathway', 'wait']],\n                      y=\"wait\", x=\"time\", color=\"pathway\", line_group=\"pathway\"\n                    )\n\n                                                    \n\n\n\ninter_appointment_gaps = (event_log_df\n                .dropna(subset='interval')\n                .drop_duplicates('patient')\n                # .query('event_original == \"have_appointment\"')\n                [['time', 'follow_up_intensity','interval']]\n                )\n\n\npx.box(\n                      inter_appointment_gaps,\n                      y=\"interval\", x=\"follow_up_intensity\", color=\"follow_up_intensity\"\n                          )\n\n                                                    \n\n\n\npx.line(\n                      inter_appointment_gaps,\n                      y=\"interval\", x=\"time\", color=\"follow_up_intensity\", line_group=\"follow_up_intensity\"\n                    )\n\n                                                    \n\n\n\nfig_arrivals = go.Figure(make_subplots(rows=1, cols=1))\nfig_arrivals_1 = px.scatter(\n        pd.DataFrame(pd.Series(daily_arrivals).value_counts()).reset_index(drop=False),\n        x=\"index\",\n        y=\"count\",\n        trendline=\"rolling\",\n        opacity=0.4,\n        trendline_options=dict(window=7)#,\n    )\nfig_arrivals_2 = px.scatter(\n        pd.DataFrame(pd.Series(daily_arrivals).value_counts()).reset_index(drop=False),\n        x=\"index\",\n        y=\"count\",\n        trendline=\"rolling\",\n        trendline_options=dict(window=60),\n        color_discrete_sequence=['red']\n    )\nfig_arrivals_2.data = [t for t in fig_arrivals_2.data if t.mode == \"lines\"]\nfig_trace = []\n\nfor trace in range(len(fig_arrivals_1[\"data\"])):\n    fig_trace.append(fig_arrivals_1[\"data\"][trace])\nfor trace in range(len(fig_arrivals_2[\"data\"])):\n    fig_trace.append(fig_arrivals_2[\"data\"][trace])\n\nfor traces in fig_trace:\n    fig_arrivals.append_trace(traces, row=1, col=1)\n\nfig_arrivals\n\n                                                    \n\n\n\npx.bar(\n                event_log_df\n                  .dropna(subset='follow_ups_intended')\n                  .drop_duplicates(subset='patient')[['pathway','follow_ups_intended']]\n                  .value_counts()\n                  .reset_index(drop=False),\n                x=\"follow_ups_intended\", y=\"count\",facet_row=\"pathway\"\n                )\n\n                                                    \n\n\n\npx.bar(\n                event_log_df\n                .dropna(subset='assessment_booking_wait')\n                .drop_duplicates(subset='patient')\n                .groupby('pathway')[['pathway','assessment_booking_wait']]\n                .value_counts()\n                .reset_index(drop=False),\n                x=\"assessment_booking_wait\", y=\"count\", facet_row=\"pathway\"\n                )\n\n                                                    \n\n\n\ncl = pd.DataFrame(daily_caseload_snapshots[\"caseload_day_end\"].tolist())\ncl_filtered = cl.iloc[WARM_UP:RUN_LENGTH,:]\ncl_plotting = cl_filtered.reset_index(drop=False).melt(id_vars=[\"index\"], var_name=\"clinician\", value_name=\"caseload\")\npx.line(\n    cl_plotting,\n    x=\"index\",\n    y= \"caseload\",\n    color=\"clinician\",\n    range_y=[0, max(cl_plotting[\"caseload\"])]\n    )\n\n                                                    \n\n\n\npx.line((cl_filtered.sum(axis=1)/(np.floor(shifts.sum() * CASELOAD_TARGET_MULTIPLIER).sum())).reset_index(),\n        x=\"index\", y=0)\n\n                                                    \n\n\n\npx.bar(\n    daily_position_counts[daily_position_counts[\"event\"] != \"depart\"],\n    x=\"event\",\n    y=\"count\",\n    animation_frame=\"day\",\n    range_y=[0, max(daily_position_counts[\"count\"])]\n)",
    "crumbs": [
      "SimPy Examples",
      "More Resourceless Queues - Community Service Repeat Appointment Booking Model with Variable Follow-ups"
    ]
  },
  {
    "objectID": "examples/example_14_carwash/ATTRIBUTION.html",
    "href": "examples/example_14_carwash/ATTRIBUTION.html",
    "title": "vidigi",
    "section": "",
    "text": "Asphalt road texture by starline, Freepik https://www.freepik.com/free-photo/asphalt-road-texture-dark-gray-color_5247630.htm\nsimpy model (simpy_carwash.py) written by Team SimPy as part of SimPy documentation."
  },
  {
    "objectID": "examples/example_15_gas_station_refuelling/ATTRIBUTION.html",
    "href": "examples/example_15_gas_station_refuelling/ATTRIBUTION.html",
    "title": "vidigi",
    "section": "",
    "text": "Asphalt road texture by starline, Freepik https://www.freepik.com/free-photo/asphalt-road-texture-dark-gray-color_5247630.htm\nsimpy model (simpy_gas_stations.py) written by Team SimPy as part of SimPy documentation."
  },
  {
    "objectID": "examples/example_16_packing_robot/packing_robot.html",
    "href": "examples/example_16_packing_robot/packing_robot.html",
    "title": "Precalculated pathing",
    "section": "",
    "text": "import os\nfrom vidigi.utils import EventPosition, create_event_position_df\nfrom vidigi.prep import reshape_for_animations, generate_animation_df\nfrom vidigi.animation import generate_animation, animate_activity_log\nimport pandas as pd\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\n\n\n\n\n\n\n\nView Imported Code, which has had logging steps added at the appropriate points in the ‘model’ class\n\n\n\n\n\nimport simpy\nimport random\nfrom typing import Tuple\nfrom vidigi.logging import EventLogger\n\n\n# ---------------------------\n# Warehouse Layout (scaled)\n# ---------------------------\n# Coordinates in pixels for animation space\nLAYOUT = {\n    # Packing & maintenance\n    \"packing\": (270, 270),\n    \"maintenance\": (600, 300),\n\n    # 8 pickup points\n    \"pickup_1\": (25, 500),\n    \"pickup_2\": (180, 500),\n    \"pickup_3\": (70, 500),\n    \"pickup_4\": (550, 500),\n    \"pickup_5\": (25, 100),\n    \"pickup_6\": (180, 100),\n    \"pickup_7\": (370, 100),\n    \"pickup_8\": (550, 100),\n}\n\nPICKUP_POINTS = list(name for name in LAYOUT if name.startswith(\"pickup\"))\n\nSPEED = 100.0  # pixels per minute\nPACKING_TIME = 5\nPACKAGES_PER_BATCH = (1, 5)\nOTHER_TASK_TIME = (2, 4)\nOTHER_TASK_PROB = 0.3\nSIM_DURATION = 60*24\n\n\ndef travel_time(pos_a: Tuple[int, int], pos_b: Tuple[int, int]) -&gt; float:\n    \"\"\"Calculate travel time between two coordinates.\"\"\"\n    dist = ((pos_a[0] - pos_b[0]) ** 2 + (pos_a[1] - pos_b[1]) ** 2) ** 0.5\n    return dist / SPEED\n\n\nclass PackingRobot:\n    def __init__(self, env, name, logger):\n        self.env = env\n        self.name = name\n        self.logger = logger\n        self.pos = LAYOUT[\"packing\"]  # start at packing station\n        self.env.process(self.poll_position())\n        self.logger.log_arrival(entity_id=self.name,\n                                x=self.pos[0], y=self.pos[1])\n        self.logger.log_queue(entity_id=self.name, event=\"packing\",\n                               x=self.pos[0], y=self.pos[1])\n\n    def poll_position(self):\n        \"\"\"Logs position every 1 sim time unit, even if idle.\"\"\"\n        while True:\n            self.logger.log_custom_event(entity_id=self.name,\n                                         event_type=\"position_poll\",\n                                         event=\"position\",\n                                         x=self.pos[0], y=self.pos[1])\n            yield self.env.timeout(1)\n\n    def move_to(self, location_name, pathway, outbound=True):\n        \"\"\"Move robot to a location using Manhattan path.\n        outbound=True: horizontal then vertical\n        outbound=False: retrace return path (vertical then horizontal)\n        \"\"\"\n        destination = LAYOUT[location_name]\n        start_x, start_y = self.pos\n        dest_x, dest_y = destination\n\n        if outbound:\n            sequence = [(\"x\", dest_x - start_x), (\"y\", dest_y - start_y)]\n        else:\n            sequence = [(\"y\", dest_y - start_y), (\"x\", dest_x - start_x)]\n\n        for axis, delta in sequence:\n            if delta != 0:\n                travel_time = abs(delta) / SPEED\n                steps = int(travel_time)\n                remaining = travel_time - steps\n                move_per_unit = delta / travel_time\n\n                for _ in range(steps):\n                    yield self.env.timeout(1)\n                    if axis == \"x\":\n                        self.pos = (self.pos[0] + move_per_unit, self.pos[1])\n                    else:\n                        self.pos = (self.pos[0], self.pos[1] + move_per_unit)\n                if remaining &gt; 0:\n                    yield self.env.timeout(remaining)\n                    if axis == \"x\":\n                        self.pos = (self.pos[0] + move_per_unit * remaining, self.pos[1])\n                    else:\n                        self.pos = (self.pos[0], self.pos[1] + move_per_unit * remaining)\n\n\n    def pickup_packages(self, count, pickup_name):\n        yield self.env.process(self.move_to(pickup_name, \"to_pickup\", outbound=True))\n        # self.logger.log_custom_event(entity_id=self.name, event_type=\"action\",\n        #                              event=f\"picked_up_{count}_packages\",\n        #                              x=self.pos[0], y=self.pos[1],\n        #                              location=pickup_name)\n\n        yield self.env.process(self.move_to(\"packing\", \"to_packing\", outbound=False))\n\n\n        self.logger.log_queue(entity_id=self.name,\n                                    event=pickup_name,\n                                    x=self.pos[0], y=self.pos[1],\n                                    package_count=count)\n        for i in range(count):\n            yield self.env.timeout(PACKING_TIME)\n\n        if random.random() &lt; OTHER_TASK_PROB:\n            yield self.env.process(self.other_task())\n\n        # Go back to the packing station\n        self.logger.log_queue(entity_id=self.name,\n                                    event=\"packing\",\n                                    x=self.pos[0], y=self.pos[1])\n\n\n\n    def other_task(self):\n        yield self.env.process(self.move_to(\"maintenance\", \"to_maintenance\"))\n        task_time = random.randint(*OTHER_TASK_TIME)\n        self.logger.log_queue(entity_id=self.name,\n                                     event=\"maintenance\",\n                                     x=self.pos[0], y=self.pos[1],\n                                     task_duration_mins=task_time\n                                     )\n        yield self.env.timeout(task_time)\n        yield self.env.process(self.move_to(\"packing\", \"return_from_maintenance\"))\n        # Logging of return to packing location will be handled in pickup_packages process\n\n\ndef package_arrival(env, robot):\n    while True:\n        yield env.timeout(random.randint(4, 8))\n        num_packages = random.randint(*PACKAGES_PER_BATCH)\n        pickup_name = random.choice(PICKUP_POINTS)\n        yield env.process(robot.pickup_packages(num_packages, pickup_name))\n\n\n\n\n# ---------------------------\n# Running the simulation\n# ---------------------------\nif __name__ == \"__main__\":\n    env = simpy.Environment()\n    logger = EventLogger(env=env)\n    robot = PackingRobot(env, \"RoboPack-1\", logger)\n    env.process(package_arrival(env, robot))\n    env.run(until=SIM_DURATION)\n    logger.log_departure(entity_id=robot.name,\n                            x=robot.pos[0], y=robot.pos[1])\n\n    logger.to_csv(\"robot_log.csv\")\n\n\n\n\n# Define positions for animation\nevent_positions = create_event_position_df([\n    EventPosition(event='arrival', x=0, y=550, label=\"Entrance\"),\n\n    EventPosition(event='pickup_1', x=40, y=500, label=\"Pickup 1\"),\n    EventPosition(event='pickup_2', x=170, y=500, label=\"Pickup 2\"),\n    EventPosition(event='pickup_3', x=350, y=500, label=\"Pickup 3\"),\n    EventPosition(event='pickup_4', x=500, y=500, label=\"Pickup 4\"),\n    EventPosition(event='pickup_5', x=40, y=60, label=\"Pickup 5\"),\n    EventPosition(event='pickup_6', x=170, y=60, label=\"Pickup 6\"),\n    EventPosition(event='pickup_7', x=350, y=60, label=\"Pickup 7\"),\n    EventPosition(event='pickup_8', x=500, y=60, label=\"Pickup 8\"),\n\n    EventPosition(event='packing', x=300, y=300, label=\"Packing\"),\n    EventPosition(event='maintenance', x=600, y=300, label=\"Maintenance\"),\n\n    EventPosition(event='depart', x=650, y=50, label=\"Exit\")\n])\n\n\nevent_log_df = pd.read_csv(\"robot_log.csv\")\nevent_log_df.head()\n\n\n\n\n\n\n\n\nentity_id\nevent_type\nevent\ntime\npathway\nrun_number\ntimestamp\nresource_id\nx\ny\npackage_count\ntask_duration_mins\n\n\n\n\n0\nRoboPack-1\narrival_departure\narrival\n0.0\nNaN\nNaN\nNaN\nNaN\n270.0\n270.0\nNaN\nNaN\n\n\n1\nRoboPack-1\nqueue\npacking\n0.0\nNaN\nNaN\nNaN\nNaN\n270.0\n270.0\nNaN\nNaN\n\n\n2\nRoboPack-1\nposition_poll\nposition\n0.0\nNaN\nNaN\nNaN\nNaN\n270.0\n270.0\nNaN\nNaN\n\n\n3\nRoboPack-1\nposition_poll\nposition\n1.0\nNaN\nNaN\nNaN\nNaN\n270.0\n270.0\nNaN\nNaN\n\n\n4\nRoboPack-1\nposition_poll\nposition\n2.0\nNaN\nNaN\nNaN\nNaN\n270.0\n270.0\nNaN\nNaN\n\n\n\n\n\n\n\n\nSTEP_SNAPSHOT_MAX = 999\nLIMIT_DURATION = int(max(event_log_df[event_log_df[\"event_type\"]!=\"position_poll\"]['time']))\nWRAP_QUEUES_AT = 999\n\n\nevent_log_df_filtered = event_log_df[~event_log_df[\"event_type\"].isin([\"position_poll\", \"action\"])][['entity_id', 'event_type', 'event', 'time', 'pathway']]\nevent_log_df_filtered.head(10)\n\n\n\n\n\n\n\n\nentity_id\nevent_type\nevent\ntime\npathway\n\n\n\n\n0\nRoboPack-1\narrival_departure\narrival\n0.0\nNaN\n\n\n1\nRoboPack-1\nqueue\npacking\n0.0\nNaN\n\n\n13\nRoboPack-1\nqueue\npickup_2\n10.4\nNaN\n\n\n23\nRoboPack-1\nqueue\nmaintenance\n19.0\nNaN\n\n\n29\nRoboPack-1\nqueue\npacking\n24.6\nNaN\n\n\n46\nRoboPack-1\nqueue\npickup_8\n40.6\nNaN\n\n\n67\nRoboPack-1\nqueue\npacking\n60.6\nNaN\n\n\n86\nRoboPack-1\nqueue\npickup_1\n78.1\nNaN\n\n\n97\nRoboPack-1\nqueue\npacking\n88.1\nNaN\n\n\n114\nRoboPack-1\nqueue\npickup_8\n104.1\nNaN\n\n\n\n\n\n\n\nWe’ll first run this while allowing vidigi to handle the pathing. This means that the path between each step will be interpolated.\n\nanimate_activity_log(\n    event_log=event_log_df_filtered,\n    event_position_df=event_positions,\n    wrap_queues_at=WRAP_QUEUES_AT,\n    limit_duration=LIMIT_DURATION,\n    step_snapshot_max=STEP_SNAPSHOT_MAX,\n    every_x_time_units=1,\n    debug_mode=True,\n    custom_entity_icon_list=[\"🤖\"]\n)\n\nAnimation function called at 16:38:11\nIteration through time-unit-by-time-unit logs complete 16:38:17\nSnapshot df concatenation complete at 16:38:17\nReshaped animation dataframe finished construction at 16:38:17\nPlacement dataframe finished construction at 16:38:17\nOutput animation generation complete at 16:38:22\nTotal Time Elapsed: 10.60 seconds\n\n\n        \n        \n        \n\n\n                                                    \n\n\nIf we were to put in a background illustrating the paths the robots should follow, this will look bad:\n\nanimate_activity_log(\n    event_log=event_log_df_filtered,\n    event_position_df=event_positions,\n    wrap_queues_at=WRAP_QUEUES_AT,\n    limit_duration=LIMIT_DURATION,\n    step_snapshot_max=STEP_SNAPSHOT_MAX,\n    every_x_time_units=1,\n    debug_mode=True,\n    display_stage_labels=False,\n    custom_entity_icon_list=[\"🤖\"],\n    add_background_image=\"https://raw.githubusercontent.com/hsma-tools/vidigi/refs/heads/main/examples/example_16_packing_robot/warehouse.png\",\n    background_image_opacity=1, # New parameter in 1.1.0\n    override_x_max=650,\n    override_y_max=550,\n    plotly_width=1300,\n    plotly_height=800,\n)\n\nAnimation function called at 16:38:22\nIteration through time-unit-by-time-unit logs complete 16:38:28\nSnapshot df concatenation complete at 16:38:28\nReshaped animation dataframe finished construction at 16:38:28\nPlacement dataframe finished construction at 16:38:28\nOutput animation generation complete at 16:38:32\nTotal Time Elapsed: 10.22 seconds\n\n\n                                                    \n\n\nHowever, in this particular model, we have been polling the location of the robot after every step.\nThis might be imporant to visualise accurately in certain models - for example, to demonstrate why a robot might have to wait for another robot to move out of the way, and to assure stakeholders that such a thing has been recorded accurately.\nLet’s see how we can combine vidigi with these polled locations.\n\nfull_entity_df = reshape_for_animations(\n    event_log=event_log_df[~event_log_df[\"event_type\"].isin([\"position_poll\", \"action\"])][['entity_id', 'event_type', 'event', 'time', 'pathway']],\n    limit_duration=LIMIT_DURATION,\n    step_snapshot_max=STEP_SNAPSHOT_MAX,\n    every_x_time_units=1,\n    debug_mode=True\n    )\n\nfull_entity_df\n\nIteration through time-unit-by-time-unit logs complete 16:38:38\nSnapshot df concatenation complete at 16:38:38\n\n\n\n\n\n\n\n\n\nindex\nentity_id\nevent_type\nevent\ntime\npathway\nrank\nsnapshot_time\n\n\n\n\n0\n1\nRoboPack-1\nqueue\npacking\n0.0\nNaN\n1.0\n0\n\n\n1\n1\nRoboPack-1\nqueue\npacking\n0.0\nNaN\n1.0\n1\n\n\n2\n1\nRoboPack-1\nqueue\npacking\n0.0\nNaN\n1.0\n2\n\n\n3\n1\nRoboPack-1\nqueue\npacking\n0.0\nNaN\n1.0\n3\n\n\n4\n1\nRoboPack-1\nqueue\npacking\n0.0\nNaN\n1.0\n4\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n1436\n1535\nRoboPack-1\nqueue\npacking\n1428.4\nNaN\n1.0\n1436\n\n\n1437\n1535\nRoboPack-1\nqueue\npacking\n1428.4\nNaN\n1.0\n1437\n\n\n1438\n1535\nRoboPack-1\nqueue\npacking\n1428.4\nNaN\n1.0\n1438\n\n\n1439\n1535\nRoboPack-1\nqueue\npacking\n1428.4\nNaN\n1.0\n1439\n\n\n1440\n1547\nRoboPack-1\narrival_departure\ndepart\n1440.0\nNaN\n1.0\n1440\n\n\n\n\n1441 rows × 8 columns\n\n\n\n\nfull_entity_df_plus_pos = generate_animation_df(\n    full_entity_df=full_entity_df,\n    event_position_df=event_positions,\n    wrap_queues_at=WRAP_QUEUES_AT,\n    step_snapshot_max=STEP_SNAPSHOT_MAX,\n    debug_mode=True,\n    custom_entity_icon_list=[\"🤖\"]\n    )\n\nfull_entity_df_plus_pos\n\nPlacement dataframe finished construction at 16:38:38\n\n\n\n\n\n\n\n\n\nindex\nentity_id\nevent_type\nevent\ntime\npathway\nrank\nsnapshot_time\nx\ny_final\nlabel\nresource\nx_final\nrow\ny\nicon\nopacity\n\n\n\n\n0\n23\nRoboPack-1\nqueue\nmaintenance\n19.0\nNaN\n1.0\n19\n600\n300.0\nMaintenance\nNone\n600.0\n0.0\nNaN\n🤖\n1.0\n\n\n1\n23\nRoboPack-1\nqueue\nmaintenance\n19.0\nNaN\n1.0\n20\n600\n300.0\nMaintenance\nNone\n600.0\n0.0\nNaN\n🤖\n1.0\n\n\n2\n23\nRoboPack-1\nqueue\nmaintenance\n19.0\nNaN\n1.0\n21\n600\n300.0\nMaintenance\nNone\n600.0\n0.0\nNaN\n🤖\n1.0\n\n\n3\n23\nRoboPack-1\nqueue\nmaintenance\n19.0\nNaN\n1.0\n22\n600\n300.0\nMaintenance\nNone\n600.0\n0.0\nNaN\n🤖\n1.0\n\n\n4\n23\nRoboPack-1\nqueue\nmaintenance\n19.0\nNaN\n1.0\n23\n600\n300.0\nMaintenance\nNone\n600.0\n0.0\nNaN\n🤖\n1.0\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n1435\n1472\nRoboPack-1\nqueue\npickup_8\n1370.7\nNaN\n1.0\n1385\n500\n60.0\nPickup 8\nNone\n500.0\n0.0\nNaN\n🤖\n1.0\n\n\n1436\n1472\nRoboPack-1\nqueue\npickup_8\n1370.7\nNaN\n1.0\n1386\n500\n60.0\nPickup 8\nNone\n500.0\n0.0\nNaN\n🤖\n1.0\n\n\n1437\n1472\nRoboPack-1\nqueue\npickup_8\n1370.7\nNaN\n1.0\n1387\n500\n60.0\nPickup 8\nNone\n500.0\n0.0\nNaN\n🤖\n1.0\n\n\n1438\n1472\nRoboPack-1\nqueue\npickup_8\n1370.7\nNaN\n1.0\n1388\n500\n60.0\nPickup 8\nNone\n500.0\n0.0\nNaN\n🤖\n1.0\n\n\n1439\n1472\nRoboPack-1\nqueue\npickup_8\n1370.7\nNaN\n1.0\n1389\n500\n60.0\nPickup 8\nNone\n500.0\n0.0\nNaN\n🤖\n1.0\n\n\n\n\n1440 rows × 17 columns\n\n\n\nNow we can replace our calculated x_final and y_final coordinates with the values from the polling.\nFirst, we pull this data out of our event logs and rename the columns to match the relevant columns in our transformed event logging dataset.\n\nentity_position_df = event_log_df[event_log_df[\"event_type\"]==\"position_poll\"][['entity_id', 'time', 'x', 'y']].reset_index(drop=True)\nentity_position_df = entity_position_df.rename(columns={\"x\": \"x_final\", \"y\": \"y_final\", \"time\": \"snapshot_time\"})\nentity_position_df\n\n\n\n\n\n\n\n\nentity_id\nsnapshot_time\nx_final\ny_final\n\n\n\n\n0\nRoboPack-1\n0.0\n270.0\n270.0\n\n\n1\nRoboPack-1\n1.0\n270.0\n270.0\n\n\n2\nRoboPack-1\n2.0\n270.0\n270.0\n\n\n3\nRoboPack-1\n3.0\n270.0\n270.0\n\n\n4\nRoboPack-1\n4.0\n270.0\n270.0\n\n\n...\n...\n...\n...\n...\n\n\n1435\nRoboPack-1\n1435.0\n25.0\n270.0\n\n\n1436\nRoboPack-1\n1436.0\n25.0\n370.0\n\n\n1437\nRoboPack-1\n1437.0\n25.0\n470.0\n\n\n1438\nRoboPack-1\n1438.0\n25.0\n500.0\n\n\n1439\nRoboPack-1\n1439.0\n25.0\n400.0\n\n\n\n\n1440 rows × 4 columns\n\n\n\nWe then drop our original x_final and y_final columns from our transformed dataset, replacing them with those from the polling in our model.\n\nfull_entity_df_plus_pos_manual_locations = (\n    full_entity_df_plus_pos\n    .drop(columns=[\"x_final\", \"y_final\"])\n    .merge(entity_position_df, on=[\"entity_id\", \"snapshot_time\"])\n)\n\nfull_entity_df_plus_pos_manual_locations\n\n\n\n\n\n\n\n\nindex\nentity_id\nevent_type\nevent\ntime\npathway\nrank\nsnapshot_time\nx\nlabel\nresource\nrow\ny\nicon\nopacity\nx_final\ny_final\n\n\n\n\n0\n23\nRoboPack-1\nqueue\nmaintenance\n19.0\nNaN\n1.0\n19\n600\nMaintenance\nNone\n0.0\nNaN\n🤖\n1.0\n600.0\n270.0\n\n\n1\n23\nRoboPack-1\nqueue\nmaintenance\n19.0\nNaN\n1.0\n20\n600\nMaintenance\nNone\n0.0\nNaN\n🤖\n1.0\n600.0\n300.0\n\n\n2\n23\nRoboPack-1\nqueue\nmaintenance\n19.0\nNaN\n1.0\n21\n600\nMaintenance\nNone\n0.0\nNaN\n🤖\n1.0\n600.0\n300.0\n\n\n3\n23\nRoboPack-1\nqueue\nmaintenance\n19.0\nNaN\n1.0\n22\n600\nMaintenance\nNone\n0.0\nNaN\n🤖\n1.0\n500.0\n300.0\n\n\n4\n23\nRoboPack-1\nqueue\nmaintenance\n19.0\nNaN\n1.0\n23\n600\nMaintenance\nNone\n0.0\nNaN\n🤖\n1.0\n400.0\n300.0\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n1435\n1472\nRoboPack-1\nqueue\npickup_8\n1370.7\nNaN\n1.0\n1385\n500\nPickup 8\nNone\n0.0\nNaN\n🤖\n1.0\n270.0\n270.0\n\n\n1436\n1472\nRoboPack-1\nqueue\npickup_8\n1370.7\nNaN\n1.0\n1386\n500\nPickup 8\nNone\n0.0\nNaN\n🤖\n1.0\n270.0\n270.0\n\n\n1437\n1472\nRoboPack-1\nqueue\npickup_8\n1370.7\nNaN\n1.0\n1387\n500\nPickup 8\nNone\n0.0\nNaN\n🤖\n1.0\n370.0\n270.0\n\n\n1438\n1472\nRoboPack-1\nqueue\npickup_8\n1370.7\nNaN\n1.0\n1388\n500\nPickup 8\nNone\n0.0\nNaN\n🤖\n1.0\n470.0\n270.0\n\n\n1439\n1472\nRoboPack-1\nqueue\npickup_8\n1370.7\nNaN\n1.0\n1389\n500\nPickup 8\nNone\n0.0\nNaN\n🤖\n1.0\n600.0\n270.0\n\n\n\n\n1440 rows × 17 columns\n\n\n\nFinally, we then generate our animation as usual - making sure to refer to our updated dataframe.\n\nfig = generate_animation(\n        full_entity_df_plus_pos=full_entity_df_plus_pos_manual_locations.sort_values(['entity_id', 'snapshot_time']),\n        event_position_df= event_positions,\n        simulation_time_unit=\"seconds\",\n        display_stage_labels=False,\n        setup_mode=False,\n        start_time=\"07:00:00\",\n        time_display_units=\"%H:%M:%S\",\n        debug_mode=True,\n        add_background_image=\"https://raw.githubusercontent.com/hsma-tools/vidigi/refs/heads/main/examples/example_16_packing_robot/warehouse.png\",\n        background_image_opacity=1, # New parameter in 1.1.0\n        override_x_max=650,\n        override_y_max=550,\n        plotly_width=1300,\n        plotly_height=800,\n        entity_icon_size=50,\n        frame_duration=200,\n        frame_transition_duration=300\n\n    )\n\nfig\n\nOutput animation generation complete at 16:38:43\n\n\n                                                    \n\n\nLet’s finally repeat this with an instance with multiple packers.\nIn this very simplistic model, blocking of corridors is not implemented - but is the kind of thing that would visualise well with this kind of pre-calculated movement.\n\nevent_log_df_multiple = pd.read_csv(\"robot_log_multiple.csv\")\n\nfull_entity_df_multiple = reshape_for_animations(\n    event_log=event_log_df_multiple[~event_log_df_multiple[\"event_type\"].isin([\"position_poll\", \"action\"])][['entity_id', 'event_type', 'event', 'time', 'pathway']],\n    limit_duration=LIMIT_DURATION,\n    step_snapshot_max=STEP_SNAPSHOT_MAX,\n    every_x_time_units=1,\n    debug_mode=True\n    )\n\nfull_entity_df_plus_pos_multiple = generate_animation_df(\n    full_entity_df=full_entity_df_multiple,\n    event_position_df=event_positions,\n    wrap_queues_at=WRAP_QUEUES_AT,\n    step_snapshot_max=STEP_SNAPSHOT_MAX,\n    debug_mode=True,\n    custom_entity_icon_list=[\"🤖\"]\n    # custom_entity_icon_list=[\"🟦\", \"🟫\", \"🟪\", \"🟧\", \"🟥\", \"🟨\", \"🟩\", \"◻️\"]\n    )\n\nfull_entity_df_plus_pos_multiple\n\nIteration through time-unit-by-time-unit logs complete 16:38:51\nSnapshot df concatenation complete at 16:38:51\nPlacement dataframe finished construction at 16:38:51\n\n\n\n\n\n\n\n\n\nindex\nentity_id\nevent_type\nevent\ntime\npathway\nrank\nsnapshot_time\nx\ny_final\nlabel\nresource\nx_final\nrow\ny\nicon\nopacity\n\n\n\n\n0\n224\nRoboPack-8\nqueue\nmaintenance\n24.9\nNaN\n1.0\n25\n600\n300.0\nMaintenance\nNone\n600.0\n0.0\nNaN\n🤖\n1.0\n\n\n1\n224\nRoboPack-8\nqueue\nmaintenance\n24.9\nNaN\n1.0\n26\n600\n300.0\nMaintenance\nNone\n600.0\n0.0\nNaN\n🤖\n1.0\n\n\n2\n224\nRoboPack-8\nqueue\nmaintenance\n24.9\nNaN\n1.0\n27\n600\n300.0\nMaintenance\nNone\n600.0\n0.0\nNaN\n🤖\n1.0\n\n\n3\n224\nRoboPack-8\nqueue\nmaintenance\n24.9\nNaN\n1.0\n28\n600\n300.0\nMaintenance\nNone\n600.0\n0.0\nNaN\n🤖\n1.0\n\n\n4\n224\nRoboPack-8\nqueue\nmaintenance\n24.9\nNaN\n1.0\n29\n600\n300.0\nMaintenance\nNone\n600.0\n0.0\nNaN\n🤖\n1.0\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n11515\n4934\nRoboPack-1\nqueue\npickup_7\n576.6\nNaN\n1.0\n597\n350\n60.0\nPickup 7\nNone\n350.0\n0.0\nNaN\n🤖\n1.0\n\n\n11516\n4934\nRoboPack-1\nqueue\npickup_7\n576.6\nNaN\n1.0\n598\n350\n60.0\nPickup 7\nNone\n350.0\n0.0\nNaN\n🤖\n1.0\n\n\n11517\n4934\nRoboPack-1\nqueue\npickup_7\n576.6\nNaN\n1.0\n599\n350\n60.0\nPickup 7\nNone\n350.0\n0.0\nNaN\n🤖\n1.0\n\n\n11518\n4934\nRoboPack-1\nqueue\npickup_7\n576.6\nNaN\n1.0\n600\n350\n60.0\nPickup 7\nNone\n350.0\n0.0\nNaN\n🤖\n1.0\n\n\n11519\n4934\nRoboPack-1\nqueue\npickup_7\n576.6\nNaN\n1.0\n601\n350\n60.0\nPickup 7\nNone\n350.0\n0.0\nNaN\n🤖\n1.0\n\n\n\n\n11520 rows × 17 columns\n\n\n\n\nentity_position_df_multiple = (\n    event_log_df_multiple[event_log_df_multiple[\"event_type\"]==\"position_poll\"]\n    [['entity_id', 'time', 'x', 'y']]\n    .reset_index(drop=True)\n    .rename(columns={\"x\": \"x_final\", \"y\": \"y_final\", \"time\": \"snapshot_time\"})\n    )\n\n# entity_position_df_multiple[\"snapshot_time\"] = entity_position_df_multiple[\"snapshot_time\"].astype('int')\n\nentity_position_df_multiple\n\n\n\n\n\n\n\n\nentity_id\nsnapshot_time\nx_final\ny_final\n\n\n\n\n0\nRoboPack-1\n0.0\n270.0\n270.0\n\n\n1\nRoboPack-2\n0.0\n285.0\n270.0\n\n\n2\nRoboPack-3\n0.0\n300.0\n270.0\n\n\n3\nRoboPack-4\n0.0\n315.0\n270.0\n\n\n4\nRoboPack-5\n0.0\n270.0\n300.0\n\n\n...\n...\n...\n...\n...\n\n\n11515\nRoboPack-4\n1439.0\n300.0\n300.0\n\n\n11516\nRoboPack-5\n1439.0\n270.0\n300.0\n\n\n11517\nRoboPack-6\n1439.0\n300.0\n300.0\n\n\n11518\nRoboPack-7\n1439.0\n300.0\n300.0\n\n\n11519\nRoboPack-8\n1439.0\n315.0\n300.0\n\n\n\n\n11520 rows × 4 columns\n\n\n\n\nfull_entity_df_plus_pos_manual_locations_multiple = (\n    full_entity_df_plus_pos_multiple\n    .drop(columns=[\"x_final\", \"y_final\"])\n    .merge(entity_position_df_multiple, on=[\"entity_id\", \"snapshot_time\"])\n)\n\nfull_entity_df_plus_pos_manual_locations_multiple\n\n\n\n\n\n\n\n\nindex\nentity_id\nevent_type\nevent\ntime\npathway\nrank\nsnapshot_time\nx\nlabel\nresource\nrow\ny\nicon\nopacity\nx_final\ny_final\n\n\n\n\n0\n224\nRoboPack-8\nqueue\nmaintenance\n24.9\nNaN\n1.0\n25\n600\nMaintenance\nNone\n0.0\nNaN\n🤖\n1.0\n600.0\n300.0\n\n\n1\n224\nRoboPack-8\nqueue\nmaintenance\n24.9\nNaN\n1.0\n26\n600\nMaintenance\nNone\n0.0\nNaN\n🤖\n1.0\n600.0\n300.0\n\n\n2\n224\nRoboPack-8\nqueue\nmaintenance\n24.9\nNaN\n1.0\n27\n600\nMaintenance\nNone\n0.0\nNaN\n🤖\n1.0\n600.0\n300.0\n\n\n3\n224\nRoboPack-8\nqueue\nmaintenance\n24.9\nNaN\n1.0\n28\n600\nMaintenance\nNone\n0.0\nNaN\n🤖\n1.0\n600.0\n300.0\n\n\n4\n224\nRoboPack-8\nqueue\nmaintenance\n24.9\nNaN\n1.0\n29\n600\nMaintenance\nNone\n0.0\nNaN\n🤖\n1.0\n600.0\n300.0\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n11515\n4934\nRoboPack-1\nqueue\npickup_7\n576.6\nNaN\n1.0\n597\n350\nPickup 7\nNone\n0.0\nNaN\n🤖\n1.0\n270.0\n270.0\n\n\n11516\n4934\nRoboPack-1\nqueue\npickup_7\n576.6\nNaN\n1.0\n598\n350\nPickup 7\nNone\n0.0\nNaN\n🤖\n1.0\n270.0\n270.0\n\n\n11517\n4934\nRoboPack-1\nqueue\npickup_7\n576.6\nNaN\n1.0\n599\n350\nPickup 7\nNone\n0.0\nNaN\n🤖\n1.0\n270.0\n270.0\n\n\n11518\n4934\nRoboPack-1\nqueue\npickup_7\n576.6\nNaN\n1.0\n600\n350\nPickup 7\nNone\n0.0\nNaN\n🤖\n1.0\n270.0\n270.0\n\n\n11519\n4934\nRoboPack-1\nqueue\npickup_7\n576.6\nNaN\n1.0\n601\n350\nPickup 7\nNone\n0.0\nNaN\n🤖\n1.0\n270.0\n270.0\n\n\n\n\n11520 rows × 17 columns\n\n\n\n\nfig_multiple = generate_animation(\n        full_entity_df_plus_pos=full_entity_df_plus_pos_manual_locations_multiple.sort_values(['entity_id', 'snapshot_time']),\n        event_position_df= event_positions,\n        simulation_time_unit=\"seconds\",\n        display_stage_labels=False,\n        setup_mode=False,\n        start_time=\"07:00:00\",\n        time_display_units=\"%H:%M:%S\",\n        debug_mode=True,\n        add_background_image=\"https://raw.githubusercontent.com/hsma-tools/vidigi/refs/heads/main/examples/example_16_packing_robot/warehouse.png\",\n        background_image_opacity=1, # New parameter in 1.1.0\n        override_x_max=650,\n        override_y_max=550,\n        plotly_width=1300,\n        plotly_height=800,\n        entity_icon_size=30\n\n    )\n\nfig_multiple\n\nOutput animation generation complete at 16:38:56"
  },
  {
    "objectID": "examples/example_1_simplest_case/ex_1_simplest_case.html",
    "href": "examples/example_1_simplest_case/ex_1_simplest_case.html",
    "title": "A Simple Animation of a One-step SimPy Model",
    "section": "",
    "text": "from examples.example_1_simplest_case.ex_1_model_classes_with_vidigi_logging import Trial, g\nfrom vidigi.animation import animate_activity_log\nfrom vidigi.utils import EventPosition, create_event_position_df\nimport pandas as pd\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\nimport os\n\n\n\n\n\n\n\nView Imported Code, which has had logging steps added at the appropriate points in the ‘model’ class\n\n\n\n\n\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\nfrom sim_tools.distributions import Exponential, Lognormal\nfrom vidigi.resources import populate_store\n\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    '''\n    Create a scenario to parameterise the simulation model\n\n    Parameters:\n    -----------\n    random_number_set: int, optional (default=DEFAULT_RNG_SET)\n        Set to control the initial seeds of each stream of pseudo\n        random numbers used in the model.\n\n    n_cubicles: int\n        The number of treatment cubicles\n\n    trauma_treat_mean: float\n        Mean of the trauma cubicle treatment distribution (Lognormal)\n\n    trauma_treat_var: float\n        Variance of the trauma cubicle treatment distribution (Lognormal)\n\n    arrival_rate: float\n        Set the mean of the exponential distribution that is used to sample the\n        inter-arrival time of patients\n\n    sim_duration: int\n        The number of time units the simulation will run for\n\n    number_of_runs: int\n        The number of times the simulation will be run with different random number streams\n\n    '''\n    random_number_set = 42\n\n    n_cubicles = 4\n    trauma_treat_mean = 40\n    trauma_treat_var = 5\n\n    arrival_rate = 5\n\n    sim_duration = 600\n    number_of_runs = 100\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    '''\n    Class defining details for a patient entity\n    '''\n    def __init__(self, p_id):\n        '''\n        Constructor method\n\n        Params:\n        -----\n        identifier: int\n            a numeric identifier for the patient.\n        '''\n        self.identifier = p_id\n        self.arrival = -np.inf\n        self.wait_treat = -np.inf\n        self.total_time = -np.inf\n        self.treat_duration = -np.inf\n\n# Class representing our model of the clinic.\nclass Model:\n    '''\n    Simulates the simplest minor treatment process for a patient\n\n    1. Arrive\n    2. Examined/treated by nurse when one available\n    3. Discharged\n    '''\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        self.event_log = []\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        self.patients = []\n\n        # Create our resources\n        self.init_resources()\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Queue Time Cubicle\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_cubicle = 0\n\n        self.patient_inter_arrival_dist = Exponential(mean = g.arrival_rate,\n                                                      random_seed = self.run_number*g.random_number_set)\n        self.treat_dist = Lognormal(mean = g.trauma_treat_mean,\n                                    stdev = g.trauma_treat_var,\n                                    random_seed = self.run_number*g.random_number_set)\n\n    def init_resources(self):\n        '''\n        Init the number of resources\n        and store in the arguments container object\n\n        Resource list:\n            1. Nurses/treatment bays (same thing in this model)\n\n        '''\n        self.treatment_cubicles = simpy.Store(self.env)\n\n        populate_store(num_resources=g.n_cubicles,\n                       simpy_store=self.treatment_cubicles,\n                       sim_env=self.env)\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            # Store patient in list for later easy access\n            self.patients.append(p)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = self.patient_inter_arrival_dist.sample()\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        self.arrival = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Simplest',\n             'event_type': 'arrival_departure',\n             'event': 'arrival',\n             'time': self.env.now}\n        )\n\n        # request examination resource\n        start_wait = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Simplest',\n             'event': 'treatment_wait_begins',\n             'event_type': 'queue',\n             'time': self.env.now}\n        )\n\n        # Seize a treatment resource when available\n        treatment_resource = yield self.treatment_cubicles.get()\n\n        # record the waiting time for registration\n        self.wait_treat = self.env.now - start_wait\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Simplest',\n                'event': 'treatment_begins',\n                'event_type': 'resource_use',\n                'time': self.env.now,\n                'resource_id': treatment_resource.id_attribute\n                }\n        )\n\n        # sample treatment duration\n        self.treat_duration = self.treat_dist.sample()\n        yield self.env.timeout(self.treat_duration)\n\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Simplest',\n                'event': 'treatment_complete',\n                'event_type': 'resource_use_end',\n                'time': self.env.now,\n                'resource_id': treatment_resource.id_attribute}\n        )\n\n        # Resource is no longer in use, so put it back in\n        self.treatment_cubicles.put(treatment_resource)\n\n        # total time in system\n        self.total_time = self.env.now - self.arrival\n        self.event_log.append(\n            {'patient': patient.identifier,\n            'pathway': 'Simplest',\n            'event': 'depart',\n            'event_type': 'arrival_departure',\n            'time': self.env.now}\n        )\n\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_cubicle = self.results_df[\"Queue Time Cubicle\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        self.event_log = pd.DataFrame(self.event_log)\n\n        self.event_log[\"run\"] = self.run_number\n\n        return {'results': self.results_df, 'event_log': self.event_log}\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Arrivals\"] = [0]\n        self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n        self.all_event_logs = []\n\n    # Method to run a trial\n    def run_trial(self):\n        print(f\"{g.n_cubicles} nurses\")\n        print(\"\") ## Print a blank line\n\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            random.seed(run)\n\n            my_model = Model(run)\n            model_outputs = my_model.run()\n            patient_level_results = model_outputs[\"results\"]\n            event_log = model_outputs[\"event_log\"]\n\n            self.df_trial_results.loc[run] = [\n                len(patient_level_results),\n                my_model.mean_q_time_cubicle,\n            ]\n\n            # print(event_log)\n\n            self.all_event_logs.append(event_log)\n\n        self.all_event_logs = pd.concat(self.all_event_logs)\n\n\n\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\n4 nurses\n\n\n\n\nmy_trial.all_event_logs.head(50)\n\n\n\n\n\n\n\n\npatient\npathway\nevent_type\nevent\ntime\nresource_id\nrun\n\n\n\n\n0\n1\nSimplest\narrival_departure\narrival\n0.000000\nNaN\n0\n\n\n1\n1\nSimplest\nqueue\ntreatment_wait_begins\n0.000000\nNaN\n0\n\n\n2\n1\nSimplest\nresource_use\ntreatment_begins\n0.000000\n1.0\n0\n\n\n3\n2\nSimplest\narrival_departure\narrival\n3.399660\nNaN\n0\n\n\n4\n2\nSimplest\nqueue\ntreatment_wait_begins\n3.399660\nNaN\n0\n\n\n5\n2\nSimplest\nresource_use\ntreatment_begins\n3.399660\n2.0\n0\n\n\n6\n3\nSimplest\narrival_departure\narrival\n8.497645\nNaN\n0\n\n\n7\n3\nSimplest\nqueue\ntreatment_wait_begins\n8.497645\nNaN\n0\n\n\n8\n3\nSimplest\nresource_use\ntreatment_begins\n8.497645\n3.0\n0\n\n\n9\n4\nSimplest\narrival_departure\narrival\n8.596678\nNaN\n0\n\n\n10\n4\nSimplest\nqueue\ntreatment_wait_begins\n8.596678\nNaN\n0\n\n\n11\n4\nSimplest\nresource_use\ntreatment_begins\n8.596678\n4.0\n0\n\n\n12\n5\nSimplest\narrival_departure\narrival\n8.608025\nNaN\n0\n\n\n13\n5\nSimplest\nqueue\ntreatment_wait_begins\n8.608025\nNaN\n0\n\n\n14\n6\nSimplest\narrival_departure\narrival\n11.359739\nNaN\n0\n\n\n15\n6\nSimplest\nqueue\ntreatment_wait_begins\n11.359739\nNaN\n0\n\n\n16\n7\nSimplest\narrival_departure\narrival\n19.509442\nNaN\n0\n\n\n17\n7\nSimplest\nqueue\ntreatment_wait_begins\n19.509442\nNaN\n0\n\n\n18\n8\nSimplest\narrival_departure\narrival\n22.877356\nNaN\n0\n\n\n19\n8\nSimplest\nqueue\ntreatment_wait_begins\n22.877356\nNaN\n0\n\n\n20\n9\nSimplest\narrival_departure\narrival\n26.653863\nNaN\n0\n\n\n21\n9\nSimplest\nqueue\ntreatment_wait_begins\n26.653863\nNaN\n0\n\n\n22\n1\nSimplest\nresource_use_end\ntreatment_complete\n40.317385\n1.0\n0\n\n\n23\n1\nSimplest\narrival_departure\ndepart\n40.317385\nNaN\n0\n\n\n24\n5\nSimplest\nresource_use\ntreatment_begins\n40.317385\n1.0\n0\n\n\n25\n10\nSimplest\narrival_departure\narrival\n40.737793\nNaN\n0\n\n\n26\n10\nSimplest\nqueue\ntreatment_wait_begins\n40.737793\nNaN\n0\n\n\n27\n2\nSimplest\nresource_use_end\ntreatment_complete\n42.443230\n2.0\n0\n\n\n28\n2\nSimplest\narrival_departure\ndepart\n42.443230\nNaN\n0\n\n\n29\n6\nSimplest\nresource_use\ntreatment_begins\n42.443230\n2.0\n0\n\n\n30\n4\nSimplest\nresource_use_end\ntreatment_complete\n48.809628\n4.0\n0\n\n\n31\n4\nSimplest\narrival_departure\ndepart\n48.809628\nNaN\n0\n\n\n32\n7\nSimplest\nresource_use\ntreatment_begins\n48.809628\n4.0\n0\n\n\n33\n3\nSimplest\nresource_use_end\ntreatment_complete\n51.483457\n3.0\n0\n\n\n34\n3\nSimplest\narrival_departure\ndepart\n51.483457\nNaN\n0\n\n\n35\n8\nSimplest\nresource_use\ntreatment_begins\n51.483457\n3.0\n0\n\n\n36\n11\nSimplest\narrival_departure\narrival\n71.026558\nNaN\n0\n\n\n37\n11\nSimplest\nqueue\ntreatment_wait_begins\n71.026558\nNaN\n0\n\n\n38\n5\nSimplest\nresource_use_end\ntreatment_complete\n77.447488\n1.0\n0\n\n\n39\n5\nSimplest\narrival_departure\ndepart\n77.447488\nNaN\n0\n\n\n40\n9\nSimplest\nresource_use\ntreatment_begins\n77.447488\n1.0\n0\n\n\n41\n6\nSimplest\nresource_use_end\ntreatment_complete\n83.962251\n2.0\n0\n\n\n42\n6\nSimplest\narrival_departure\ndepart\n83.962251\nNaN\n0\n\n\n43\n10\nSimplest\nresource_use\ntreatment_begins\n83.962251\n2.0\n0\n\n\n44\n12\nSimplest\narrival_departure\narrival\n87.458700\nNaN\n0\n\n\n45\n12\nSimplest\nqueue\ntreatment_wait_begins\n87.458700\nNaN\n0\n\n\n46\n13\nSimplest\narrival_departure\narrival\n87.465138\nNaN\n0\n\n\n47\n13\nSimplest\nqueue\ntreatment_wait_begins\n87.465138\nNaN\n0\n\n\n48\n7\nSimplest\nresource_use_end\ntreatment_complete\n95.498040\n4.0\n0\n\n\n49\n7\nSimplest\narrival_departure\ndepart\n95.498040\nNaN\n0\n\n\n\n\n\n\n\n\n# Create a list of EventPosition objects\nevent_position_df = create_event_position_df([\n    EventPosition(event='arrival', x=50, y=300, label=\"Arrival\"),\n    EventPosition(event='treatment_wait_begins', x=205, y=275, label=\"Waiting for Treatment\"),\n    EventPosition(event='treatment_begins', x=205, y=175, resource='n_cubicles', label=\"Being Treated\"),\n    EventPosition(event='depart', x=270, y=70, label=\"Exit\")\n])\n\n\nanimate_activity_log(\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        entity_col_name=\"patient\",\n        scenario=g(),\n        debug_mode=True,\n        setup_mode=False,\n        every_x_time_units=1,\n        include_play_button=True,\n        resource_icon_size=15,\n        text_size=20,\n        entity_icon_size=13,\n        gap_between_entities=6,\n        gap_between_queue_rows=25,\n        gap_between_resource_rows=25,\n        plotly_height=600,\n        frame_duration=200,\n        plotly_width=1000,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=g.sim_duration,\n        wrap_queues_at=25,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nAnimation function called at 11:27:17\nIteration through time-unit-by-time-unit logs complete 11:27:20\nSnapshot df concatenation complete at 11:27:20\nReshaped animation dataframe finished construction at 11:27:20\nPlacement dataframe finished construction at 11:27:20\nOutput animation generation complete at 11:27:23\nTotal Time Elapsed: 5.66 seconds",
    "crumbs": [
      "SimPy Examples",
      "A Simple Animation of a One-step SimPy Model"
    ]
  },
  {
    "objectID": "examples/example_3_simplest_case_priority_resource/ex_3_simplest_case_priority_resource.html",
    "href": "examples/example_3_simplest_case_priority_resource/ex_3_simplest_case_priority_resource.html",
    "title": "Visualising Entities with Different Priorities",
    "section": "",
    "text": "IMPORTANT NOTE!\nIn vidigi 0.0.5, the original implementation of VidigiPriorityStore was rewritten, with the version available in 0.0.4 renamed VidigiPriorityStoreLegacy.\nIf upgrading, you can change your import statement from\nfrom vidigi.utils import VidigiPriorityStore\nto\nfrom vidigi.resources import VidigiPriorityStoreLegacy as VidigiPriorityStore\nto allow your code to continue working in 0.0.5 with no other modifications.\nThe 0.0.5+ version of VidigiPriorityStore is designed to simplify the incorporation of vidigi into models that use simpy resources, minimizing the syntax changes required when requesting a resource. Take a look at example_7_simplest_case_priority_resource_storewrapper.ex_7_model_classes.py for an example of its use.\n\nfrom examples.example_3_simplest_case_priority_resource.ex_3_model_classes import Trial, g\nfrom vidigi.prep import reshape_for_animations, generate_animation_df\nfrom vidigi.animation import generate_animation, animate_activity_log\nimport pandas as pd\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\nimport os\n\n\n\n\n\n\n\nView Imported Code, which has had logging steps added at the appropriate points in the ‘model’ class\n\n\n\n\n\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\nfrom sim_tools.distributions import Exponential, Lognormal\nfrom vidigi.resources import populate_store, VidigiPriorityStoreLegacy as VidigiPriorityStore\n\nclass g:\n    '''\n    Create a scenario to parameterise the simulation model\n\n    Parameters:\n    -----------\n    random_number_set: int, optional (default=DEFAULT_RNG_SET)\n        Set to control the initial seeds of each stream of pseudo\n        random numbers used in the model.\n\n    n_cubicles: int\n        The number of treatment cubicles\n\n    trauma_treat_mean: float\n        Mean of the trauma cubicle treatment distribution (Lognormal)\n\n    trauma_treat_var: float\n        Variance of the trauma cubicle treatment distribution (Lognormal)\n\n        arrival_rate: float\n        Set the mean of the exponential distribution that is used to sample the\n        inter-arrival time of patients\n\n    '''\n    random_number_set = 42\n\n    n_cubicles = 4\n    trauma_treat_mean = 40\n    trauma_treat_var = 5\n\n    arrival_rate = 5\n    sim_duration = 600\n    number_of_runs = 100\n\nclass Patient:\n    '''\n    Class defining details for a patient entity\n    '''\n    def __init__(self, p_id):\n        '''\n        Constructor method\n\n        Params:\n        -----\n        identifier: int\n            a numeric identifier for the patient.\n        '''\n        self.identifier = p_id\n        self.arrival = -np.inf\n        self.wait_treat = -np.inf\n        self.total_time = -np.inf\n        self.treat_duration = -np.inf\n\n        # Randomly initialise a patient priority value\n        # Lower values will be prioritised - so priority 1 will be seen before priority 2\n        if random.uniform(0, 1) &lt; 0.2:\n            self.priority = 1\n        else:\n            self.priority = 2\n\nclass Model:\n    '''\n    Simulates the simplest minor treatment process for a patient\n\n    1. Arrive\n    2. Examined/treated by nurse when one available\n    3. Discharged\n    '''\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        self.event_log = []\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        self.patients = []\n\n        # Create our resources\n        self.init_resources()\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Queue Time Cubicle\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_cubicle = 0\n\n        self.patient_inter_arrival_dist = Exponential(mean = g.arrival_rate,\n                                                      random_seed = self.run_number*g.random_number_set)\n        self.treat_dist = Lognormal(mean = g.trauma_treat_mean,\n                                    stdev = g.trauma_treat_var,\n                                    random_seed = self.run_number*g.random_number_set)\n\n    def init_resources(self):\n        '''\n        Init the number of resources\n        and store in the arguments container object\n\n        Resource list:\n            1. Nurses/treatment bays (same thing in this model)\n\n        '''\n        self.treatment_cubicles = VidigiPriorityStore(self.env)\n\n        populate_store(num_resources=g.n_cubicles,\n                       simpy_store=self.treatment_cubicles,\n                       sim_env=self.env)\n\n    # A generator function that represents the DES generator for patient arrivals\n    def generator_patient_arrivals(self):\n        # Use an infinite loop here to keep doing this indefinitely while the simulation runs\n        while True:\n            # Increment the patient counter by 1 (first patient will have an ID of 1)\n            self.patient_counter += 1\n\n            p = Patient(self.patient_counter)\n\n            # Store patient in list for later easy access\n            self.patients.append(p)\n\n            # Tell SimPy to start up the attend_clinic generator function with this patient\n            # (the generator function that will model the patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving\n            sampled_inter = self.patient_inter_arrival_dist.sample()\n\n            # Freeze this instance of this function in place until the inter-arrival time\n            # sampled above has elapsed\n            yield self.env.timeout(sampled_inter)\n\n    def attend_clinic(self, patient):\n        \"\"\"\n        A generator function that represents the pathway for a patient going through the clinic.\n\n        The patient object is passed in to the generator function so we can extract information\n        from / record information to it\n        \"\"\"\n        self.arrival = self.env.now\n\n        # ===== LOGGING FOR VIDIGI ANIMATION  ===== #\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': patient.priority,\n             'event_type': 'arrival_departure',\n             'event': 'arrival',\n             'time': self.env.now}\n        )\n        # ========================================= #\n\n        # request examination resource\n        start_wait = self.env.now\n\n        # ===== LOGGING FOR VIDIGI ANIMATION  ===== #\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': patient.priority,\n             'event': 'treatment_wait_begins',\n             'event_type': 'queue',\n             'time': self.env.now}\n        )\n        # ========================================= #\n\n        # Seize a treatment resource when available\n        # Note that we must pass in the patient priority\n        treatment_resource = yield self.treatment_cubicles.get(priority=patient.priority)\n\n        # record the waiting time for registration\n        self.wait_treat = self.env.now - start_wait\n\n        # ===== LOGGING FOR VIDIGI ANIMATION  ===== #\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': patient.priority,\n                'event': 'treatment_begins',\n                'event_type': 'resource_use',\n                'time': self.env.now,\n                'resource_id': treatment_resource.id_attribute\n                }\n        )\n        # ========================================= #\n\n        # sample treatment duration\n        self.treat_duration = self.treat_dist.sample()\n        yield self.env.timeout(self.treat_duration)\n\n        # ===== LOGGING FOR VIDIGI ANIMATION  ===== #\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': patient.priority,\n                'event': 'treatment_complete',\n                'event_type': 'resource_use_end',\n                'time': self.env.now,\n                'resource_id': treatment_resource.id_attribute}\n        )\n        # ========================================= #\n\n        # Resource is no longer in use, so put it back in\n        self.treatment_cubicles.put(treatment_resource)\n\n        # total time in system\n        self.total_time = self.env.now - self.arrival\n\n        # ===== LOGGING FOR VIDIGI ANIMATION  ===== #\n        self.event_log.append(\n            {'patient': patient.identifier,\n            'pathway': patient.priority,\n            'event': 'depart',\n            'event_type': 'arrival_departure',\n            'time': self.env.now}\n        )\n        # ========================================= #\n\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_cubicle = self.results_df[\"Queue Time Cubicle\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        self.event_log = pd.DataFrame(self.event_log)\n\n        self.event_log[\"run\"] = self.run_number\n\n        return {'results': self.results_df, 'event_log': self.event_log}\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Arrivals\"] = [0]\n        self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n        self.all_event_logs = []\n\n    # Method to run a trial\n    def run_trial(self):\n        print(f\"{g.n_cubicles} nurses\")\n        print(\"\") ## Print a blank line\n\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            random.seed(run)\n\n            my_model = Model(run)\n            model_outputs = my_model.run()\n            patient_level_results = model_outputs[\"results\"]\n            event_log = model_outputs[\"event_log\"]\n\n            self.df_trial_results.loc[run] = [\n                len(patient_level_results),\n                my_model.mean_q_time_cubicle,\n            ]\n\n            # print(event_log)\n\n            self.all_event_logs.append(event_log)\n\n        self.all_event_logs = pd.concat(self.all_event_logs)\n\n\n\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\n4 nurses\n\n\n\n\nmy_trial.all_event_logs.head(50)\n\n\n\n\n\n\n\n\npatient\npathway\nevent_type\nevent\ntime\nresource_id\nrun\n\n\n\n\n0\n1\n2\narrival_departure\narrival\n0.000000\nNaN\n0\n\n\n1\n1\n2\nqueue\ntreatment_wait_begins\n0.000000\nNaN\n0\n\n\n2\n1\n2\nresource_use\ntreatment_begins\n0.000000\n1.0\n0\n\n\n3\n2\n2\narrival_departure\narrival\n3.399660\nNaN\n0\n\n\n4\n2\n2\nqueue\ntreatment_wait_begins\n3.399660\nNaN\n0\n\n\n5\n2\n2\nresource_use\ntreatment_begins\n3.399660\n2.0\n0\n\n\n6\n3\n2\narrival_departure\narrival\n8.497645\nNaN\n0\n\n\n7\n3\n2\nqueue\ntreatment_wait_begins\n8.497645\nNaN\n0\n\n\n8\n3\n2\nresource_use\ntreatment_begins\n8.497645\n3.0\n0\n\n\n9\n4\n2\narrival_departure\narrival\n8.596678\nNaN\n0\n\n\n10\n4\n2\nqueue\ntreatment_wait_begins\n8.596678\nNaN\n0\n\n\n11\n4\n2\nresource_use\ntreatment_begins\n8.596678\n4.0\n0\n\n\n12\n5\n2\narrival_departure\narrival\n8.608025\nNaN\n0\n\n\n13\n5\n2\nqueue\ntreatment_wait_begins\n8.608025\nNaN\n0\n\n\n14\n6\n2\narrival_departure\narrival\n11.359739\nNaN\n0\n\n\n15\n6\n2\nqueue\ntreatment_wait_begins\n11.359739\nNaN\n0\n\n\n16\n7\n2\narrival_departure\narrival\n19.509442\nNaN\n0\n\n\n17\n7\n2\nqueue\ntreatment_wait_begins\n19.509442\nNaN\n0\n\n\n18\n8\n2\narrival_departure\narrival\n22.877356\nNaN\n0\n\n\n19\n8\n2\nqueue\ntreatment_wait_begins\n22.877356\nNaN\n0\n\n\n20\n9\n2\narrival_departure\narrival\n26.653863\nNaN\n0\n\n\n21\n9\n2\nqueue\ntreatment_wait_begins\n26.653863\nNaN\n0\n\n\n22\n1\n2\nresource_use_end\ntreatment_complete\n40.317385\n1.0\n0\n\n\n23\n1\n2\narrival_departure\ndepart\n40.317385\nNaN\n0\n\n\n24\n5\n2\nresource_use\ntreatment_begins\n40.317385\n1.0\n0\n\n\n25\n10\n2\narrival_departure\narrival\n40.737793\nNaN\n0\n\n\n26\n10\n2\nqueue\ntreatment_wait_begins\n40.737793\nNaN\n0\n\n\n27\n2\n2\nresource_use_end\ntreatment_complete\n42.443230\n2.0\n0\n\n\n28\n2\n2\narrival_departure\ndepart\n42.443230\nNaN\n0\n\n\n29\n6\n2\nresource_use\ntreatment_begins\n42.443230\n2.0\n0\n\n\n30\n4\n2\nresource_use_end\ntreatment_complete\n48.809628\n4.0\n0\n\n\n31\n4\n2\narrival_departure\ndepart\n48.809628\nNaN\n0\n\n\n32\n7\n2\nresource_use\ntreatment_begins\n48.809628\n4.0\n0\n\n\n33\n3\n2\nresource_use_end\ntreatment_complete\n51.483457\n3.0\n0\n\n\n34\n3\n2\narrival_departure\ndepart\n51.483457\nNaN\n0\n\n\n35\n8\n2\nresource_use\ntreatment_begins\n51.483457\n3.0\n0\n\n\n36\n11\n2\narrival_departure\narrival\n71.026558\nNaN\n0\n\n\n37\n11\n2\nqueue\ntreatment_wait_begins\n71.026558\nNaN\n0\n\n\n38\n5\n2\nresource_use_end\ntreatment_complete\n77.447488\n1.0\n0\n\n\n39\n5\n2\narrival_departure\ndepart\n77.447488\nNaN\n0\n\n\n40\n9\n2\nresource_use\ntreatment_begins\n77.447488\n1.0\n0\n\n\n41\n6\n2\nresource_use_end\ntreatment_complete\n83.962251\n2.0\n0\n\n\n42\n6\n2\narrival_departure\ndepart\n83.962251\nNaN\n0\n\n\n43\n10\n2\nresource_use\ntreatment_begins\n83.962251\n2.0\n0\n\n\n44\n12\n2\narrival_departure\narrival\n87.458700\nNaN\n0\n\n\n45\n12\n2\nqueue\ntreatment_wait_begins\n87.458700\nNaN\n0\n\n\n46\n13\n2\narrival_departure\narrival\n87.465138\nNaN\n0\n\n\n47\n13\n2\nqueue\ntreatment_wait_begins\n87.465138\nNaN\n0\n\n\n48\n7\n2\nresource_use_end\ntreatment_complete\n95.498040\n4.0\n0\n\n\n49\n7\n2\narrival_departure\ndepart\n95.498040\nNaN\n0\n\n\n\n\n\n\n\n\nSTEP_SNAPSHOT_MAX = 45\nLIMIT_DURATION = g.sim_duration\nWRAP_QUEUES_AT = 15\n\n\nfull_patient_df = reshape_for_animations(\n    event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n    entity_col_name=\"patient\",\n    every_x_time_units=2,\n    step_snapshot_max=STEP_SNAPSHOT_MAX,\n    limit_duration=LIMIT_DURATION,\n    debug_mode=True\n    )\n\nfull_patient_df.head(15)\n\nIteration through time-unit-by-time-unit logs complete 11:26:36\nSnapshot df concatenation complete at 11:26:36\n\n\n\n\n\n\n\n\n\nindex\npatient\npathway\nevent_type\nevent\ntime\nresource_id\nrun\nrank\nsnapshot_time\nadditional\n\n\n\n\n0\n2\n1\n1\nresource_use\ntreatment_begins\n0.000000\n1.0\n1\n1.0\n0\nNaN\n\n\n1\n2\n1\n1\nresource_use\ntreatment_begins\n0.000000\n1.0\n1\n1.0\n2\nNaN\n\n\n2\n2\n1\n1\nresource_use\ntreatment_begins\n0.000000\n1.0\n1\n1.0\n4\nNaN\n\n\n3\n2\n1\n1\nresource_use\ntreatment_begins\n0.000000\n1.0\n1\n1.0\n6\nNaN\n\n\n4\n2\n1\n1\nresource_use\ntreatment_begins\n0.000000\n1.0\n1\n1.0\n8\nNaN\n\n\n5\n2\n1\n1\nresource_use\ntreatment_begins\n0.000000\n1.0\n1\n1.0\n10\nNaN\n\n\n6\n2\n1\n1\nresource_use\ntreatment_begins\n0.000000\n1.0\n1\n1.0\n12\nNaN\n\n\n7\n2\n1\n1\nresource_use\ntreatment_begins\n0.000000\n1.0\n1\n1.0\n14\nNaN\n\n\n8\n5\n2\n2\nresource_use\ntreatment_begins\n12.021043\n2.0\n1\n2.0\n14\nNaN\n\n\n9\n2\n1\n1\nresource_use\ntreatment_begins\n0.000000\n1.0\n1\n1.0\n16\nNaN\n\n\n10\n5\n2\n2\nresource_use\ntreatment_begins\n12.021043\n2.0\n1\n2.0\n16\nNaN\n\n\n11\n2\n1\n1\nresource_use\ntreatment_begins\n0.000000\n1.0\n1\n1.0\n18\nNaN\n\n\n12\n5\n2\n2\nresource_use\ntreatment_begins\n12.021043\n2.0\n1\n2.0\n18\nNaN\n\n\n13\n2\n1\n1\nresource_use\ntreatment_begins\n0.000000\n1.0\n1\n1.0\n20\nNaN\n\n\n14\n5\n2\n2\nresource_use\ntreatment_begins\n12.021043\n2.0\n1\n2.0\n20\nNaN\n\n\n\n\n\n\n\n\nevent_position_df = pd.DataFrame([\n                    {'event': 'arrival',\n                     'x':  50, 'y': 300,\n                     'label': \"Arrival\" },\n\n                    # Triage - minor and trauma\n                    {'event': 'treatment_wait_begins',\n                     'x':  205, 'y': 275,\n                     'label': \"Waiting for Treatment\"},\n\n                    {'event': 'treatment_begins',\n                     'x':  205, 'y': 175,\n                     'resource':'n_cubicles',\n                     'label': \"Being Treated\"},\n\n                    {'event': 'depart',\n                     'x':  270, 'y': 70,\n                     'label': \"Exit\"}\n\n                ])\n\n\nGenerate animation using the step-by-step functions\nUsing the three step-by-step functions allows us to intervene in the produced dataframe and manually take control of the icons in use.\nThis will allow us to show the high-priority patients with a unique icon so we can see their frequency and how they are handled in the final model.\n\nfull_patient_df_plus_pos = generate_animation_df(\n    full_entity_df=full_patient_df,\n    event_position_df=event_position_df,\n    entity_col_name=\"patient\",\n    wrap_queues_at=WRAP_QUEUES_AT,\n    step_snapshot_max=STEP_SNAPSHOT_MAX,\n    gap_between_entities=10,\n    gap_between_resources=10,\n    gap_between_queue_rows=30,\n    debug_mode=True\n    )\n\nfull_patient_df_plus_pos.sort_values(['patient', 'snapshot_time']).head(15)\n\nPlacement dataframe finished construction at 11:26:37\n\n\n\n\n\n\n\n\n\nindex\npatient\npathway\nevent_type\nevent\ntime\nresource_id\nrun\nrank\nsnapshot_time\nadditional\nx\ny_final\nlabel\nresource\nx_final\nrow\ny\nicon\n\n\n\n\n10186\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n0\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n10187\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n2\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n10188\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n4\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n10189\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n6\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n10190\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n8\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n10191\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n10\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n10192\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n12\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n10193\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n14\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n10194\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n16\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n10195\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n18\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n10196\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n20\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n10197\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n22\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n10198\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n24\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n10199\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n26\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n10200\n2\n1\n1\nresource_use\ntreatment_begins\n0.0\n1.0\n1\n1.0\n28\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n🧔🏼\n\n\n\n\n\n\n\n\ndef show_priority_icon(row):\n            if \"more\" not in row[\"icon\"]:\n                if row[\"pathway\"] == 1:\n                        return \"🚨\"\n                else:\n                    return row[\"icon\"]\n            else:\n                return row[\"icon\"]\n\n\nfull_patient_df_plus_pos = full_patient_df_plus_pos.assign(\n            icon=full_patient_df_plus_pos.apply(show_priority_icon, axis=1)\n            )\n\n\nfull_patient_df_plus_pos.head(15)\n\n\n\n\n\n\n\n\nindex\npatient\npathway\nevent_type\nevent\ntime\nresource_id\nrun\nrank\nsnapshot_time\nadditional\nx\ny_final\nlabel\nresource\nx_final\nrow\ny\nicon\n\n\n\n\n0\n13\n5\n2\nqueue\ntreatment_wait_begins\n37.024768\nNaN\n1\n1.0\n38\nNaN\n205\n275.0\nWaiting for Treatment\nNaN\n205.0\n0.0\nNaN\n👩🏿‍🦱\n\n\n1\n13\n5\n2\nqueue\ntreatment_wait_begins\n37.024768\nNaN\n1\n1.0\n40\nNaN\n205\n275.0\nWaiting for Treatment\nNaN\n205.0\n0.0\nNaN\n👩🏿‍🦱\n\n\n2\n18\n5\n2\nresource_use\ndepart\n41.226014\n1.0\n1\n1.0\n74\nNaN\n270\n70.0\nExit\nNaN\n270.0\n0.0\nNaN\n👩🏿‍🦱\n\n\n3\n18\n5\n2\nresource_use\ntreatment_begins\n41.226014\n1.0\n1\n4.0\n42\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n👩🏿‍🦱\n\n\n4\n18\n5\n2\nresource_use\ntreatment_begins\n41.226014\n1.0\n1\n4.0\n44\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n👩🏿‍🦱\n\n\n5\n18\n5\n2\nresource_use\ntreatment_begins\n41.226014\n1.0\n1\n4.0\n46\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n👩🏿‍🦱\n\n\n6\n18\n5\n2\nresource_use\ntreatment_begins\n41.226014\n1.0\n1\n3.0\n48\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n👩🏿‍🦱\n\n\n7\n18\n5\n2\nresource_use\ntreatment_begins\n41.226014\n1.0\n1\n3.0\n50\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n👩🏿‍🦱\n\n\n8\n18\n5\n2\nresource_use\ntreatment_begins\n41.226014\n1.0\n1\n3.0\n52\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n👩🏿‍🦱\n\n\n9\n18\n5\n2\nresource_use\ntreatment_begins\n41.226014\n1.0\n1\n3.0\n54\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n👩🏿‍🦱\n\n\n10\n18\n5\n2\nresource_use\ntreatment_begins\n41.226014\n1.0\n1\n3.0\n56\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n👩🏿‍🦱\n\n\n11\n18\n5\n2\nresource_use\ntreatment_begins\n41.226014\n1.0\n1\n3.0\n58\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n👩🏿‍🦱\n\n\n12\n18\n5\n2\nresource_use\ntreatment_begins\n41.226014\n1.0\n1\n3.0\n60\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n👩🏿‍🦱\n\n\n13\n18\n5\n2\nresource_use\ntreatment_begins\n41.226014\n1.0\n1\n3.0\n62\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n👩🏿‍🦱\n\n\n14\n18\n5\n2\nresource_use\ntreatment_begins\n41.226014\n1.0\n1\n3.0\n64\nNaN\n205\n175.0\nBeing Treated\nn_cubicles\n205.0\n0.0\nNaN\n👩🏿‍🦱\n\n\n\n\n\n\n\n\ngenerate_animation(\n        full_entity_df_plus_pos=full_patient_df_plus_pos.sort_values(['patient', 'snapshot_time']),\n        event_position_df= event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        debug_mode=True,\n        setup_mode=False,\n        include_play_button=True,\n        entity_icon_size=13,\n        resource_icon_size=15,\n        plotly_height=600,\n        frame_duration=800,\n        frame_transition_duration=200,\n        plotly_width=1000,\n        override_x_max=300,\n        override_y_max=500,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nOutput animation generation complete at 11:26:38\n\n\n        \n        \n        \n\n\n                                                    \n\n\n\n\nRerun, but using the all-in-one animation function (which will not show different priority icons)\n\nanimate_activity_log(\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        debug_mode=True,\n        setup_mode=False,\n        every_x_time_units=1,\n        include_play_button=True,\n        entity_icon_size=13,\n        resource_icon_size=15,\n        gap_between_entities=6,\n        gap_between_queue_rows=25,\n        plotly_height=600,\n        frame_duration=200,\n        plotly_width=1000,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=g.sim_duration,\n        wrap_queues_at=25,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nAnimation function called at 11:26:39\nIteration through time-unit-by-time-unit logs complete 11:26:41\nSnapshot df concatenation complete at 11:26:41\nReshaped animation dataframe finished construction at 11:26:41\nPlacement dataframe finished construction at 11:26:41\nOutput animation generation complete at 11:26:44\nTotal Time Elapsed: 5.11 seconds",
    "crumbs": [
      "SimPy Examples",
      "Visualising Entities with Different Priorities"
    ]
  },
  {
    "objectID": "examples/example_4_ciw/notes.html",
    "href": "examples/example_4_ciw/notes.html",
    "title": "vidigi",
    "section": "",
    "text": "This is adapted from the following repository: Monks, T., Harper, A., & Heather, A. (2023). Towards Sharing Tools, Artefacts, and Reproducible Simulation: a ciw model example (v1.0.1). Zenodo. https://doi.org/10.5281/zenodo.10051494\nSee here for the adaptation embedded within that repo: https://github.com/Bergam0t/ciw-example-animation/tree/main\nPlease also note this model runs ciw 2.x\nIt will not run with 3.x - but could theoretically be adapted to do so"
  },
  {
    "objectID": "examples/example_6_simplest_case_storewrapper/ex_6_simplest_case.html",
    "href": "examples/example_6_simplest_case_storewrapper/ex_6_simplest_case.html",
    "title": "Using the VidigiStore to Simplify Model Code Changes",
    "section": "",
    "text": "In vidigi 1.0.0, a new class VidigiStore has been added that can be used almost exactly like a resource - reducing the amount of rewriting required to incorporate vidigi into your model.\nThis allows us to use the pattern\nwith self.treatment_cubicles.request() as req:\n\n    treatment_resource = yield req\n\n    ### Continue all code in the indented portion that requires the resource, with the resource\n    ### automatically being returned to the store when the indented portion completes\nInstead of\ntreatment_resource = yield self.treatment_cubicles.get()\n\n### Continue all code that requires the resource\n\nself.treatment_cubicles.put(treatment_resource)\n(even though we are still using a Store behind the scenes)\nThis minimizes the syntax changes and rewriting that are required when converting an existing model built using resources to a vidigi-compatible state.\nWhen setting up the resources, we simply use the pattern\nfrom vidigi.resources import VidigiStore\n\n...\n\nself.treatment_cubicles = VidigiStore(\n    self.env,\n    num_resources=g.n_cubicles, # or wherever you are storing your resource counts\n    )\n\nfrom examples.example_6_simplest_case_storewrapper.ex_6_model_classes_with_vidigi_logging import Trial, g\nfrom vidigi.animation import animate_activity_log\nimport pandas as pd\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\nimport os\n\n\n\n\n\n\n\nView Imported Code, which has had logging steps added at the appropriate points in the ‘model’ class\n\n\n\n\n\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\nfrom sim_tools.distributions import Exponential, Lognormal\nfrom vidigi.resources import VidigiStore\n\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    '''\n    Create a scenario to parameterise the simulation model\n\n    Parameters:\n    -----------\n    random_number_set: int, optional (default=DEFAULT_RNG_SET)\n        Set to control the initial seeds of each stream of pseudo\n        random numbers used in the model.\n\n    n_cubicles: int\n        The number of treatment cubicles\n\n    trauma_treat_mean: float\n        Mean of the trauma cubicle treatment distribution (Lognormal)\n\n    trauma_treat_var: float\n        Variance of the trauma cubicle treatment distribution (Lognormal)\n\n    arrival_rate: float\n        Set the mean of the exponential distribution that is used to sample the\n        inter-arrival time of patients\n\n    sim_duration: int\n        The number of time units the simulation will run for\n\n    number_of_runs: int\n        The number of times the simulation will be run with different random number streams\n\n    '''\n    random_number_set = 42\n\n    n_cubicles = 4\n    trauma_treat_mean = 40\n    trauma_treat_var = 5\n\n    arrival_rate = 5\n\n    sim_duration = 600\n    number_of_runs = 100\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    '''\n    Class defining details for a patient entity\n    '''\n    def __init__(self, p_id):\n        '''\n        Constructor method\n\n        Params:\n        -----\n        identifier: int\n            a numeric identifier for the patient.\n        '''\n        self.identifier = p_id\n        self.arrival = -np.inf\n        self.wait_treat = -np.inf\n        self.total_time = -np.inf\n        self.treat_duration = -np.inf\n\n# Class representing our model of the clinic.\nclass Model:\n    '''\n    Simulates the simplest minor treatment process for a patient\n\n    1. Arrive\n    2. Examined/treated by nurse when one available\n    3. Discharged\n    '''\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        self.event_log = []\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        self.patients = []\n\n        # Create our resources\n        self.init_resources()\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Queue Time Cubicle\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_cubicle = 0\n\n        self.patient_inter_arrival_dist = Exponential(mean = g.arrival_rate,\n                                                      random_seed = self.run_number*g.random_number_set)\n        self.treat_dist = Lognormal(mean = g.trauma_treat_mean,\n                                    stdev = g.trauma_treat_var,\n                                    random_seed = self.run_number*g.random_number_set)\n\n    def init_resources(self):\n        '''\n        Init the number of resources\n        and store in the arguments container object\n\n        Resource list:\n            1. Nurses/treatment bays (same thing in this model)\n\n        '''\n        self.treatment_cubicles = VidigiStore(self.env, num_resources=g.n_cubicles)\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            # Store patient in list for later easy access\n            self.patients.append(p)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = self.patient_inter_arrival_dist.sample()\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        self.arrival = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Simplest',\n             'event_type': 'arrival_departure',\n             'event': 'arrival',\n             'time': self.env.now}\n        )\n\n        # request examination resource\n        start_wait = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Simplest',\n             'event': 'treatment_wait_begins',\n             'event_type': 'queue',\n             'time': self.env.now}\n        )\n\n        # Seize a treatment resource when available\n        with self.treatment_cubicles.request() as req:\n            treatment_resource = yield req\n            # record the waiting time for registration\n            self.wait_treat = self.env.now - start_wait\n            self.event_log.append(\n                {'patient': patient.identifier,\n                    'pathway': 'Simplest',\n                    'event': 'treatment_begins',\n                    'event_type': 'resource_use',\n                    'time': self.env.now,\n                    'resource_id': treatment_resource.id_attribute\n                    }\n            )\n\n            # sample treatment duration\n            self.treat_duration = self.treat_dist.sample()\n            yield self.env.timeout(self.treat_duration)\n\n            self.event_log.append(\n                {'patient': patient.identifier,\n                    'pathway': 'Simplest',\n                    'event': 'treatment_complete',\n                    'event_type': 'resource_use_end',\n                    'time': self.env.now,\n                    'resource_id': treatment_resource.id_attribute}\n            )\n\n\n        # total time in system\n        self.total_time = self.env.now - self.arrival\n        self.event_log.append(\n            {'patient': patient.identifier,\n            'pathway': 'Simplest',\n            'event': 'depart',\n            'event_type': 'arrival_departure',\n            'time': self.env.now}\n        )\n\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_cubicle = self.results_df[\"Queue Time Cubicle\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        self.event_log = pd.DataFrame(self.event_log)\n\n        self.event_log[\"run\"] = self.run_number\n\n        return {'results': self.results_df, 'event_log': self.event_log}\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Arrivals\"] = [0]\n        self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n        self.all_event_logs = []\n\n    # Method to run a trial\n    def run_trial(self):\n        print(f\"{g.n_cubicles} nurses\")\n        print(\"\") ## Print a blank line\n\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            random.seed(run)\n\n            my_model = Model(run)\n            model_outputs = my_model.run()\n            patient_level_results = model_outputs[\"results\"]\n            event_log = model_outputs[\"event_log\"]\n\n            self.df_trial_results.loc[run] = [\n                len(patient_level_results),\n                my_model.mean_q_time_cubicle,\n            ]\n\n            # print(event_log)\n\n            self.all_event_logs.append(event_log)\n\n        self.all_event_logs = pd.concat(self.all_event_logs)\n\n\n\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\n4 nurses\n\n\n\n\nmy_trial.all_event_logs.head(50)\n\n\n\n\n\n\n\n\npatient\npathway\nevent_type\nevent\ntime\nresource_id\nrun\n\n\n\n\n0\n1\nSimplest\narrival_departure\narrival\n0.000000\nNaN\n0\n\n\n1\n1\nSimplest\nqueue\ntreatment_wait_begins\n0.000000\nNaN\n0\n\n\n2\n1\nSimplest\nresource_use\ntreatment_begins\n0.000000\n1.0\n0\n\n\n3\n2\nSimplest\narrival_departure\narrival\n3.399660\nNaN\n0\n\n\n4\n2\nSimplest\nqueue\ntreatment_wait_begins\n3.399660\nNaN\n0\n\n\n5\n2\nSimplest\nresource_use\ntreatment_begins\n3.399660\n2.0\n0\n\n\n6\n3\nSimplest\narrival_departure\narrival\n8.497645\nNaN\n0\n\n\n7\n3\nSimplest\nqueue\ntreatment_wait_begins\n8.497645\nNaN\n0\n\n\n8\n3\nSimplest\nresource_use\ntreatment_begins\n8.497645\n3.0\n0\n\n\n9\n4\nSimplest\narrival_departure\narrival\n8.596678\nNaN\n0\n\n\n10\n4\nSimplest\nqueue\ntreatment_wait_begins\n8.596678\nNaN\n0\n\n\n11\n4\nSimplest\nresource_use\ntreatment_begins\n8.596678\n4.0\n0\n\n\n12\n5\nSimplest\narrival_departure\narrival\n8.608025\nNaN\n0\n\n\n13\n5\nSimplest\nqueue\ntreatment_wait_begins\n8.608025\nNaN\n0\n\n\n14\n6\nSimplest\narrival_departure\narrival\n11.359739\nNaN\n0\n\n\n15\n6\nSimplest\nqueue\ntreatment_wait_begins\n11.359739\nNaN\n0\n\n\n16\n7\nSimplest\narrival_departure\narrival\n19.509442\nNaN\n0\n\n\n17\n7\nSimplest\nqueue\ntreatment_wait_begins\n19.509442\nNaN\n0\n\n\n18\n8\nSimplest\narrival_departure\narrival\n22.877356\nNaN\n0\n\n\n19\n8\nSimplest\nqueue\ntreatment_wait_begins\n22.877356\nNaN\n0\n\n\n20\n9\nSimplest\narrival_departure\narrival\n26.653863\nNaN\n0\n\n\n21\n9\nSimplest\nqueue\ntreatment_wait_begins\n26.653863\nNaN\n0\n\n\n22\n1\nSimplest\nresource_use_end\ntreatment_complete\n40.317385\n1.0\n0\n\n\n23\n1\nSimplest\narrival_departure\ndepart\n40.317385\nNaN\n0\n\n\n24\n5\nSimplest\nresource_use\ntreatment_begins\n40.317385\n1.0\n0\n\n\n25\n10\nSimplest\narrival_departure\narrival\n40.737793\nNaN\n0\n\n\n26\n10\nSimplest\nqueue\ntreatment_wait_begins\n40.737793\nNaN\n0\n\n\n27\n2\nSimplest\nresource_use_end\ntreatment_complete\n42.443230\n2.0\n0\n\n\n28\n2\nSimplest\narrival_departure\ndepart\n42.443230\nNaN\n0\n\n\n29\n6\nSimplest\nresource_use\ntreatment_begins\n42.443230\n2.0\n0\n\n\n30\n4\nSimplest\nresource_use_end\ntreatment_complete\n48.809628\n4.0\n0\n\n\n31\n4\nSimplest\narrival_departure\ndepart\n48.809628\nNaN\n0\n\n\n32\n7\nSimplest\nresource_use\ntreatment_begins\n48.809628\n4.0\n0\n\n\n33\n3\nSimplest\nresource_use_end\ntreatment_complete\n51.483457\n3.0\n0\n\n\n34\n3\nSimplest\narrival_departure\ndepart\n51.483457\nNaN\n0\n\n\n35\n8\nSimplest\nresource_use\ntreatment_begins\n51.483457\n3.0\n0\n\n\n36\n11\nSimplest\narrival_departure\narrival\n71.026558\nNaN\n0\n\n\n37\n11\nSimplest\nqueue\ntreatment_wait_begins\n71.026558\nNaN\n0\n\n\n38\n5\nSimplest\nresource_use_end\ntreatment_complete\n77.447488\n1.0\n0\n\n\n39\n5\nSimplest\narrival_departure\ndepart\n77.447488\nNaN\n0\n\n\n40\n9\nSimplest\nresource_use\ntreatment_begins\n77.447488\n1.0\n0\n\n\n41\n6\nSimplest\nresource_use_end\ntreatment_complete\n83.962251\n2.0\n0\n\n\n42\n6\nSimplest\narrival_departure\ndepart\n83.962251\nNaN\n0\n\n\n43\n10\nSimplest\nresource_use\ntreatment_begins\n83.962251\n2.0\n0\n\n\n44\n12\nSimplest\narrival_departure\narrival\n87.458700\nNaN\n0\n\n\n45\n12\nSimplest\nqueue\ntreatment_wait_begins\n87.458700\nNaN\n0\n\n\n46\n13\nSimplest\narrival_departure\narrival\n87.465138\nNaN\n0\n\n\n47\n13\nSimplest\nqueue\ntreatment_wait_begins\n87.465138\nNaN\n0\n\n\n48\n7\nSimplest\nresource_use_end\ntreatment_complete\n95.498040\n4.0\n0\n\n\n49\n7\nSimplest\narrival_departure\ndepart\n95.498040\nNaN\n0\n\n\n\n\n\n\n\n\nevent_position_df = pd.DataFrame([\n                    {'event': 'arrival',\n                     'x':  50, 'y': 300,\n                     'label': \"Arrival\" },\n\n                    # Triage - minor and trauma\n                    {'event': 'treatment_wait_begins',\n                     'x':  205, 'y': 275,\n                     'label': \"Waiting for Treatment\"},\n\n                    {'event': 'treatment_begins',\n                     'x':  205, 'y': 175,\n                     'resource':'n_cubicles',\n                     'label': \"Being Treated\"},\n\n                    {'event': 'depart',\n                     'x':  270, 'y': 70,\n                     'label': \"Exit\"}\n\n                ])\n\n\nanimate_activity_log(\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        debug_mode=True,\n        setup_mode=False,\n        every_x_time_units=1,\n        include_play_button=True,\n        entity_icon_size=16,\n        text_size=20,\n        gap_between_entities=6,\n        gap_between_queue_rows=25,\n        plotly_height=600,\n        frame_duration=200,\n        plotly_width=1000,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=g.sim_duration,\n        wrap_queues_at=25,\n        step_snapshot_max=125,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nAnimation function called at 11:57:56\nIteration through time-unit-by-time-unit logs complete 11:57:59\nSnapshot df concatenation complete at 11:57:59\nReshaped animation dataframe finished construction at 11:57:59\nPlacement dataframe finished construction at 11:57:59\nOutput animation generation complete at 11:58:02\nTotal Time Elapsed: 5.72 seconds",
    "crumbs": [
      "SimPy Examples",
      "Using the VidigiStore to Simplify Model Code Changes"
    ]
  },
  {
    "objectID": "examples/example_8_wide_resource_spacing/ex_8_model.html",
    "href": "examples/example_8_wide_resource_spacing/ex_8_model.html",
    "title": "Creative Layouts - Single Hospital Ward Example",
    "section": "",
    "text": "import numpy as np\nimport pandas as pd\n\nfrom examples.example_8_wide_resource_spacing.ex_8_model_classes import g, Trial\n\nfrom vidigi.animation import animate_activity_log\n\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\n\n\nclinic_simulation = Trial()\n\n\nclinic_simulation.trial_results\n\n\n\n\n\n\n\n\nentity_id\nevent_type\nevent\ntime\npathway\nrun_number\ntimestamp\nresource_id\n\n\n\n\n0\n1\narrival_departure\narrival\n0.000000\nNone\n1\nNone\nNaN\n\n\n1\n1\nqueue\nbed_wait_begins\n0.000000\nNone\n1\nNone\nNaN\n\n\n2\n1\nresource_use\nstay_begins\n0.000000\nNone\n1\nNone\n1.0\n\n\n3\n2\narrival_departure\narrival\n2.337500\nNone\n1\nNone\nNaN\n\n\n4\n2\nqueue\nbed_wait_begins\n2.337500\nNone\n1\nNone\nNaN\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n2272\n453\nresource_use_end\nstay_complete\n8719.027185\nNone\n100\nNone\n2.0\n\n\n2273\n453\narrival_departure\ndepart\n8719.027185\nNone\n100\nNone\nNaN\n\n\n2274\n457\narrival_departure\narrival\n8719.147321\nNone\n100\nNone\nNaN\n\n\n2275\n457\nqueue\nbed_wait_begins\n8719.147321\nNone\n100\nNone\nNaN\n\n\n2276\n457\nresource_use\nstay_begins\n8719.147321\nNone\n100\nNone\n1.0\n\n\n\n\n242708 rows × 8 columns\n\n\n\n\nevent_position_df = pd.DataFrame([\n                    {'event': 'arrival',\n                     'x':  50, 'y': 800,\n                     'label': \"Arrival\" },\n\n                    # Triage - minor and trauma\n                    {'event': 'bed_wait_begins',\n                     'x':  205, 'y': 700,\n                     'label': \"Waiting for Bed\"},\n\n                    {'event': 'stay_begins',\n                     'x':  205, 'y': 175,\n                     'resource':'number_of_beds',\n                     'label': \"In Ward\"},\n\n                    {'event': 'depart',\n                     'x':  270, 'y': 70,\n                     'label': \"Exit\"}\n\n                ])\n\n\nanimate_activity_log(\n        event_log=clinic_simulation.trial_results[clinic_simulation.trial_results['run_number']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        # Key animation prep parameters\n        every_x_time_units=6,\n        simulation_time_unit=\"hours\",\n        limit_duration=g.sim_duration,\n        step_snapshot_max=125,\n        # Animation display parameters\n        time_display_units=\"dhm\",\n        include_play_button=True,\n        setup_mode=True,\n        debug_mode=True,\n        frame_duration=200,\n        # Text parameters\n        display_stage_labels=True,\n        text_size=20,\n        # Entity and queue size and spacing\n        entity_icon_size=20,\n        wrap_queues_at=25,\n        gap_between_entities=6,\n        gap_between_queue_rows=30,\n        # Resource size and spacing\n        gap_between_resources=150,\n        gap_between_resource_rows=100,\n        resource_icon_size=40,\n        wrap_resources_at=2,\n        custom_resource_icon='🛏️',\n        # Plot size\n        plotly_height=600,\n        plotly_width=1000,\n        # Internal plot coordinates\n        override_x_max=300,\n        override_y_max=900,\n        )\n\nAnimation function called at 12:02:44\nIteration through time-unit-by-time-unit logs complete 12:02:51\nSnapshot df concatenation complete at 12:02:51\nReshaped animation dataframe finished construction at 12:02:51\nPlacement dataframe finished construction at 12:02:51\nOutput animation generation complete at 12:02:57\nTotal Time Elapsed: 12.89 seconds",
    "crumbs": [
      "SimPy Examples",
      "Creative Layouts - Single Hospital Ward Example"
    ]
  },
  {
    "objectID": "examples/feat_changing_sim_time/feat_changing_sim_time.html",
    "href": "examples/feat_changing_sim_time/feat_changing_sim_time.html",
    "title": "Feature Breakdown: Changing how the date and time are displayed",
    "section": "",
    "text": "We can change the start time of our simulation to best reflect our simulation’s parameters.\n\nfrom examples.example_6_simplest_case_storewrapper.ex_6_model_classes_with_vidigi_logging import Trial, g\nfrom vidigi.animation import animate_activity_log\nfrom vidigi.utils import EventPosition, create_event_position_df\nimport pandas as pd\nimport plotly.io as pio\npio.renderers.default = \"notebook\"\nimport os\n\n\n\n\n\n\n\nView Imported Code, which has had logging steps added at the appropriate points in the ‘model’ class\n\n\n\n\n\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\nfrom sim_tools.distributions import Exponential, Lognormal\nfrom vidigi.resources import VidigiStore\n\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    '''\n    Create a scenario to parameterise the simulation model\n\n    Parameters:\n    -----------\n    random_number_set: int, optional (default=DEFAULT_RNG_SET)\n        Set to control the initial seeds of each stream of pseudo\n        random numbers used in the model.\n\n    n_cubicles: int\n        The number of treatment cubicles\n\n    trauma_treat_mean: float\n        Mean of the trauma cubicle treatment distribution (Lognormal)\n\n    trauma_treat_var: float\n        Variance of the trauma cubicle treatment distribution (Lognormal)\n\n    arrival_rate: float\n        Set the mean of the exponential distribution that is used to sample the\n        inter-arrival time of patients\n\n    sim_duration: int\n        The number of time units the simulation will run for\n\n    number_of_runs: int\n        The number of times the simulation will be run with different random number streams\n\n    '''\n    random_number_set = 42\n\n    n_cubicles = 4\n    trauma_treat_mean = 40\n    trauma_treat_var = 5\n\n    arrival_rate = 5\n\n    sim_duration = 600\n    number_of_runs = 100\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    '''\n    Class defining details for a patient entity\n    '''\n    def __init__(self, p_id):\n        '''\n        Constructor method\n\n        Params:\n        -----\n        identifier: int\n            a numeric identifier for the patient.\n        '''\n        self.identifier = p_id\n        self.arrival = -np.inf\n        self.wait_treat = -np.inf\n        self.total_time = -np.inf\n        self.treat_duration = -np.inf\n\n# Class representing our model of the clinic.\nclass Model:\n    '''\n    Simulates the simplest minor treatment process for a patient\n\n    1. Arrive\n    2. Examined/treated by nurse when one available\n    3. Discharged\n    '''\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        self.event_log = []\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        self.patients = []\n\n        # Create our resources\n        self.init_resources()\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Queue Time Cubicle\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_cubicle = 0\n\n        self.patient_inter_arrival_dist = Exponential(mean = g.arrival_rate,\n                                                      random_seed = self.run_number*g.random_number_set)\n        self.treat_dist = Lognormal(mean = g.trauma_treat_mean,\n                                    stdev = g.trauma_treat_var,\n                                    random_seed = self.run_number*g.random_number_set)\n\n    def init_resources(self):\n        '''\n        Init the number of resources\n        and store in the arguments container object\n\n        Resource list:\n            1. Nurses/treatment bays (same thing in this model)\n\n        '''\n        self.treatment_cubicles = VidigiStore(self.env, num_resources=g.n_cubicles)\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            # Store patient in list for later easy access\n            self.patients.append(p)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = self.patient_inter_arrival_dist.sample()\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        self.arrival = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Simplest',\n             'event_type': 'arrival_departure',\n             'event': 'arrival',\n             'time': self.env.now}\n        )\n\n        # request examination resource\n        start_wait = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Simplest',\n             'event': 'treatment_wait_begins',\n             'event_type': 'queue',\n             'time': self.env.now}\n        )\n\n        # Seize a treatment resource when available\n        with self.treatment_cubicles.request() as req:\n            treatment_resource = yield req\n            # record the waiting time for registration\n            self.wait_treat = self.env.now - start_wait\n            self.event_log.append(\n                {'patient': patient.identifier,\n                    'pathway': 'Simplest',\n                    'event': 'treatment_begins',\n                    'event_type': 'resource_use',\n                    'time': self.env.now,\n                    'resource_id': treatment_resource.id_attribute\n                    }\n            )\n\n            # sample treatment duration\n            self.treat_duration = self.treat_dist.sample()\n            yield self.env.timeout(self.treat_duration)\n\n            self.event_log.append(\n                {'patient': patient.identifier,\n                    'pathway': 'Simplest',\n                    'event': 'treatment_complete',\n                    'event_type': 'resource_use_end',\n                    'time': self.env.now,\n                    'resource_id': treatment_resource.id_attribute}\n            )\n\n\n        # total time in system\n        self.total_time = self.env.now - self.arrival\n        self.event_log.append(\n            {'patient': patient.identifier,\n            'pathway': 'Simplest',\n            'event': 'depart',\n            'event_type': 'arrival_departure',\n            'time': self.env.now}\n        )\n\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_cubicle = self.results_df[\"Queue Time Cubicle\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        self.event_log = pd.DataFrame(self.event_log)\n\n        self.event_log[\"run\"] = self.run_number\n\n        return {'results': self.results_df, 'event_log': self.event_log}\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Arrivals\"] = [0]\n        self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n        self.all_event_logs = []\n\n    # Method to run a trial\n    def run_trial(self):\n        print(f\"{g.n_cubicles} nurses\")\n        print(\"\") ## Print a blank line\n\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            random.seed(run)\n\n            my_model = Model(run)\n            model_outputs = my_model.run()\n            patient_level_results = model_outputs[\"results\"]\n            event_log = model_outputs[\"event_log\"]\n\n            self.df_trial_results.loc[run] = [\n                len(patient_level_results),\n                my_model.mean_q_time_cubicle,\n            ]\n\n            # print(event_log)\n\n            self.all_event_logs.append(event_log)\n\n        self.all_event_logs = pd.concat(self.all_event_logs)\n\n\n\n\ng.sim_duration = 60 * 24 * 2 # 2 days (using unit of minutes)\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\n4 nurses\n\n\n\n\nSIM_START_DATE = \"2024-01-01\"\nSIM_START_TIME = \"08:00:00\"\nSTEP_SNAPSHOT_MAX = 45\nLIMIT_DURATION = g.sim_duration\nWRAP_QUEUES_AT = 15\n\n\n# Create a list of EventPosition objects\nevent_position_df = create_event_position_df([\n    EventPosition(event='arrival', x=50, y=300, label=\"Arrival\"),\n    EventPosition(event='treatment_wait_begins', x=205, y=275, label=\"Waiting for Treatment\"),\n    EventPosition(event='treatment_begins', x=205, y=175, resource='n_cubicles', label=\"Being Treated\"),\n    EventPosition(event='depart', x=270, y=70, label=\"Exit\")\n])\n\n\nRun using the all-in-one animation function\nLet’s first look at the output if we don’t use the start date or ask for the data to displayed in days, hours and minutes.\n\nanimate_activity_log(\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        every_x_time_units=10,\n        gap_between_entities=6,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=g.sim_duration,\n        wrap_queues_at=25,\n        step_snapshot_max=100,\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n        debug_mode=True\n    )\n\nAnimation function called at 12:32:48\nIteration through time-unit-by-time-unit logs complete 12:32:49\nSnapshot df concatenation complete at 12:32:50\nReshaped animation dataframe finished construction at 12:32:50\nPlacement dataframe finished construction at 12:32:50\nOutput animation generation complete at 12:32:51\nTotal Time Elapsed: 3.06 seconds\n\n\n        \n        \n        \n\n\n                                                    \n\n\nNext, let’s see what happens when we request it in days, hours and minutes using the time_display_units parameter, but don’t specify a simulation start date.\nThe default behaviour is that it will choose a date 6 months from the date the code is run, and set the starting time to 00:00:00 (midnight).\n\nanimate_activity_log(\n        time_display_units=\"dhm\",\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        entity_col_name=\"patient\",\n        scenario=g(),\n        every_x_time_units=10,\n        gap_between_entities=6,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=g.sim_duration,\n        wrap_queues_at=25,\n        step_snapshot_max=100,\n        display_stage_labels=False,\n        debug_mode=True,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nAnimation function called at 12:32:52\nIteration through time-unit-by-time-unit logs complete 12:32:53\nSnapshot df concatenation complete at 12:32:53\nReshaped animation dataframe finished construction at 12:32:53\nPlacement dataframe finished construction at 12:32:53\nOutput animation generation complete at 12:32:55\nTotal Time Elapsed: 3.19 seconds\n\n\n                                                    \n\n\nLet’s now provide a start date of the 1st of January 2024.\nWe can see that with a start date provided but no start time, the simulation clock will start at 00:00.\n\nanimate_activity_log(\n        start_date=SIM_START_DATE,\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        entity_col_name=\"patient\",\n        every_x_time_units=10,\n        include_play_button=True,\n        gap_between_entities=6,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=g.sim_duration,\n        wrap_queues_at=25,\n        step_snapshot_max=100,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\n                                                    \n\n\nFinally, we’ll provide a start date for the simulation to display too.\n\nanimate_activity_log(\n        entity_col_name=\"patient\",\n        time_display_units=\"dhm\",\n        start_date=SIM_START_DATE,\n        start_time=SIM_START_TIME,\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        every_x_time_units=10,\n        gap_between_entities=6,\n        plotly_height=700,\n        frame_duration=200,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=g.sim_duration,\n        wrap_queues_at=25,\n        step_snapshot_max=100,\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\n                                                    \n\n\nThere are a wide range of different acceptable parameters for the time_display_units parameter.\nThese include\n\n‘dhms’ : Day Month Year + HH:MM:SS (e.g., “06 June 2025:23:45”)\n‘dhms_ampm’ : Same as ‘dhms’, but in 12-hour format with AM/PM (e.g., “06 June 2025:23:45 PM”)\n‘dhm’ : Day Month Year + HH:MM (e.g., “06 June 2025:23”)\n‘dhm_ampm’ : 12-hour format with AM/PM (e.g., “06 June 2025:23 PM”)\n‘dh’ : Day Month Year + HH (e.g., “06 June 2025”)\n‘dh_ampm’ : 12-hour format with AM/PM (e.g., “06 June 2025 PM”)\n‘d’ : Full weekday and date (e.g., “Friday 06 June 2025”)\n‘m’ : Month and year (e.g., “June 2025”)\n‘y’ : Year only (e.g., “2025”)\n‘day_clock’ or ‘simulation_day_clock’: Show simulation-relative day and time (e.g., “Simulation Day 3:15”)\n‘day_clock_ampm’ or ‘simulation_day_clock_ampm’: Same as above, but time is shown in 12-hour clock with AM/PM (e.g., “Simulation Day 3:15 PM”)\n\nAlternatively, you can supply a custom strftime format string (e.g., ‘%Y-%m-%d %H’) to control the display manually.\nLet’s have a look at day_clock:\n\nanimate_activity_log(\n        simulation_time_unit=\"minutes\",\n        time_display_units=\"day_clock\",\n        entity_col_name=\"patient\",\n        start_date=SIM_START_DATE,\n        start_time=SIM_START_TIME,\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df=event_position_df,\n        scenario=g(),\n        every_x_time_units=10, # Every minute\n        gap_between_entities=6,\n        plotly_height=700,\n        frame_duration=1000,\n        frame_transition_duration=1000,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=g.sim_duration,\n        wrap_queues_at=25,\n        step_snapshot_max=100,\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\n                                                    \n\n\nAnd ‘day_clock_ampm’.\nNote that the suffix _ampm can be added to any of dhms, dhm, dh, and day_clock so that you display the time in a 12 hour format with AM/PM instead of the default 24 hour clock.\n\nanimate_activity_log(\n        simulation_time_unit=\"minutes\",\n        time_display_units=\"day_clock_ampm\",\n        entity_col_name=\"patient\",\n        start_date=SIM_START_DATE,\n        start_time=SIM_START_TIME,\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df=event_position_df,\n        scenario=g(),\n        every_x_time_units=10, # Every minute\n        gap_between_entities=6,\n        plotly_height=700,\n        frame_duration=1000,\n        frame_transition_duration=1000,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=g.sim_duration,\n        wrap_queues_at=25,\n        step_snapshot_max=100,\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\n                                                    \n\n\n\n\nChanging the timescale\nWe could also display the simulation at a daily level. Let’s imagine our simulation represents the number of patients being seen per day instead of per minute.\nNOTE: These example animations won’t make a lot of sense as the underlying simulation doesn’t really make sense at a higher resolution than daily! but it gives you some idea of how these parameters can change and their impact on how dates and times are displayed.\n\nanimate_activity_log(\n        simulation_time_unit=\"days\",\n        time_display_units=\"d\",\n        start_date=SIM_START_DATE,\n        entity_col_name=\"patient\",\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        every_x_time_units=10,\n        gap_between_entities=6,\n        plotly_height=700,\n        frame_duration=2000,\n        frame_transition_duration=1000,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=g.sim_duration,\n        wrap_queues_at=25,\n        step_snapshot_max=100,\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\n                                                    \n\n\nOr per month…\n\nanimate_activity_log(\n        simulation_time_unit=\"months\",\n        time_display_units=\"m\",\n        entity_col_name=\"patient\",\n        start_date=SIM_START_DATE,\n        start_time=SIM_START_TIME,\n        event_log=my_trial.all_event_logs[my_trial.all_event_logs['run']==1],\n        event_position_df=event_position_df,\n        scenario=g(),\n        every_x_time_units=10, # Every day\n        gap_between_entities=6,\n        plotly_height=700,\n        frame_duration=1000,\n        frame_transition_duration=1000,\n        plotly_width=1200,\n        override_x_max=300,\n        override_y_max=500,\n        limit_duration=g.sim_duration,\n        wrap_queues_at=25,\n        step_snapshot_max=100,\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\n                                                    \n\n\nOr even per year (though we don’t have a simulation set up to demo this at this time!).",
    "crumbs": [
      "Feature Breakdowns",
      "Feature Breakdown: Changing how the date and time are displayed"
    ]
  },
  {
    "objectID": "examples/feat_vidigi_logging_class/feat_example_logging_class.html",
    "href": "examples/feat_vidigi_logging_class/feat_example_logging_class.html",
    "title": "Feature Example: Event Logging Helpers",
    "section": "",
    "text": "version 0.5.0 of vidigi added an EventLogger class, with various helper methods to simplify the process of generating the event logs that vidigi requires for the animation process.\nIn this notebook, we will add this logging into a simulation, also making use of the VidigiStore and its .populate() method to generate resources that have an ID attribute, allowing the vidigi animations to show individuals using a consistent resource.\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\n\nfrom sim_tools.distributions import Exponential, Lognormal\n\nfrom vidigi.resources import VidigiStore\nfrom vidigi.logging import EventLogger\nfrom vidigi.animation import animate_activity_log\nfrom vidigi.utils import EventPosition, create_event_position_df\n\nimport plotly.io as pio\npio.renderers.default = \"notebook\"",
    "crumbs": [
      "Details",
      "Feature Example: Event Logging Helpers"
    ]
  },
  {
    "objectID": "examples/feat_vidigi_logging_class/feat_example_logging_class.html#more-complex-example---multiple-resource-types-branching",
    "href": "examples/feat_vidigi_logging_class/feat_example_logging_class.html#more-complex-example---multiple-resource-types-branching",
    "title": "Feature Example: Event Logging Helpers",
    "section": "More Complex example - Multiple Resource Types, Branching",
    "text": "More Complex example - Multiple Resource Types, Branching\n\n# Import additional required distributions\nfrom sim_tools.distributions import Normal, Bernoulli, Uniform\n\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    '''\n    Create a scenario to parameterise the simulation model\n\n    Parameters:\n    -----------\n    random_number_set: int, optional (default=DEFAULT_RNG_SET)\n        Set to control the initial seeds of each stream of pseudo\n        random numbers used in the model.\n\n    n_triage: int\n        The number of triage cubicles\n\n    n_reg: int\n        The number of registration clerks\n\n    n_exam: int\n        The number of examination rooms\n\n    n_trauma: int\n        The number of trauma bays for stablisation\n\n    n_cubicles_non_trauma_treat: int\n        The number of non-trauma treatment cubicles\n\n    n_cubicles_trauma_treat: int\n        The number of trauma treatment cubicles\n\n    triage_mean: float\n        Mean duration of the triage distribution (Exponential)\n\n    reg_mean: float\n        Mean duration of the registration distribution (Lognormal)\n\n    reg_var: float\n        Variance of the registration distribution (Lognormal)\n\n    exam_mean: float\n        Mean of the examination distribution (Normal)\n\n    exam_var: float\n        Variance of the examination distribution (Normal)\n\n    trauma_mean: float\n        Mean of the trauma stabilisation distribution (Exponential)\n\n    trauma_treat_mean: float\n        Mean of the trauma cubicle treatment distribution (Lognormal)\n\n    trauma_treat_var: float\n        Variance of the trauma cubicle treatment distribution (Lognormal)\n\n    non_trauma_treat_mean: float\n        Mean of the non trauma treatment distribution\n\n    non_trauma_treat_var: float\n        Variance of the non trauma treatment distribution\n\n    non_trauma_treat_p: float\n        Probability non trauma patient requires treatment\n\n    prob_trauma: float\n        probability that a new arrival is a trauma patient.\n    '''\n    random_number_set = 42\n\n    n_triage=2\n    n_reg=2\n    n_exam=3\n    n_trauma=4\n    n_cubicles_non_trauma_treat=4\n    n_cubicles_trauma_treat=5\n\n    triage_mean=6\n    reg_mean=8\n    reg_var=2\n    exam_mean=16\n    exam_var=3\n    trauma_mean=90\n    trauma_treat_mean=30\n    trauma_treat_var=4\n    non_trauma_treat_mean=13.3\n    non_trauma_treat_var=2\n\n    non_trauma_treat_p=0.6\n    prob_trauma=0.12\n\n    arrival_df=\"ed_arrivals.csv\"\n\n    sim_duration = 600\n    number_of_runs = 100\n\n\nclass Patient:\n    '''\n    Class defining details for a patient entity\n    '''\n    def __init__(self, p_id):\n        '''\n        Constructor method\n\n        Params:\n        -----\n        identifier: int\n            a numeric identifier for the patient.\n        '''\n        self.identifier = p_id\n\n        # Time of arrival in model/at centre\n        self.arrival = -np.inf\n        # Total time in pathway\n        self.total_time = -np.inf\n\n        # Shared waits\n        self.wait_triage = -np.inf\n        self.wait_reg = -np.inf\n        self.wait_treat = -np.inf\n        # Non-trauma pathway - examination wait\n        self.wait_exam = -np.inf\n        # Trauma pathway - stabilisation wait\n        self.wait_trauma = -np.inf\n\n        # Shared durations\n        self.triage_duration = -np.inf\n        self.reg_duration = -np.inf\n        self.treat_duration = -np.inf\n\n        # Non-trauma pathway - examination duration\n        self.exam_duration = -np.inf\n        # Trauma pathway - stabilisation duration\n        self.trauma_duration = -np.inf\n\n\n# Class representing our model of the clinic.\nclass Model:\n    '''\n    Simulates the simplest minor treatment process for a patient\n\n    1. Arrive\n    2. Examined/treated by nurse when one available\n    3. Discharged\n    '''\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n        # Store the passed in run number\n        self.run_number = run_number\n\n        self.logger = EventLogger(env=self.env, run_number=self.run_number)\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        self.trauma_patients = []\n        self.non_trauma_patients = []\n\n        # Create our resources\n        self.init_resources()\n        # Create our distributions\n        self.init_distributions()\n\n    def init_distributions(self):\n        # Create distributions\n\n        # Triage duration\n        self.triage_dist = Exponential(g.triage_mean,\n                                    random_seed=self.run_number*g.random_number_set)\n\n        # Registration duration (non-trauma only)\n        self.reg_dist = Lognormal(g.reg_mean,\n                                np.sqrt(g.reg_var),\n                                random_seed=self.run_number*g.random_number_set)\n\n        # Evaluation (non-trauma only)\n        self.exam_dist = Normal(g.exam_mean,\n                                np.sqrt(g.exam_var),\n                                random_seed=self.run_number*g.random_number_set)\n\n        # Trauma/stablisation duration (trauma only)\n        self.trauma_dist = Exponential(g.trauma_mean,\n                                    random_seed=self.run_number*g.random_number_set)\n\n        # Non-trauma treatment\n        self.nt_treat_dist = Lognormal(g.non_trauma_treat_mean,\n                                    np.sqrt(g.non_trauma_treat_var),\n                                    random_seed=self.run_number*g.random_number_set)\n\n        # treatment of trauma patients\n        self.treat_dist = Lognormal(g.trauma_treat_mean,\n                                    np.sqrt(g.non_trauma_treat_var),\n                                    random_seed=self.run_number*g.random_number_set)\n\n        # probability of non-trauma patient requiring treatment\n        self.nt_p_treat_dist = Bernoulli(g.non_trauma_treat_p,\n                                        random_seed=self.run_number*g.random_number_set)\n\n        # probability of non-trauma versus trauma patient\n        self.p_trauma_dist = Bernoulli(g.prob_trauma,\n                                    random_seed=self.run_number*g.random_number_set)\n\n        # init sampling for non-stationary poisson process\n        self.init_nspp()\n\n    def init_nspp(self):\n\n        # read arrival profile\n        self.arrivals = pd.read_csv(g.arrival_df)  # pylint: disable=attribute-defined-outside-init\n        self.arrivals['mean_iat'] = 60 / self.arrivals['arrival_rate']\n\n        # maximum arrival rate (smallest time between arrivals)\n        self.lambda_max = self.arrivals['arrival_rate'].max()  # pylint: disable=attribute-defined-outside-init\n\n        # thinning exponential\n        self.arrival_dist = Exponential(60.0 / self.lambda_max,  # pylint: disable=attribute-defined-outside-init\n                                            random_seed=self.run_number*g.random_number_set)\n\n        # thinning uniform rng\n        self.thinning_rng = Uniform(low=0.0, high=1.0,  # pylint: disable=attribute-defined-outside-init\n                                    random_seed=self.run_number*g.random_number_set)\n\n\n    def init_resources(self):\n        '''\n        Init the number of resources\n        and store in the arguments container object\n\n        Resource list:\n            1. Nurses/treatment bays (same thing in this model)\n\n        '''\n        # Shared Resources\n        self.triage_cubicles = VidigiStore(self.env, num_resources=g.n_triage)\n        self.registration_cubicles = VidigiStore(self.env, num_resources=g.n_reg)\n\n        # Non-trauma\n        self.exam_cubicles = VidigiStore(self.env, num_resources=g.n_exam)\n        self.non_trauma_treatment_cubicles = VidigiStore(self.env, g.n_cubicles_non_trauma_treat)\n\n        # Trauma\n        self.trauma_stabilisation_bays = VidigiStore(self.env, num_resources=g.n_trauma)\n        self.trauma_treatment_cubicles = VidigiStore(self.env, num_resources=g.n_cubicles_trauma_treat)\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            t = int(self.env.now // 60) % self.arrivals.shape[0]\n            lambda_t = self.arrivals['arrival_rate'].iloc[t]\n\n            # set to a large number so that at least 1 sample taken!\n            u = np.Inf\n\n            interarrival_time = 0.0\n            # reject samples if u &gt;= lambda_t / lambda_max\n            while u &gt;= (lambda_t / self.lambda_max):\n                interarrival_time += self.arrival_dist.sample()\n                u = self.thinning_rng.sample()\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(interarrival_time)\n\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            self.logger.log_arrival(entity_id=p.identifier,\n                                    pathway=\"Shared\")\n\n            # sample if the patient is trauma or non-trauma\n            trauma = self.p_trauma_dist.sample()\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            # and store patient in list for later easy access\n            if trauma:\n                # create and store a trauma patient to update KPIs.\n                self.trauma_patients.append(p)\n                self.env.process(self.attend_trauma_pathway(p))\n\n            else:\n                # create and store a non-trauma patient to update KPIs.\n                self.non_trauma_patients.append(p)\n                self.env.process(self.attend_non_trauma_pathway(p))\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_non_trauma_pathway(self, patient):\n        '''\n        simulates the non-trauma/minor treatment process for a patient\n\n        1. request and wait for sign-in/triage\n        2. patient registration\n        3. examination\n        4a. percentage discharged\n        4b. remaining percentage treatment then discharge\n        '''\n        # record the time of arrival and entered the triage queue\n        patient.arrival = self.env.now\n\n        self.logger.log_queue(\n            entity_id=patient.identifier,\n            pathway='Non-Trauma',\n            event='triage_wait_begins'\n            )\n\n        ###################################################\n        # request sign-in/triage\n        with self.triage_cubicles.request() as req:\n            triage_resource = yield req\n\n            # record the waiting time for triage\n            patient.wait_triage = self.env.now - patient.arrival\n\n            self.logger.log_resource_use_start(\n                entity_id=patient.identifier,\n                pathway='Non-Trauma',\n                event='triage_begins',\n                resource_id=triage_resource.id_attribute\n                )\n\n            # sample triage duration.\n            patient.triage_duration = self.triage_dist.sample()\n            yield self.env.timeout(patient.triage_duration)\n\n            self.logger.log_resource_use_end(\n                entity_id=patient.identifier,\n                pathway='Non-Trauma',\n                event='triage_complete',\n                resource_id=triage_resource.id_attribute\n                )\n\n        #########################################################\n\n        # record the time that entered the registration queue\n        start_wait = self.env.now\n\n        self.logger.log_queue(\n            entity_id=patient.identifier,\n            pathway='Non-Trauma',\n            event='MINORS_registration_wait_begins'\n            )\n\n        #########################################################\n        # request registration clerk\n        with self.registration_cubicles.request() as req:\n            registration_resource = yield req\n\n            # record the waiting time for registration\n            patient.wait_reg = self.env.now - start_wait\n\n            self.logger.log_resource_use_start(\n                    entity_id=patient.identifier,\n                    pathway='Non-Trauma',\n                    event='MINORS_registration_begins',\n                    resource_id=registration_resource.id_attribute\n                    )\n\n            # sample registration duration.\n            patient.reg_duration = self.reg_dist.sample()\n\n            yield self.env.timeout(patient.reg_duration)\n\n            self.logger.log_resource_use_end(\n                    entity_id=patient.identifier,\n                    pathway='Non-Trauma',\n                    event='MINORS_registration_complete',\n                    resource_id=registration_resource.id_attribute\n                    )\n\n        ########################################################\n\n        # record the time that entered the evaluation queue\n        start_wait = self.env.now\n\n        self.logger.log_queue(\n            entity_id=patient.identifier,\n            pathway='Non-Trauma',\n            event='MINORS_examination_wait_begins'\n            )\n\n        #########################################################\n        # request examination resource\n        with self.exam_cubicles.request() as req:\n            examination_resource = yield req\n\n            # record the waiting time for examination to begin\n            patient.wait_exam = self.env.now - start_wait\n\n            self.logger.log_resource_use_start(\n                    entity_id=patient.identifier,\n                    pathway='Non-Trauma',\n                    event='MINORS_examination_begins',\n                    resource_id=examination_resource.id_attribute\n                    )\n\n            # sample examination duration.\n            patient.exam_duration = self.exam_dist.sample()\n\n            yield self.env.timeout(patient.exam_duration)\n\n            self.logger.log_resource_use_end(\n                    entity_id=patient.identifier,\n                    pathway='Non-Trauma',\n                    event='MINORS_examination_complete',\n                    resource_id=examination_resource.id_attribute\n                    )\n\n        ############################################################################\n\n        # sample if patient requires treatment?\n        patient.require_treat = self.nt_p_treat_dist.sample()  #pylint: disable=attribute-defined-outside-init\n\n        if patient.require_treat:\n\n            self.logger.log_event(\n                entity_id = patient.identifier,\n                pathway = 'Non-Trauma',\n                event = 'requires_treatment',\n                event_type = 'attribute_assigned'\n            )\n\n            # record the time that entered the treatment queue\n            start_wait = self.env.now\n\n            self.logger.log_queue(\n                entity_id = patient.identifier,\n                pathway='Non-Trauma',\n                event='MINORS_treatment_wait_begins'\n                )\n\n            ###################################################\n            # request treatment cubicle\n\n            with self.non_trauma_treatment_cubicles.request() as req:\n                non_trauma_treatment_resource = yield req\n\n                # record the waiting time for treatment\n                patient.wait_treat = self.env.now - start_wait\n\n                self.logger.log_resource_use_start(\n                    entity_id=patient.identifier,\n                    pathway='Non-Trauma',\n                    event='MINORS_treatment_begins',\n                    resource_id=non_trauma_treatment_resource.id_attribute\n                    )\n\n                # sample treatment duration.\n                patient.treat_duration = self.nt_treat_dist.sample()\n                yield self.env.timeout(patient.treat_duration)\n\n                self.logger.log_resource_use_end(\n                    entity_id=patient.identifier,\n                    pathway='Non-Trauma',\n                    event='MINORS_treatment_complete',\n                    resource_id=non_trauma_treatment_resource.id_attribute\n                    )\n\n        ##########################################################################\n\n        # Return to what happens to all patients, regardless of whether\n        # they were sampled as needing treatment\n\n        self.logger.log_departure(\n            entity_id=patient.identifier,\n            pathway='Non-Trauma'\n        )\n\n        # total time in system\n        patient.total_time = self.env.now - patient.arrival\n\n    def attend_trauma_pathway(self, patient):\n        '''\n        simulates the major treatment process for a patient\n\n        1. request and wait for sign-in/triage\n        2. trauma\n        3. treatment\n        '''\n        # record the time of arrival and entered the triage queue\n        patient.arrival = self.env.now\n\n        self.logger.log_queue(\n            entity_id = patient.identifier,\n            pathway = 'Trauma',\n            event = 'triage_wait_begins'\n        )\n\n        ###################################################\n        # request sign-in/triage\n        with self.triage_cubicles.request() as req:\n\n            triage_resource = yield req\n\n            # record the waiting time for triage\n            patient.wait_triage = self.env.now - patient.arrival\n\n            self.logger.log_resource_use_start(\n                entity_id = patient.identifier,\n                pathway = 'Trauma',\n                event = 'triage_begins',\n                resource_id = triage_resource.id_attribute\n            )\n\n            # sample triage duration.\n            patient.triage_duration = self.triage_dist.sample()\n            yield self.env.timeout(patient.triage_duration)\n\n            self.logger.log_resource_use_end(\n                entity_id = patient.identifier,\n                pathway = 'Trauma',\n                event = 'triage_complete',\n                resource_id = triage_resource.id_attribute\n            )\n\n        ###################################################\n\n        # record the time that entered the trauma queue\n        self.logger.log_queue(\n            entity_id = patient.identifier,\n            pathway = 'Trauma',\n            event = 'TRAUMA_stabilisation_wait_begins'\n        )\n        start_wait = self.env.now\n\n        ###################################################\n        # request trauma room\n        with self.trauma_stabilisation_bays.request() as req:\n            trauma_resource = yield req\n\n            self.logger.log_resource_use_start(\n                entity_id = patient.identifier,\n                pathway = 'Trauma',\n                event = 'TRAUMA_stabilisation_begins',\n                resource_id = trauma_resource.id_attribute\n            )\n\n            # record the waiting time for trauma\n            patient.wait_trauma = self.env.now - start_wait\n\n            # sample stablisation duration.\n            patient.trauma_duration = self.trauma_dist.sample()\n            yield self.env.timeout(patient.trauma_duration)\n\n            self.logger.log_resource_use_end(\n                entity_id = patient.identifier,\n                pathway = 'Trauma',\n                event = 'TRAUMA_stabilisation_complete',\n                resource_id = trauma_resource.id_attribute\n            )\n\n        #######################################################\n\n        # record the time that patient entered the treatment queue\n        start_wait = self.env.now\n\n        self.logger.log_queue(\n            entity_id = patient.identifier,\n            pathway = 'Trauma',\n            event = 'TRAUMA_treatment_wait_begins'\n        )\n\n        ########################################################\n        # request treatment cubicle\n        with self.trauma_treatment_cubicles.request() as req:\n            trauma_treatment_resource = yield req\n\n            # record the waiting time for trauma\n            patient.wait_treat = self.env.now - start_wait\n\n            self.logger.log_resource_use_start(\n                    entity_id = patient.identifier,\n                    pathway = 'Trauma',\n                    event = 'TRAUMA_treatment_begins',\n                    resource_id = trauma_treatment_resource.id_attribute\n                )\n\n            # sample treatment duration.\n            patient.treat_duration = self.trauma_dist.sample()\n            yield self.env.timeout(patient.treat_duration)\n\n            self.logger.log_resource_use_end(\n                    entity_id = patient.identifier,\n                    pathway = 'Trauma',\n                    event = 'TRAUMA_treatment_complete',\n                    resource_id = trauma_treatment_resource.id_attribute\n                )\n\n        self.logger.log_departure(\n            entity_id = patient.identifier,\n            pathway = 'Shared'\n        )\n\n        #########################################################\n\n        # total time in system\n        patient.total_time = self.env.now - patient.arrival\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n\nclass Trial:\n    def  __init__(self):\n        self.all_event_logs = []\n        self.trial_results_df = pd.DataFrame()\n\n        self.run_trial()\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(1, g.number_of_runs+1):\n            random.seed(run)\n\n            my_model = Model(run)\n            my_model.run()\n\n            self.all_event_logs.append(my_model.logger)\n\n        self.trial_results = pd.concat(\n            [run_results.to_dataframe() for run_results in self.all_event_logs]\n            )\n\n\nadvanced_clinic_simulation = Trial()\n\nC:\\Users\\Sammi\\AppData\\Local\\Temp\\ipykernel_56100\\2193437664.py:297: UserWarning:\n\nUnrecognized event_type 'attribute_assigned'. Recommended values are: arrival_departure, resource_use, resource_use_end, queue.\n\n\n\n\nadvanced_clinic_simulation.all_event_logs[0].get_events_by_entity(5)\n\n\n\n\n\n\n\n\nentity_id\nevent_type\nevent\ntime\npathway\nrun_number\ntimestamp\nresource_id\n\n\n\n\n0\n5\narrival_departure\narrival\n125.487189\nShared\n1\nNone\nNaN\n\n\n1\n5\nqueue\ntriage_wait_begins\n125.487189\nNon-Trauma\n1\nNone\nNaN\n\n\n2\n5\nresource_use\ntriage_begins\n125.487189\nNon-Trauma\n1\nNone\n1.0\n\n\n3\n5\nresource_use_end\ntriage_complete\n126.005814\nNon-Trauma\n1\nNone\n1.0\n\n\n4\n5\nqueue\nMINORS_registration_wait_begins\n126.005814\nNon-Trauma\n1\nNone\nNaN\n\n\n5\n5\nresource_use\nMINORS_registration_begins\n126.005814\nNon-Trauma\n1\nNone\n1.0\n\n\n6\n5\nresource_use_end\nMINORS_registration_complete\n131.600448\nNon-Trauma\n1\nNone\n1.0\n\n\n7\n5\nqueue\nMINORS_examination_wait_begins\n131.600448\nNon-Trauma\n1\nNone\nNaN\n\n\n8\n5\nresource_use\nMINORS_examination_begins\n131.600448\nNon-Trauma\n1\nNone\n1.0\n\n\n9\n5\nresource_use_end\nMINORS_examination_complete\n149.229554\nNon-Trauma\n1\nNone\n1.0\n\n\n10\n5\nattribute_assigned\nrequires_treatment\n149.229554\nNon-Trauma\n1\nNone\nNaN\n\n\n11\n5\nqueue\nMINORS_treatment_wait_begins\n149.229554\nNon-Trauma\n1\nNone\nNaN\n\n\n12\n5\nresource_use\nMINORS_treatment_begins\n149.229554\nNon-Trauma\n1\nNone\n2.0\n\n\n13\n5\nresource_use_end\nMINORS_treatment_complete\n161.074127\nNon-Trauma\n1\nNone\n2.0\n\n\n14\n5\narrival_departure\ndepart\n161.074127\nNon-Trauma\n1\nNone\nNaN\n\n\n\n\n\n\n\n\nadvanced_clinic_simulation.trial_results\n\n\n\n\n\n\n\n\nentity_id\nevent_type\nevent\ntime\npathway\nrun_number\ntimestamp\nresource_id\n\n\n\n\n0\n1\narrival_departure\narrival\n37.593555\nShared\n1\nNone\nNaN\n\n\n1\n1\nqueue\ntriage_wait_begins\n37.593555\nNon-Trauma\n1\nNone\nNaN\n\n\n2\n1\nresource_use\ntriage_begins\n37.593555\nNon-Trauma\n1\nNone\n1.0\n\n\n3\n2\narrival_departure\narrival\n51.835879\nShared\n1\nNone\nNaN\n\n\n4\n2\nqueue\ntriage_wait_begins\n51.835879\nNon-Trauma\n1\nNone\nNaN\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n1470\n87\nresource_use_end\nMINORS_examination_complete\n598.990148\nNon-Trauma\n100\nNone\n1.0\n\n\n1471\n87\nattribute_assigned\nrequires_treatment\n598.990148\nNon-Trauma\n100\nNone\nNaN\n\n\n1472\n87\nqueue\nMINORS_treatment_wait_begins\n598.990148\nNon-Trauma\n100\nNone\nNaN\n\n\n1473\n87\nresource_use\nMINORS_treatment_begins\n598.990148\nNon-Trauma\n100\nNone\n1.0\n\n\n1474\n86\nresource_use\nMINORS_examination_begins\n598.990148\nNon-Trauma\n100\nNone\n1.0\n\n\n\n\n146776 rows × 8 columns\n\n\n\nAgain, we could create our event position dataframe by passing in a list of positions…\n\nevent_position_df = pd.DataFrame([\n                {'event': 'arrival', 'x':  10, 'y': 250, 'label': \"Arrival\" },\n\n                # Triage - minor and trauma\n                {'event': 'triage_wait_begins',\n                 'x':  160, 'y': 375, 'label': \"Waiting for&lt;br&gt;Triage\"  },\n                {'event': 'triage_begins',\n                 'x':  160, 'y': 315, 'resource':'n_triage', 'label': \"Being Triaged\" },\n\n                # Minors (non-trauma) pathway\n                {'event': 'MINORS_registration_wait_begins',\n                 'x':  300, 'y': 145, 'label': \"Waiting for&lt;br&gt;Registration\"  },\n                {'event': 'MINORS_registration_begins',\n                 'x':  300, 'y': 85, 'resource':'n_reg', 'label':'Being&lt;br&gt;Registered'  },\n\n                {'event': 'MINORS_examination_wait_begins',\n                 'x':  465, 'y': 145, 'label': \"Waiting for&lt;br&gt;Examination\"  },\n                {'event': 'MINORS_examination_begins',\n                 'x':  465, 'y': 85, 'resource':'n_exam', 'label': \"Being&lt;br&gt;Examined\" },\n\n                {'event': 'MINORS_treatment_wait_begins',\n                 'x':  630, 'y': 145, 'label': \"Waiting for&lt;br&gt;Treatment\"  },\n                {'event': 'MINORS_treatment_begins',\n                 'x':  630, 'y': 85, 'resource':'n_cubicles_non_trauma_treat', 'label': \"Being&lt;br&gt;Treated\" },\n\n                # Trauma pathway\n                {'event': 'TRAUMA_stabilisation_wait_begins',\n                 'x': 300, 'y': 560, 'label': \"Waiting for&lt;br&gt;Stabilisation\" },\n                {'event': 'TRAUMA_stabilisation_begins',\n                 'x': 300, 'y': 490, 'resource':'n_trauma', 'label': \"Being&lt;br&gt;Stabilised\" },\n\n                {'event': 'TRAUMA_treatment_wait_begins',\n                 'x': 630, 'y': 560, 'label': \"Waiting for&lt;br&gt;Treatment\" },\n                {'event': 'TRAUMA_treatment_begins',\n                 'x': 630, 'y': 490, 'resource':'n_cubicles_trauma_treat', 'label': \"Being&lt;br&gt;Treated\" },\n\n                 {'event': 'depart',\n                 'x':  670, 'y': 330, 'label': \"Exit\"}\n            ])\n\nOr using the vidigi helpers.\n\nevent_position_df = create_event_position_df([\n    EventPosition(event='arrival', x=10, y=250, label=\"Arrival\"),\n\n    # Triage - minor and trauma\n    EventPosition(event='triage_wait_begins', x=160, y=375, label=\"Waiting for&lt;br&gt;Triage\"),\n    EventPosition(event='triage_begins', x=160, y=315, resource='n_triage', label=\"Being Triaged\"),\n\n    # Minors (non-trauma) pathway\n    EventPosition(event='MINORS_registration_wait_begins', x=300, y=145, label=\"Waiting for&lt;br&gt;Registration\"),\n    EventPosition(event='MINORS_registration_begins', x=300, y=85, resource='n_reg', label='Being&lt;br&gt;Registered'),\n\n    EventPosition(event='MINORS_examination_wait_begins', x=465, y=145, label=\"Waiting for&lt;br&gt;Examination\"),\n    EventPosition(event='MINORS_examination_begins', x=465, y=85, resource='n_exam', label=\"Being&lt;br&gt;Examined\"),\n\n    EventPosition(event='MINORS_treatment_wait_begins', x=630, y=145, label=\"Waiting for&lt;br&gt;Treatment\"),\n    EventPosition(event='MINORS_treatment_begins', x=630, y=85, resource='n_cubicles_non_trauma_treat', label=\"Being&lt;br&gt;Treated\"),\n\n    # Trauma pathway\n    EventPosition(event='TRAUMA_stabilisation_wait_begins', x=300, y=560, label=\"Waiting for&lt;br&gt;Stabilisation\"),\n    EventPosition(event='TRAUMA_stabilisation_begins', x=300, y=490, resource='n_trauma', label=\"Being&lt;br&gt;Stabilised\"),\n\n    EventPosition(event='TRAUMA_treatment_wait_begins', x=630, y=560, label=\"Waiting for&lt;br&gt;Treatment\"),\n    EventPosition(event='TRAUMA_treatment_begins', x=630, y=490, resource='n_cubicles_trauma_treat', label=\"Being&lt;br&gt;Treated\"),\n\n    EventPosition(event='depart', x=670, y=330, label=\"Exit\")\n])\n\nFinally, we’ll create the animation, remembering to filter to a single run when passing in our dataframe.\n\nanimate_activity_log(\n        event_log=advanced_clinic_simulation.trial_results[advanced_clinic_simulation.trial_results['run_number']==1],\n        event_position_df= event_position_df,\n        scenario=g(),\n        debug_mode=True,\n        setup_mode=False,\n        every_x_time_units=5,\n        include_play_button=True,\n        gap_between_entities=11,\n        gap_between_resources=15,\n        gap_between_resource_rows=30,\n        gap_between_queue_rows=30,\n        plotly_height=600,\n        plotly_width=1000,\n        override_x_max=700,\n        override_y_max=675,\n        entity_icon_size=10,\n        resource_icon_size=13,\n        text_size=15,\n        wrap_queues_at=10,\n        step_snapshot_max=20,\n        limit_duration=g.sim_duration,\n        time_display_units=\"dhm\",\n        display_stage_labels=False,\n        add_background_image=\"https://raw.githubusercontent.com/Bergam0t/vidigi/refs/heads/main/examples/example_2_branching_multistep/Full%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\",\n    )\n\nAnimation function called at 11:17:30\nIteration through time-unit-by-time-unit logs complete 11:17:31\nSnapshot df concatenation complete at 11:17:31\nReshaped animation dataframe finished construction at 11:17:31\nPlacement dataframe finished construction at 11:17:31\nOutput animation generation complete at 11:17:31\nTotal Time Elapsed: 1.64 seconds",
    "crumbs": [
      "Details",
      "Feature Example: Event Logging Helpers"
    ]
  },
  {
    "objectID": "notes.html",
    "href": "notes.html",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "",
    "text": "Current mechanism\nIn short, the final plot is an animated plotly scatterplot.\nIn theory, there’s nothing to stop it using an alternative mode of action (e.g. svg), but one benefit of plotly is that it nicely deals with the intermediate paths of patients. It is also available in both Python and R with minimal changes and has extensive compatability with other tools - e.g. Streamlit, Dash.\nThere are a couple of key steps to setting up the visualisation 1. Adding logging steps to the model 2. Swapping the use of resources for simpy stores containing resources 3. Creating an object that stores resources - a ‘scenario’ object - which then informs the number of resources displayed 4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval) 5. Using Plotly to display these logs"
  },
  {
    "objectID": "notes.html#adding-logging-steps-to-the-model",
    "href": "notes.html#adding-logging-steps-to-the-model",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "1. Adding logging steps to the model",
    "text": "1. Adding logging steps to the model\nFive key classes of events need to be logged for every patient: - arrival - queue - resource use start - resource use end (could possibly be removed) - depart\nSimple improvements required include applying consistency to naming (e.g. arrival and departure, arrive and depart, not a mixture of the two)\nAt present, five to six things are recorded per log. ‘Pathway’ could potentially be removed.\nThis whole structure could be rewritten to be significantly less verbose. It is written like this at present because of the ease of transforming this structure of dictionary to a dataframe and the flexibility of the structure, but exploring alternatives like key:value pairs of event:time could be explored.\nCurrenly, the key logs take the following format\nArrival:\nself.full_event_log.append({\n    'patient': self.identifier,\n    'pathway': 'Simplest',\n    'event_type': 'arrival_departure',\n    'event': 'arrival',\n    'time': self.env.now\n})\nQueueing:\nself.full_event_log.append({\n    'patient': self.identifier,\n    'pathway': 'Simplest',\n    'event': 'treatment_wait_begins',\n    'event_type': 'queue',\n    'time': self.env.now\n})\nResource Use Start:\nself.full_event_log.append({\n    'patient': self.identifier,\n    'pathway': 'Simplest',\n    'event': 'treatment_begins',\n    'event_type': 'resource_use',\n    'time': self.env.now,\n    'resource_id': treatment_resource.id_attribute\n})\nResource Use End:\nself.full_event_log.append({\n    'patient': self.identifier,\n    'pathway': 'Simplest',\n    'event': 'treatment_complete',\n    'event_type': 'resource_use_end',\n    'time': self.env.now,\n    'resource_id': treatment_resource.id_attribute\n})\nDeparture:\nself.full_event_log.append({\n    'patient': self.identifier,\n    'pathway': 'Simplest',\n    'event': 'depart',\n    'event_type': 'arrival_departure',\n    'time': self.env.now\n})"
  },
  {
    "objectID": "notes.html#swapping-the-use-of-resources-for-simpy-stores-containing-resources",
    "href": "notes.html#swapping-the-use-of-resources-for-simpy-stores-containing-resources",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "2. Swapping the use of resources for simpy stores containing resources",
    "text": "2. Swapping the use of resources for simpy stores containing resources\nWhen a resource is in use, we need to be able to show a single entity consistently hogging the same resource throughout the full time they are using it.\nSimpy resources do not inherently have any ID attribute. After exploring options like monkey patching the resource class, a better alternative seemed to be using a simpy store - which does have an ID - instead of a straight resource.\nWithout this ID attribute, the default logic used to move entities through the steps results in them visually behaving like a queue, which makes it hard to understand how long someone has been using a resource for and is visually confusing.\nFortunately the code changes required are minimal. We initialise the store, then use a loop to create as many resources within that store as required.\ndef init_resources(self):\n    '''\n    Init the number of resources\n    and store in the arguments container object\n\n    Resource list:\n        1. Nurses/treatment bays (same thing in this model)\n\n    '''\n    self.args.treatment = simpy.Store(self.env)\n\n    for i in range(self.args.n_cubicles_1):\n        self.args.treatment.put(\n            CustomResource(\n                self.env,\n                capacity=1,\n                id_attribute = i+1)\n            )\nUse of the resource then becomes\n# Seize a treatment resource when available\ntreatment_resource = yield self.args.treatment.get()\nWhen the timeout has elapsed, we then use the following code.\n# Resource is no longer in use, so put it back in\nself.args.treatment.put(treatment_resource)\nThis has additional benefits of making it easier to monitor the use of individual resources.\nOne thing that has been noticed is that the resources seem to be cycled through in order. For example, if you have 4 resources and all are available, but the last resource to be in use was resource 2, resource 3 will be seized the next time someone requires a resource. This may not be entirely realistic, and code to ‘shake up’ the resources after use may be worth exploring."
  },
  {
    "objectID": "notes.html#creating-an-object-that-stores-resources---a-scenario-object---which-then-informs-the-number-of-resources-displayed",
    "href": "notes.html#creating-an-object-that-stores-resources---a-scenario-object---which-then-informs-the-number-of-resources-displayed",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "3. Creating an object that stores resources - a ‘scenario’ object - which then informs the number of resources displayed",
    "text": "3. Creating an object that stores resources - a ‘scenario’ object - which then informs the number of resources displayed\nAt present this part of the code expects a scenario object. This could be changed to - expect a dictionary instead - work with either a scenario or dictionary object (maybe if the route of expanding TM’s approach to simpy modelling into an opinionated framework)\nIf going with the first option, the scenario class used in TM’s work routinely could be expanded to include a method to export the required data to a dictionary format.\n\nevents_with_resources = event_position_df[event_position_df['resource'].notnull()].copy()\nevents_with_resources['resource_count'] = events_with_resources['resource'].apply(lambda x: getattr(scenario, x))\n\nevents_with_resources = events_with_resources.join(events_with_resources.apply(\n    lambda r: pd.Series({'x_final': [r['x']-(10*(i+1)) for i in range(r['resource_count'])]}), axis=1).explode('x_final'),\n    how='right')\n\nfig.add_trace(go.Scatter(\n    x=events_with_resources['x_final'].to_list(),\n    # Place these slightly below the y position for each entity\n    # that will be using the resource\n    y=[i-10 for i in events_with_resources['y'].to_list()],\n    mode=\"markers\",\n    # Define what the marker will look like\n    marker=dict(\n        color='LightSkyBlue',\n        size=15),\n    opacity=0.8,\n    hoverinfo='none'\n))\n\nThe function reshape_for_animations()"
  },
  {
    "objectID": "notes.html#using-plotly-to-display-these-logs",
    "href": "notes.html#using-plotly-to-display-these-logs",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "5. Using Plotly to display these logs",
    "text": "5. Using Plotly to display these logs\nThe function animate_activity_log currently takes 3 mandatory parameters: - full_patient_df - event_position_df - scenario\nfull_patient_df is the output of the function reshape_for_animations\nThe graph is a plotly scatterplot. The initial animated plot is created using plotly express, with additional static layers added afterwards.\nEach individual is a scatter point. The actual points are fully transparent, and what we see is a text label - the emoji.\nA list of any length of emojis is required. This will then be joined with a distinct patient table to provide a list of patients."
  },
  {
    "objectID": "notes.html#already-created",
    "href": "notes.html#already-created",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "Already created",
    "text": "Already created\n\nSimple pathway (units: minutes)\nPathway with branching and optional steps (units: weeks)"
  },
  {
    "objectID": "notes.html#not-yet-created---additional-features-possibly-required",
    "href": "notes.html#not-yet-created---additional-features-possibly-required",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "Not yet created - additional features possibly required",
    "text": "Not yet created - additional features possibly required\n\nSimple pathway (units: days, weeks)\nResource numbers that change at different points of the day\nPrioritised queueing\nShared resources\nMultiple resources required for a step (e.g. doctor + cubicle - how to display this?)\nReneging\nJockeying\nBalking"
  },
  {
    "objectID": "notes.html#known-areas-for-attention",
    "href": "notes.html#known-areas-for-attention",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "Known areas for attention",
    "text": "Known areas for attention\n\nThe code is not written in an object oriented manner.\nThere’s a bug in the wrapping code that results in queues building out in a diagonal manner (shifted 1 to the left) from the 3rd row onwards (2nd row counts to 11 instead of 10, and then subsequent rows correctly include 10 but start too far over)"
  },
  {
    "objectID": "notes.html#required-enhancements",
    "href": "notes.html#required-enhancements",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "Required enhancements",
    "text": "Required enhancements\n\nAt present, the queue of users will continue to grow indefinitely until it leaves the boundary."
  },
  {
    "objectID": "notes.html#friction-points",
    "href": "notes.html#friction-points",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "Friction points",
    "text": "Friction points\n\nSetting up the background image can be a fiddly process"
  },
  {
    "objectID": "notes.html#other-limitations",
    "href": "notes.html#other-limitations",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "Other limitations",
    "text": "Other limitations\n\nBy avoiding emojis that were released after v12.0 of the emoji standard (released in early 2019), we can ensure compatability with most major OSs. Windows 10 has not been updated past this point. However, due to the nature of emojis, we cannot absolutely ensure full compatability across all systems."
  },
  {
    "objectID": "notes.html#concerns",
    "href": "notes.html#concerns",
    "title": "4. Iterating through the logs to make a minute-by-minute picture of the position of every patient (or any desired interval)",
    "section": "Concerns",
    "text": "Concerns\n\nCurrently, logging can cope with ~5 minute snapshots for 5 days of logs in a system that has ~10-60 people in the system at any given point in time. This results in a self-contained plot of ~20mb when exported (for comparison, a self-contained line chart with some additional rectangles is &lt;20kb).\n\n5 days was chosen as a good limit for the streamlit teaching app as it offered a good balance between speed and minimized the risk of crashing across different choices of parameters.\n\nIf significantly too few resources are provided at a given step, the size of the animation dataframe quickly gets out of hand (as people aren’t getting through the system so the number of people in the system at each snapshot is very large)\n\nWorking on a way of displaying queues after a threshold number of people is reached will help significantly"
  },
  {
    "objectID": "reference/animation.animate_activity_log.html",
    "href": "reference/animation.animate_activity_log.html",
    "title": "animation.animate_activity_log",
    "section": "",
    "text": "animation.animate_activity_log(\n    event_log,\n    event_position_df,\n    scenario=None,\n    time_col_name='time',\n    entity_col_name='entity_id',\n    event_type_col_name='event_type',\n    event_col_name='event',\n    pathway_col_name=None,\n    resource_col_name='resource_id',\n    simulation_time_unit='minutes',\n    every_x_time_units=10,\n    wrap_queues_at=20,\n    wrap_resources_at=20,\n    step_snapshot_max=50,\n    limit_duration=10 * 60 * 24,\n    plotly_height=900,\n    plotly_width=None,\n    include_play_button=True,\n    add_background_image=None,\n    display_stage_labels=True,\n    entity_icon_size=24,\n    text_size=24,\n    resource_icon_size=24,\n    gap_between_entities=10,\n    gap_between_queue_rows=30,\n    gap_between_resource_rows=30,\n    gap_between_resources=10,\n    resource_opacity=0.8,\n    custom_resource_icon=None,\n    override_x_max=None,\n    override_y_max=None,\n    start_date=None,\n    start_time=None,\n    time_display_units=None,\n    setup_mode=False,\n    frame_duration=400,\n    frame_transition_duration=600,\n    debug_mode=False,\n    custom_entity_icon_list=None,\n    debug_write_intermediate_objects=False,\n    background_image_opacity=0.5,\n    overflow_text_color='black',\n    stage_label_text_colour='black',\n    backend='express',\n)\nGenerate an animated visualization of patient flow through a system.\n\nThis function processes event log data, adds positional information, and creates\nan interactive Plotly animation representing patient movement through various stages.\n\n\nevent_log : pd.DataFrame\n    The log of events to be animated, containing patient activities.\nevent_position_df : pd.DataFrame\n    DataFrame specifying the positions of different events, with columns 'event', 'x', and 'y'.\nscenario : object\n    An object containing attributes for resource counts at different steps.\n    time_col_name : str, default=\"time\"\n    Name of the column in `event_log` that contains the timestamp of each event.\n    Timestamps should represent the number of time units since the simulation began.\nentity_col_name : str, default=\"entity_id\"\n    Name of the column in `event_log` that contains the unique identifier for each entity\n    (e.g., \"entity_id\",  \"entity\", \"patient\", \"patient_id\", \"customer\", \"ID\").\nevent_type_col_name : str, default=\"event_type\"\n    Name of the column in `event_log` that specifies the category of the event.\n    Supported event types include 'arrival_departure', 'resource_use',\n    'resource_use_end', and 'queue'.\nevent_col_name : str, default=\"event\"\n    Name of the column in `event_log` that specifies the actual event that occurred.\npathway_col_name : str, optional, default=None\n    Name of the column in `event_log` that identifies the specific pathway or\n    process flow the entity is following. If `None`, it is assumed that pathway\n    information is not present.\nresource_col_name : str, default=\"resource_id\"\n    Name of the column for the resource identifier. Used for 'resource_use' events.\nsimulation_time_unit: string, optional\n    Time unit used within the simulation (default is minutes).\n    Possible values are 'seconds', 'minutes', 'hours', 'days', 'weeks', 'years'\nevery_x_time_units : int, optional\n    Time interval between animation frames in minutes (default is 10).\nwrap_queues_at : int, optional\n    Maximum number of entities to display in a queue before wrapping to a new row (default is 20).\nwrap_resources_at : int, optional\n    Number of resources to show before wrapping to a new row (default is 20).\nstep_snapshot_max : int, optional\n    Maximum number of patients to show in each snapshot per event (default is 50).\nlimit_duration : int, optional\n    Maximum duration to animate in minutes (default is 10 days or 14400 minutes).\nplotly_height : int, optional\n    Height of the Plotly figure in pixels (default is 900).\nplotly_width : int, optional\n    Width of the Plotly figure in pixels (default is None, which auto-adjusts).\ninclude_play_button : bool, optional\n    Whether to include a play button in the animation (default is True).\nadd_background_image : str, optional\n    Path to a background image file to add to the animation (default is None).\ndisplay_stage_labels : bool, optional\n    Whether to display labels for each stage (default is True).\nentity_icon_size : int, optional\n    Size of entity icons in the animation (default is 24).\ntext_size : int, optional\n    Size of text labels in the animation (default is 24).\nresource_icon_size : int, optional\n    Size of resource icons in the animation (default is 24).\ngap_between_entities : int, optional\n    Horizontal spacing between entities in pixels (default is 10).\ngap_between_queue_rows : int, optional\n    Vertical spacing between rows in pixels (default is 30).\ngap_between_resource_rows : int, optional\n    Vertical spacing between rows in pixels (default is 30).\ngap_between_resources : int, optional\n    Horizontal spacing between resources in pixels (default is 10).\nresource_opacity : float, optional\n    Opacity of resource icons (default is 0.8).\ncustom_resource_icon : str, optional\n    Custom icon to use for resources (default is None).\noverride_x_max : int, optional\n    Override the maximum x-coordinate of the plot (default is None).\noverride_y_max : int, optional\n    Override the maximum y-coordinate of the plot (default is None).\ntime_display_units : str, optional\n    Format for displaying time on the animation timeline. This affects how simulation time is\n    converted into human-readable dates or clock formats. If `None` (default), the raw simulation\n    time is used.\n    Predefined options:\n    'dhms' : Day Month Year + HH:MM:SS (e.g., \"06 June 2025 14:23:45\")\n    'dhms_ampm' : Same as 'dhms', but in 12-hour format with AM/PM (e.g., \"06 June 2025 02:23:45 PM\")\n    'dhm'  : Day Month Year + HH:MM (e.g., \"06 June 2025 14:23\")\n    'dhm_ampm' : 12-hour format with AM/PM (e.g., \"06 June 2025 02:23 PM\")\n    'dh'   : Day Month Year + HH (e.g., \"06 June 2025 14\")\n    'dh_ampm' : 12-hour format with AM/PM (e.g., \"06 June 2025 02 PM\")\n    'd'    : Full weekday and date (e.g., \"Friday 06 June 2025\")\n    'm'    : Month and year (e.g., \"June 2025\")\n    'y'    : Year only (e.g., \"2025\")\n    'day_clock' or 'simulation_day_clock': Show simulation-relative day and time (e.g., \"Simulation Day 3\n14:15”) ‘day_clock_ampm’ or ‘simulation_day_clock_ampm’: Same as above, but time is shown in 12-hour clock with AM/PM (e.g., “Simulation Day 3 02:15 PM”) Alternatively, you can supply a custom strftime format string (e.g., ‘%Y-%m-%d %H’) to control the display manually. setup_mode : bool, optional If True, display grid and tick marks for initial setup (default is False). frame_duration : int, optional Duration of each frame in milliseconds (default is 400). frame_transition_duration : int, optional Duration of transition between frames in milliseconds (default is 600). debug_mode : bool, optional If True, print debug information during processing (default is False). custom_entity_icon_list: list, optional If given, overrides the default list of emojis used to represent entities background_image_opacity : float, optional Opacity (0 is transparent, to 1, completely opaque) of the provided background image backend: str, optional EXPERIMENTAL. Whether to use the plotly express backend for the initial plot (default), or the experimental plotly go backend. The go approach is currently unstable and much slower. Use at your own risk.\n\n\n\nplotly.graph_objs._figure.Figure\n    An animated Plotly figure object representing the patient flow.\n\n\n\n- This function uses helper functions: reshape_for_animations, generate_animation_df, and generate_animation.\n- The animation supports customization of icon sizes, resource representation, and animation speed.\n- Time can be displayed as actual dates or as model time units.\n- A background image can be added to provide context for the patient flow.\n- The function handles both queuing and resource use events.",
    "crumbs": [
      "vidigi Function Reference",
      "All-In-One Animation Functions",
      "animation.animate_activity_log"
    ]
  },
  {
    "objectID": "reference/animation.animate_activity_log.html#parameters",
    "href": "reference/animation.animate_activity_log.html#parameters",
    "title": "animation.animate_activity_log",
    "section": "",
    "text": "event_log : pd.DataFrame\n    The log of events to be animated, containing patient activities.\nevent_position_df : pd.DataFrame\n    DataFrame specifying the positions of different events, with columns 'event', 'x', and 'y'.\nscenario : object\n    An object containing attributes for resource counts at different steps.\n    time_col_name : str, default=\"time\"\n    Name of the column in `event_log` that contains the timestamp of each event.\n    Timestamps should represent the number of time units since the simulation began.\nentity_col_name : str, default=\"entity_id\"\n    Name of the column in `event_log` that contains the unique identifier for each entity\n    (e.g., \"entity_id\",  \"entity\", \"patient\", \"patient_id\", \"customer\", \"ID\").\nevent_type_col_name : str, default=\"event_type\"\n    Name of the column in `event_log` that specifies the category of the event.\n    Supported event types include 'arrival_departure', 'resource_use',\n    'resource_use_end', and 'queue'.\nevent_col_name : str, default=\"event\"\n    Name of the column in `event_log` that specifies the actual event that occurred.\npathway_col_name : str, optional, default=None\n    Name of the column in `event_log` that identifies the specific pathway or\n    process flow the entity is following. If `None`, it is assumed that pathway\n    information is not present.\nresource_col_name : str, default=\"resource_id\"\n    Name of the column for the resource identifier. Used for 'resource_use' events.\nsimulation_time_unit: string, optional\n    Time unit used within the simulation (default is minutes).\n    Possible values are 'seconds', 'minutes', 'hours', 'days', 'weeks', 'years'\nevery_x_time_units : int, optional\n    Time interval between animation frames in minutes (default is 10).\nwrap_queues_at : int, optional\n    Maximum number of entities to display in a queue before wrapping to a new row (default is 20).\nwrap_resources_at : int, optional\n    Number of resources to show before wrapping to a new row (default is 20).\nstep_snapshot_max : int, optional\n    Maximum number of patients to show in each snapshot per event (default is 50).\nlimit_duration : int, optional\n    Maximum duration to animate in minutes (default is 10 days or 14400 minutes).\nplotly_height : int, optional\n    Height of the Plotly figure in pixels (default is 900).\nplotly_width : int, optional\n    Width of the Plotly figure in pixels (default is None, which auto-adjusts).\ninclude_play_button : bool, optional\n    Whether to include a play button in the animation (default is True).\nadd_background_image : str, optional\n    Path to a background image file to add to the animation (default is None).\ndisplay_stage_labels : bool, optional\n    Whether to display labels for each stage (default is True).\nentity_icon_size : int, optional\n    Size of entity icons in the animation (default is 24).\ntext_size : int, optional\n    Size of text labels in the animation (default is 24).\nresource_icon_size : int, optional\n    Size of resource icons in the animation (default is 24).\ngap_between_entities : int, optional\n    Horizontal spacing between entities in pixels (default is 10).\ngap_between_queue_rows : int, optional\n    Vertical spacing between rows in pixels (default is 30).\ngap_between_resource_rows : int, optional\n    Vertical spacing between rows in pixels (default is 30).\ngap_between_resources : int, optional\n    Horizontal spacing between resources in pixels (default is 10).\nresource_opacity : float, optional\n    Opacity of resource icons (default is 0.8).\ncustom_resource_icon : str, optional\n    Custom icon to use for resources (default is None).\noverride_x_max : int, optional\n    Override the maximum x-coordinate of the plot (default is None).\noverride_y_max : int, optional\n    Override the maximum y-coordinate of the plot (default is None).\ntime_display_units : str, optional\n    Format for displaying time on the animation timeline. This affects how simulation time is\n    converted into human-readable dates or clock formats. If `None` (default), the raw simulation\n    time is used.\n    Predefined options:\n    'dhms' : Day Month Year + HH:MM:SS (e.g., \"06 June 2025 14:23:45\")\n    'dhms_ampm' : Same as 'dhms', but in 12-hour format with AM/PM (e.g., \"06 June 2025 02:23:45 PM\")\n    'dhm'  : Day Month Year + HH:MM (e.g., \"06 June 2025 14:23\")\n    'dhm_ampm' : 12-hour format with AM/PM (e.g., \"06 June 2025 02:23 PM\")\n    'dh'   : Day Month Year + HH (e.g., \"06 June 2025 14\")\n    'dh_ampm' : 12-hour format with AM/PM (e.g., \"06 June 2025 02 PM\")\n    'd'    : Full weekday and date (e.g., \"Friday 06 June 2025\")\n    'm'    : Month and year (e.g., \"June 2025\")\n    'y'    : Year only (e.g., \"2025\")\n    'day_clock' or 'simulation_day_clock': Show simulation-relative day and time (e.g., \"Simulation Day 3\n14:15”) ‘day_clock_ampm’ or ‘simulation_day_clock_ampm’: Same as above, but time is shown in 12-hour clock with AM/PM (e.g., “Simulation Day 3 02:15 PM”) Alternatively, you can supply a custom strftime format string (e.g., ‘%Y-%m-%d %H’) to control the display manually. setup_mode : bool, optional If True, display grid and tick marks for initial setup (default is False). frame_duration : int, optional Duration of each frame in milliseconds (default is 400). frame_transition_duration : int, optional Duration of transition between frames in milliseconds (default is 600). debug_mode : bool, optional If True, print debug information during processing (default is False). custom_entity_icon_list: list, optional If given, overrides the default list of emojis used to represent entities background_image_opacity : float, optional Opacity (0 is transparent, to 1, completely opaque) of the provided background image backend: str, optional EXPERIMENTAL. Whether to use the plotly express backend for the initial plot (default), or the experimental plotly go backend. The go approach is currently unstable and much slower. Use at your own risk.",
    "crumbs": [
      "vidigi Function Reference",
      "All-In-One Animation Functions",
      "animation.animate_activity_log"
    ]
  },
  {
    "objectID": "reference/animation.animate_activity_log.html#returns",
    "href": "reference/animation.animate_activity_log.html#returns",
    "title": "animation.animate_activity_log",
    "section": "",
    "text": "plotly.graph_objs._figure.Figure\n    An animated Plotly figure object representing the patient flow.",
    "crumbs": [
      "vidigi Function Reference",
      "All-In-One Animation Functions",
      "animation.animate_activity_log"
    ]
  },
  {
    "objectID": "reference/animation.animate_activity_log.html#notes",
    "href": "reference/animation.animate_activity_log.html#notes",
    "title": "animation.animate_activity_log",
    "section": "",
    "text": "- This function uses helper functions: reshape_for_animations, generate_animation_df, and generate_animation.\n- The animation supports customization of icon sizes, resource representation, and animation speed.\n- Time can be displayed as actual dates or as model time units.\n- A background image can be added to provide context for the patient flow.\n- The function handles both queuing and resource use events.",
    "crumbs": [
      "vidigi Function Reference",
      "All-In-One Animation Functions",
      "animation.animate_activity_log"
    ]
  },
  {
    "objectID": "reference/ciw.event_log_from_ciw_recs.html",
    "href": "reference/ciw.event_log_from_ciw_recs.html",
    "title": "ciw.event_log_from_ciw_recs",
    "section": "",
    "text": "ciw.event_log_from_ciw_recs(ciw_recs_obj, node_name_list)\nGiven the ciw recs object, return a dataframe in the format expected by the vidigi functions - reshape_for_animation OR - animate_activity_log\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nciw_recs_obj\n\nThe output of the .get_all_records() method run on the ciw simulation object. This is a list of named tuples. See https://ciw.readthedocs.io/en/latest/Tutorial/GettingStarted/part_3.html and https://ciw.readthedocs.io/en/latest/Reference/results.html for more details.\nrequired\n\n\nnode_name_list\n\nUser-defined list of strings where each string relates to the resource or activity that will take place at that ciw node\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\n\n\n\n\n\n\n\nGiven the ciw recs object, if we know the nodes and what they relate to, we can build up a picture the arrival date for the first tuple for a given user ID is the arrival\nThen, for each node: - the arrival date for a given node is when they start queueing - the service start date is when they stop queueing - the service start date is when they begin using the resource - the service end date is when the resource use ends - the server ID is the equivalent of a simpy resource use ID\nA more complex multi-node example can be found in https://github.com/Bergam0t/ciw-example-animation in the files - ciw_model.py - vidigi_experiments.py",
    "crumbs": [
      "vidigi Function Reference",
      "ciw Utility Functions",
      "ciw.event_log_from_ciw_recs"
    ]
  },
  {
    "objectID": "reference/ciw.event_log_from_ciw_recs.html#parameters",
    "href": "reference/ciw.event_log_from_ciw_recs.html#parameters",
    "title": "ciw.event_log_from_ciw_recs",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nciw_recs_obj\n\nThe output of the .get_all_records() method run on the ciw simulation object. This is a list of named tuples. See https://ciw.readthedocs.io/en/latest/Tutorial/GettingStarted/part_3.html and https://ciw.readthedocs.io/en/latest/Reference/results.html for more details.\nrequired\n\n\nnode_name_list\n\nUser-defined list of strings where each string relates to the resource or activity that will take place at that ciw node\nrequired",
    "crumbs": [
      "vidigi Function Reference",
      "ciw Utility Functions",
      "ciw.event_log_from_ciw_recs"
    ]
  },
  {
    "objectID": "reference/ciw.event_log_from_ciw_recs.html#returns",
    "href": "reference/ciw.event_log_from_ciw_recs.html#returns",
    "title": "ciw.event_log_from_ciw_recs",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\npd.DataFrame",
    "crumbs": [
      "vidigi Function Reference",
      "ciw Utility Functions",
      "ciw.event_log_from_ciw_recs"
    ]
  },
  {
    "objectID": "reference/ciw.event_log_from_ciw_recs.html#notes",
    "href": "reference/ciw.event_log_from_ciw_recs.html#notes",
    "title": "ciw.event_log_from_ciw_recs",
    "section": "",
    "text": "Given the ciw recs object, if we know the nodes and what they relate to, we can build up a picture the arrival date for the first tuple for a given user ID is the arrival\nThen, for each node: - the arrival date for a given node is when they start queueing - the service start date is when they stop queueing - the service start date is when they begin using the resource - the service end date is when the resource use ends - the server ID is the equivalent of a simpy resource use ID\nA more complex multi-node example can be found in https://github.com/Bergam0t/ciw-example-animation in the files - ciw_model.py - vidigi_experiments.py",
    "crumbs": [
      "vidigi Function Reference",
      "ciw Utility Functions",
      "ciw.event_log_from_ciw_recs"
    ]
  },
  {
    "objectID": "reference/logging.EventLogger.html",
    "href": "reference/logging.EventLogger.html",
    "title": "logging.EventLogger",
    "section": "",
    "text": "logging.EventLogger(self, event_model=BaseEvent, env=None, run_number=None)\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_events_by_entity\nReturn all events associated with a specific entity_id.\n\n\nget_events_by_event_name\nReturn all events of a specific event_type.\n\n\nget_events_by_event_type\nReturn all events of a specific event_type.\n\n\nget_events_by_run\nReturn all events associated with a specific entity_id.\n\n\nlog_arrival\nHelper to log an arrival event with the correct event_type and event fields.\n\n\nlog_custom_event\nLog a custom event. The ‘event’ here can be any string describing the queue event.\n\n\nlog_departure\nHelper to log a departure event with the correct event_type and event fields.\n\n\nlog_queue\nLog a queue event. The ‘event’ here can be any string describing the queue event.\n\n\nlog_resource_use_end\nLog the end of resource use. Requires resource_id.\n\n\nlog_resource_use_start\nLog the start of resource use. Requires resource_id.\n\n\nplot_entity_timeline\nPlot a timeline of events for a specific entity_id.\n\n\nto_csv\nWrite the log to a CSV file.\n\n\nto_dataframe\nConvert the event log to a pandas DataFrame.\n\n\nto_json\nWrite the event log to a JSON file or file-like buffer.\n\n\nto_json_string\nReturn the event log as a pretty JSON string.\n\n\n\n\n\nlogging.EventLogger.get_events_by_entity(entity_id, as_dataframe=True)\nReturn all events associated with a specific entity_id.\n\n\n\nlogging.EventLogger.get_events_by_event_name(event, as_dataframe=True)\nReturn all events of a specific event_type.\n\n\n\nlogging.EventLogger.get_events_by_event_type(event_type, as_dataframe=True)\nReturn all events of a specific event_type.\n\n\n\nlogging.EventLogger.get_events_by_run(run_number, as_dataframe=True)\nReturn all events associated with a specific entity_id.\n\n\n\nlogging.EventLogger.log_arrival(\n    entity_id,\n    time=None,\n    pathway=None,\n    run_number=None,\n    **extra_fields,\n)\nHelper to log an arrival event with the correct event_type and event fields.\n\n\n\nlogging.EventLogger.log_custom_event(\n    entity_id,\n    event_type,\n    event,\n    time=None,\n    pathway=None,\n    run_number=None,\n    **extra_fields,\n)\nLog a custom event. The ‘event’ here can be any string describing the queue event. An ‘event_type’ must also be passed, but can be any string of the user’s choosing.\n\n\n\nlogging.EventLogger.log_departure(\n    entity_id,\n    time=None,\n    pathway=None,\n    run_number=None,\n    **extra_fields,\n)\nHelper to log a departure event with the correct event_type and event fields.\n\n\n\nlogging.EventLogger.log_queue(\n    entity_id,\n    event,\n    time=None,\n    pathway=None,\n    run_number=None,\n    **extra_fields,\n)\nLog a queue event. The ‘event’ here can be any string describing the queue event.\n\n\n\nlogging.EventLogger.log_resource_use_end(\n    entity_id,\n    resource_id,\n    time=None,\n    pathway=None,\n    run_number=None,\n    **extra_fields,\n)\nLog the end of resource use. Requires resource_id.\n\n\n\nlogging.EventLogger.log_resource_use_start(\n    entity_id,\n    resource_id,\n    time=None,\n    pathway=None,\n    run_number=None,\n    **extra_fields,\n)\nLog the start of resource use. Requires resource_id.\n\n\n\nlogging.EventLogger.plot_entity_timeline(entity_id)\nPlot a timeline of events for a specific entity_id.\n\n\n\nlogging.EventLogger.to_csv(path_or_buffer)\nWrite the log to a CSV file.\n\n\n\nlogging.EventLogger.to_dataframe()\nConvert the event log to a pandas DataFrame.\n\n\n\nlogging.EventLogger.to_json(path_or_buffer, indent=2)\nWrite the event log to a JSON file or file-like buffer.\n\n\n\nlogging.EventLogger.to_json_string(indent=2)\nReturn the event log as a pretty JSON string.",
    "crumbs": [
      "vidigi Function Reference",
      "Event Logging Utility Functions and Classes",
      "logging.EventLogger"
    ]
  },
  {
    "objectID": "reference/logging.EventLogger.html#methods",
    "href": "reference/logging.EventLogger.html#methods",
    "title": "logging.EventLogger",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_events_by_entity\nReturn all events associated with a specific entity_id.\n\n\nget_events_by_event_name\nReturn all events of a specific event_type.\n\n\nget_events_by_event_type\nReturn all events of a specific event_type.\n\n\nget_events_by_run\nReturn all events associated with a specific entity_id.\n\n\nlog_arrival\nHelper to log an arrival event with the correct event_type and event fields.\n\n\nlog_custom_event\nLog a custom event. The ‘event’ here can be any string describing the queue event.\n\n\nlog_departure\nHelper to log a departure event with the correct event_type and event fields.\n\n\nlog_queue\nLog a queue event. The ‘event’ here can be any string describing the queue event.\n\n\nlog_resource_use_end\nLog the end of resource use. Requires resource_id.\n\n\nlog_resource_use_start\nLog the start of resource use. Requires resource_id.\n\n\nplot_entity_timeline\nPlot a timeline of events for a specific entity_id.\n\n\nto_csv\nWrite the log to a CSV file.\n\n\nto_dataframe\nConvert the event log to a pandas DataFrame.\n\n\nto_json\nWrite the event log to a JSON file or file-like buffer.\n\n\nto_json_string\nReturn the event log as a pretty JSON string.\n\n\n\n\n\nlogging.EventLogger.get_events_by_entity(entity_id, as_dataframe=True)\nReturn all events associated with a specific entity_id.\n\n\n\nlogging.EventLogger.get_events_by_event_name(event, as_dataframe=True)\nReturn all events of a specific event_type.\n\n\n\nlogging.EventLogger.get_events_by_event_type(event_type, as_dataframe=True)\nReturn all events of a specific event_type.\n\n\n\nlogging.EventLogger.get_events_by_run(run_number, as_dataframe=True)\nReturn all events associated with a specific entity_id.\n\n\n\nlogging.EventLogger.log_arrival(\n    entity_id,\n    time=None,\n    pathway=None,\n    run_number=None,\n    **extra_fields,\n)\nHelper to log an arrival event with the correct event_type and event fields.\n\n\n\nlogging.EventLogger.log_custom_event(\n    entity_id,\n    event_type,\n    event,\n    time=None,\n    pathway=None,\n    run_number=None,\n    **extra_fields,\n)\nLog a custom event. The ‘event’ here can be any string describing the queue event. An ‘event_type’ must also be passed, but can be any string of the user’s choosing.\n\n\n\nlogging.EventLogger.log_departure(\n    entity_id,\n    time=None,\n    pathway=None,\n    run_number=None,\n    **extra_fields,\n)\nHelper to log a departure event with the correct event_type and event fields.\n\n\n\nlogging.EventLogger.log_queue(\n    entity_id,\n    event,\n    time=None,\n    pathway=None,\n    run_number=None,\n    **extra_fields,\n)\nLog a queue event. The ‘event’ here can be any string describing the queue event.\n\n\n\nlogging.EventLogger.log_resource_use_end(\n    entity_id,\n    resource_id,\n    time=None,\n    pathway=None,\n    run_number=None,\n    **extra_fields,\n)\nLog the end of resource use. Requires resource_id.\n\n\n\nlogging.EventLogger.log_resource_use_start(\n    entity_id,\n    resource_id,\n    time=None,\n    pathway=None,\n    run_number=None,\n    **extra_fields,\n)\nLog the start of resource use. Requires resource_id.\n\n\n\nlogging.EventLogger.plot_entity_timeline(entity_id)\nPlot a timeline of events for a specific entity_id.\n\n\n\nlogging.EventLogger.to_csv(path_or_buffer)\nWrite the log to a CSV file.\n\n\n\nlogging.EventLogger.to_dataframe()\nConvert the event log to a pandas DataFrame.\n\n\n\nlogging.EventLogger.to_json(path_or_buffer, indent=2)\nWrite the event log to a JSON file or file-like buffer.\n\n\n\nlogging.EventLogger.to_json_string(indent=2)\nReturn the event log as a pretty JSON string.",
    "crumbs": [
      "vidigi Function Reference",
      "Event Logging Utility Functions and Classes",
      "logging.EventLogger"
    ]
  },
  {
    "objectID": "reference/prep.reshape_for_animations.html",
    "href": "reference/prep.reshape_for_animations.html",
    "title": "prep.reshape_for_animations",
    "section": "",
    "text": "prep.reshape_for_animations(\n    event_log,\n    every_x_time_units=10,\n    limit_duration=10 * 60 * 24,\n    step_snapshot_max=50,\n    time_col_name='time',\n    entity_col_name='entity_id',\n    event_type_col_name='event_type',\n    event_col_name='event',\n    pathway_col_name=None,\n    debug_mode=False,\n)\nReshape event log data for animation purposes.\nThis function processes an event log to create a series of snapshots at regular time intervals, suitable for creating animations of patient flow through a system.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nevent_log\npd.DataFrame\nThe input event log containing entity events and timestamps in the form of a number of time units since the simulation began.\nrequired\n\n\nevery_x_time_units\nint\nThe time interval between snapshots in preferred time units (default is 10).\n10\n\n\nlimit_duration\nint\nThe maximum duration to consider in preferred time units (default is 10 days).\n10 * 60 * 24\n\n\nstep_snapshot_max\nint\nThe maximum number of entities to include in each snapshot for each event (default is 50).\n50\n\n\ntime_col_name\nstr\nName of the column in event_log that contains the timestamp of each event. Timestamps should represent the number of time units since the simulation began.\n\"time\"\n\n\nentity_col_name\nstr\nName of the column in event_log that contains the unique identifier for each entity (e.g., “entity_id”, “entity”, “patient”, “patient_id”, “customer”, “ID”).\n\"entity_id\"\n\n\nevent_type_col_name\nstr\nName of the column in event_log that specifies the category of the event. Supported event types include ‘arrival_departure’, ‘resource_use’, ‘resource_use_end’, and ‘queue’.\n\"event_type\"\n\n\nevent_col_name\nstr\nName of the column in event_log that specifies the actual event that occurred.\n\"event\"\n\n\npathway_col_name\nstr\nName of the column in event_log that identifies the specific pathway or process flow the entity is following. If None, it is assumed that pathway information is not present.\nNone\n\n\ndebug_mode\nbool\nIf True, print debug information during processing (default is False).\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nDataFrame\nA reshaped DataFrame containing snapshots of entity positions at regular time intervals, sorted by minute and event.\n\n\n\n\n\n\n\nThe function creates snapshots of entity positions at specified time intervals.\nIt handles entities who are present in the system at each snapshot time.\nEntities are ranked within each event based on their arrival order.\nA maximum number of patients per event can be set to limit the number of entities who will be displayed on screen within any one event type at a time.\nAn ‘exit’ event is added for each entity at the end of their journey.\nThe function uses memory management techniques (del and gc.collect()) to handle large datasets.\n\n\n\n\n\nAdd behavior for when limit_duration is None.\nConsider adding ‘first step’ and ‘last step’ parameters.\nImplement pathway order and precedence columns.\nFix the automatic exit at the end of the simulation run for all entities.",
    "crumbs": [
      "vidigi Function Reference",
      "Step-By-Step Functions",
      "prep.reshape_for_animations"
    ]
  },
  {
    "objectID": "reference/prep.reshape_for_animations.html#parameters",
    "href": "reference/prep.reshape_for_animations.html#parameters",
    "title": "prep.reshape_for_animations",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nevent_log\npd.DataFrame\nThe input event log containing entity events and timestamps in the form of a number of time units since the simulation began.\nrequired\n\n\nevery_x_time_units\nint\nThe time interval between snapshots in preferred time units (default is 10).\n10\n\n\nlimit_duration\nint\nThe maximum duration to consider in preferred time units (default is 10 days).\n10 * 60 * 24\n\n\nstep_snapshot_max\nint\nThe maximum number of entities to include in each snapshot for each event (default is 50).\n50\n\n\ntime_col_name\nstr\nName of the column in event_log that contains the timestamp of each event. Timestamps should represent the number of time units since the simulation began.\n\"time\"\n\n\nentity_col_name\nstr\nName of the column in event_log that contains the unique identifier for each entity (e.g., “entity_id”, “entity”, “patient”, “patient_id”, “customer”, “ID”).\n\"entity_id\"\n\n\nevent_type_col_name\nstr\nName of the column in event_log that specifies the category of the event. Supported event types include ‘arrival_departure’, ‘resource_use’, ‘resource_use_end’, and ‘queue’.\n\"event_type\"\n\n\nevent_col_name\nstr\nName of the column in event_log that specifies the actual event that occurred.\n\"event\"\n\n\npathway_col_name\nstr\nName of the column in event_log that identifies the specific pathway or process flow the entity is following. If None, it is assumed that pathway information is not present.\nNone\n\n\ndebug_mode\nbool\nIf True, print debug information during processing (default is False).\nFalse",
    "crumbs": [
      "vidigi Function Reference",
      "Step-By-Step Functions",
      "prep.reshape_for_animations"
    ]
  },
  {
    "objectID": "reference/prep.reshape_for_animations.html#returns",
    "href": "reference/prep.reshape_for_animations.html#returns",
    "title": "prep.reshape_for_animations",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nDataFrame\nA reshaped DataFrame containing snapshots of entity positions at regular time intervals, sorted by minute and event.",
    "crumbs": [
      "vidigi Function Reference",
      "Step-By-Step Functions",
      "prep.reshape_for_animations"
    ]
  },
  {
    "objectID": "reference/prep.reshape_for_animations.html#notes",
    "href": "reference/prep.reshape_for_animations.html#notes",
    "title": "prep.reshape_for_animations",
    "section": "",
    "text": "The function creates snapshots of entity positions at specified time intervals.\nIt handles entities who are present in the system at each snapshot time.\nEntities are ranked within each event based on their arrival order.\nA maximum number of patients per event can be set to limit the number of entities who will be displayed on screen within any one event type at a time.\nAn ‘exit’ event is added for each entity at the end of their journey.\nThe function uses memory management techniques (del and gc.collect()) to handle large datasets.",
    "crumbs": [
      "vidigi Function Reference",
      "Step-By-Step Functions",
      "prep.reshape_for_animations"
    ]
  },
  {
    "objectID": "reference/prep.reshape_for_animations.html#todo",
    "href": "reference/prep.reshape_for_animations.html#todo",
    "title": "prep.reshape_for_animations",
    "section": "",
    "text": "Add behavior for when limit_duration is None.\nConsider adding ‘first step’ and ‘last step’ parameters.\nImplement pathway order and precedence columns.\nFix the automatic exit at the end of the simulation run for all entities.",
    "crumbs": [
      "vidigi Function Reference",
      "Step-By-Step Functions",
      "prep.reshape_for_animations"
    ]
  },
  {
    "objectID": "reference/resources.VidigiPriorityStore.html",
    "href": "reference/resources.VidigiPriorityStore.html",
    "title": "resources.VidigiPriorityStore",
    "section": "",
    "text": "resources.VidigiPriorityStore(\n    self,\n    env,\n    num_resources=None,\n    capacity=float('inf'),\n)\nAn optimized SimPy priority store that eliminates delays between resource release and acquisition by directly triggering waiting events.\nThis implementation provides the same API as the original VidigiPriorityStore but with immediate resource handoff between processes.\nAI USE DISCLOSURE: This code was generated by Claude 3.7 Sonnet. It has been evaluated and tested by a human.\n\n\n\n\n\nName\nDescription\n\n\n\n\ncancel_get\nCancels a pending get request by removing it from the queue.\n\n\nget\nCreate an event to get an item from the store.\n\n\nget_direct\nGet an item from the store without the context manager.\n\n\npopulate\nPopulate this VidigiPriorityStore with VidigiResource objects.\n\n\nput\nPut an item into the store.\n\n\nrequest\nRequest context manager for getting an item from the store.\n\n\nrequest_direct\nAlias for get_direct() to maintain consistent API.\n\n\nreturn_item\nReturn an item to the store and immediately process any waiting get requests.\n\n\n\n\n\nresources.VidigiPriorityStore.cancel_get(get_event)\nCancels a pending get request by removing it from the queue.\n\n\n\nresources.VidigiPriorityStore.get(priority=0)\nCreate an event to get an item from the store.\nArgs: priority: Lower values indicate higher priority (default: 0)\nReturns: A get event that can be yielded\n\n\n\nresources.VidigiPriorityStore.get_direct(priority=0)\nGet an item from the store without the context manager. Use this if you don’t want to automatically return the item.\nReturns: A get event that can be yielded\n\n\n\nresources.VidigiPriorityStore.populate(num_resources)\nPopulate this VidigiPriorityStore with VidigiResource objects.\nCreates num_resources VidigiResource objects and adds them to this store.\nEach VidigiResource is initialized with a capacity of 1 and a unique ID starting at 1.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnum_resources\nint\nThe number of VidigiResource objects to create and add to the store.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nresources.VidigiPriorityStore.put(item)\nPut an item into the store.\nArgs: item: The item to put in the store\nReturns: A put event that can be yielded\n\n\n\nresources.VidigiPriorityStore.request(priority=0)\nRequest context manager for getting an item from the store. The item is automatically returned when exiting the context.\nArgs: priority: Lower values indicate higher priority (default: 0)\nReturns: A context manager that yields the get event and handles item return\n\n\n\nresources.VidigiPriorityStore.request_direct(priority=0)\nAlias for get_direct() to maintain consistent API.\nReturns: A get event that can be yielded\n\n\n\nresources.VidigiPriorityStore.return_item(item)\nReturn an item to the store and immediately process any waiting get requests.\nThis is the key to eliminating delays - it directly triggers waiting get requests without going through the normal put/get mechanism.\nArgs: item: The item to return to the store",
    "crumbs": [
      "vidigi Function Reference",
      "Simpy Resource Classes",
      "resources.VidigiPriorityStore"
    ]
  },
  {
    "objectID": "reference/resources.VidigiPriorityStore.html#methods",
    "href": "reference/resources.VidigiPriorityStore.html#methods",
    "title": "resources.VidigiPriorityStore",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncancel_get\nCancels a pending get request by removing it from the queue.\n\n\nget\nCreate an event to get an item from the store.\n\n\nget_direct\nGet an item from the store without the context manager.\n\n\npopulate\nPopulate this VidigiPriorityStore with VidigiResource objects.\n\n\nput\nPut an item into the store.\n\n\nrequest\nRequest context manager for getting an item from the store.\n\n\nrequest_direct\nAlias for get_direct() to maintain consistent API.\n\n\nreturn_item\nReturn an item to the store and immediately process any waiting get requests.\n\n\n\n\n\nresources.VidigiPriorityStore.cancel_get(get_event)\nCancels a pending get request by removing it from the queue.\n\n\n\nresources.VidigiPriorityStore.get(priority=0)\nCreate an event to get an item from the store.\nArgs: priority: Lower values indicate higher priority (default: 0)\nReturns: A get event that can be yielded\n\n\n\nresources.VidigiPriorityStore.get_direct(priority=0)\nGet an item from the store without the context manager. Use this if you don’t want to automatically return the item.\nReturns: A get event that can be yielded\n\n\n\nresources.VidigiPriorityStore.populate(num_resources)\nPopulate this VidigiPriorityStore with VidigiResource objects.\nCreates num_resources VidigiResource objects and adds them to this store.\nEach VidigiResource is initialized with a capacity of 1 and a unique ID starting at 1.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnum_resources\nint\nThe number of VidigiResource objects to create and add to the store.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nNone\n\n\n\n\n\n\n\n\nresources.VidigiPriorityStore.put(item)\nPut an item into the store.\nArgs: item: The item to put in the store\nReturns: A put event that can be yielded\n\n\n\nresources.VidigiPriorityStore.request(priority=0)\nRequest context manager for getting an item from the store. The item is automatically returned when exiting the context.\nArgs: priority: Lower values indicate higher priority (default: 0)\nReturns: A context manager that yields the get event and handles item return\n\n\n\nresources.VidigiPriorityStore.request_direct(priority=0)\nAlias for get_direct() to maintain consistent API.\nReturns: A get event that can be yielded\n\n\n\nresources.VidigiPriorityStore.return_item(item)\nReturn an item to the store and immediately process any waiting get requests.\nThis is the key to eliminating delays - it directly triggers waiting get requests without going through the normal put/get mechanism.\nArgs: item: The item to return to the store",
    "crumbs": [
      "vidigi Function Reference",
      "Simpy Resource Classes",
      "resources.VidigiPriorityStore"
    ]
  },
  {
    "objectID": "reference/resources.VidigiResource.html",
    "href": "reference/resources.VidigiResource.html",
    "title": "resources.VidigiResource",
    "section": "",
    "text": "resources.VidigiResource\nresources.VidigiResource(self, id_attribute=None, **kwargs)\nA simple resource class with an ID attribute for use in VidigiStore and VidigiPriorityStore.\nThis represents a resource that can be stored and retrieved from a store, with an identifier for tracking purposes.\nAccepts additional attributes as kwargs.",
    "crumbs": [
      "vidigi Function Reference",
      "Simpy Resource Classes",
      "resources.VidigiResource"
    ]
  },
  {
    "objectID": "reference/utils.create_event_position_df.html",
    "href": "reference/utils.create_event_position_df.html",
    "title": "utils.create_event_position_df",
    "section": "",
    "text": "utils.create_event_position_df\nutils.create_event_position_df(event_positions)\nCreates a DataFrame for event positions from a list of EventPosition objects.\nArgs: event_positions (List[EventPosition]): A list of EventPoisitions.\nReturns: pd.DataFrame: A DataFrame with the specified columns and data types.\nRaises: ValidationError: If the input data does not match the EventPosition model.",
    "crumbs": [
      "vidigi Function Reference",
      "Event Positioning Utility Functions and Classes",
      "utils.create_event_position_df"
    ]
  },
  {
    "objectID": "reference/utils.EventLogger.html",
    "href": "reference/utils.EventLogger.html",
    "title": "utils.EventLogger",
    "section": "",
    "text": "utils.EventLogger(self, event_model=BaseEvent, env=None)\n\n\n\n\n\nName\nDescription\n\n\n\n\nget_events_by_entity\nReturn all events associated with a specific entity_id.\n\n\nget_events_by_type\nReturn all events of a specific event_type.\n\n\nto_csv\nWrite the log to a CSV file.\n\n\nto_dataframe\nConvert the event log to a pandas DataFrame.\n\n\nto_json\nWrite the event log to a JSON file or file-like buffer.\n\n\nto_json_string\nReturn the event log as a pretty JSON string.\n\n\n\n\n\nutils.EventLogger.get_events_by_entity(entity_id, as_dataframe=True)\nReturn all events associated with a specific entity_id.\n\n\n\nutils.EventLogger.get_events_by_type(event_type, as_dataframe=True)\nReturn all events of a specific event_type.\n\n\n\nutils.EventLogger.to_csv(path_or_buffer)\nWrite the log to a CSV file.\n\n\n\nutils.EventLogger.to_dataframe()\nConvert the event log to a pandas DataFrame.\n\n\n\nutils.EventLogger.to_json(path_or_buffer, indent=2)\nWrite the event log to a JSON file or file-like buffer.\n\n\n\nutils.EventLogger.to_json_string(indent=2)\nReturn the event log as a pretty JSON string."
  },
  {
    "objectID": "reference/utils.EventLogger.html#methods",
    "href": "reference/utils.EventLogger.html#methods",
    "title": "utils.EventLogger",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nget_events_by_entity\nReturn all events associated with a specific entity_id.\n\n\nget_events_by_type\nReturn all events of a specific event_type.\n\n\nto_csv\nWrite the log to a CSV file.\n\n\nto_dataframe\nConvert the event log to a pandas DataFrame.\n\n\nto_json\nWrite the event log to a JSON file or file-like buffer.\n\n\nto_json_string\nReturn the event log as a pretty JSON string.\n\n\n\n\n\nutils.EventLogger.get_events_by_entity(entity_id, as_dataframe=True)\nReturn all events associated with a specific entity_id.\n\n\n\nutils.EventLogger.get_events_by_type(event_type, as_dataframe=True)\nReturn all events of a specific event_type.\n\n\n\nutils.EventLogger.to_csv(path_or_buffer)\nWrite the log to a CSV file.\n\n\n\nutils.EventLogger.to_dataframe()\nConvert the event log to a pandas DataFrame.\n\n\n\nutils.EventLogger.to_json(path_or_buffer, indent=2)\nWrite the event log to a JSON file or file-like buffer.\n\n\n\nutils.EventLogger.to_json_string(indent=2)\nReturn the event log as a pretty JSON string."
  },
  {
    "objectID": "reference/utils.event_log_from_ciw_recs.html",
    "href": "reference/utils.event_log_from_ciw_recs.html",
    "title": "utils.event_log_from_ciw_recs",
    "section": "",
    "text": "utils.event_log_from_ciw_recs(ciw_recs_obj, node_name_list)\nGiven the ciw recs object, return a dataframe in the format expected by the vidigi functions - reshape_for_animation OR - animate_activity_log\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nciw_recs_obj\n\nThe output of the .get_all_records() method run on the ciw simulation object. This is a list of named tuples. See https://ciw.readthedocs.io/en/latest/Tutorial/GettingStarted/part_3.html and https://ciw.readthedocs.io/en/latest/Reference/results.html for more details.\nrequired\n\n\nnode_name_list\n\nUser-defined list of strings where each string relates to the resource or activity that will take place at that ciw node\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\npd.DataFrame\n\n\n\n\n\n\n\nGiven the ciw recs object, if we know the nodes and what they relate to, we can build up a picture the arrival date for the first tuple for a given user ID is the arrival\nThen, for each node: - the arrival date for a given node is when they start queueing - the service start date is when they stop queueing - the service start date is when they begin using the resource - the service end date is when the resource use ends - the server ID is the equivalent of a simpy resource use ID\nA more complex multi-node example can be found in https://github.com/Bergam0t/ciw-example-animation in the files - ciw_model.py - vidigi_experiments.py"
  },
  {
    "objectID": "reference/utils.event_log_from_ciw_recs.html#parameters",
    "href": "reference/utils.event_log_from_ciw_recs.html#parameters",
    "title": "utils.event_log_from_ciw_recs",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nciw_recs_obj\n\nThe output of the .get_all_records() method run on the ciw simulation object. This is a list of named tuples. See https://ciw.readthedocs.io/en/latest/Tutorial/GettingStarted/part_3.html and https://ciw.readthedocs.io/en/latest/Reference/results.html for more details.\nrequired\n\n\nnode_name_list\n\nUser-defined list of strings where each string relates to the resource or activity that will take place at that ciw node\nrequired"
  },
  {
    "objectID": "reference/utils.event_log_from_ciw_recs.html#returns",
    "href": "reference/utils.event_log_from_ciw_recs.html#returns",
    "title": "utils.event_log_from_ciw_recs",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\npd.DataFrame"
  },
  {
    "objectID": "reference/utils.event_log_from_ciw_recs.html#notes",
    "href": "reference/utils.event_log_from_ciw_recs.html#notes",
    "title": "utils.event_log_from_ciw_recs",
    "section": "",
    "text": "Given the ciw recs object, if we know the nodes and what they relate to, we can build up a picture the arrival date for the first tuple for a given user ID is the arrival\nThen, for each node: - the arrival date for a given node is when they start queueing - the service start date is when they stop queueing - the service start date is when they begin using the resource - the service end date is when the resource use ends - the server ID is the equivalent of a simpy resource use ID\nA more complex multi-node example can be found in https://github.com/Bergam0t/ciw-example-animation in the files - ciw_model.py - vidigi_experiments.py"
  },
  {
    "objectID": "reference/utils.streamlit_play_all.html",
    "href": "reference/utils.streamlit_play_all.html",
    "title": "utils.streamlit_play_all",
    "section": "",
    "text": "utils.streamlit_play_all()\nProgrammatically triggers all ‘Play’ buttons in Plotly animations embedded in Streamlit using JavaScript.\nThis function uses the streamlit_javascript package to inject JavaScript that simulates user interaction with Plotly animation controls (specifically the play buttons) in a Streamlit app. It searches the parent document for all elements that resemble play buttons and simulates click events on them.\nThe function is useful when you have Plotly charts with animation frames and want to automatically start all animations without requiring manual user clicks.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nImportError\nIf the streamlit_javascript package is not installed. The package is required to run JavaScript within the Streamlit environment. It can be installed with: pip install vidigi[helper]\n\n\n\n\n\n\n\nThere is often some small lag in triggering multiple buttons. At present, there seems to be no way to avoid this!\nThe JavaScript is injected as a promise that logs progress to the browser console.\nIf no play buttons are found, an error is logged to the console.\nThis function assumes the presence of Plotly figures with updatemenu buttons in the DOM.",
    "crumbs": [
      "vidigi Function Reference",
      "Streamlit Utility Functions",
      "utils.streamlit_play_all"
    ]
  },
  {
    "objectID": "reference/utils.streamlit_play_all.html#raises",
    "href": "reference/utils.streamlit_play_all.html#raises",
    "title": "utils.streamlit_play_all",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nImportError\nIf the streamlit_javascript package is not installed. The package is required to run JavaScript within the Streamlit environment. It can be installed with: pip install vidigi[helper]",
    "crumbs": [
      "vidigi Function Reference",
      "Streamlit Utility Functions",
      "utils.streamlit_play_all"
    ]
  },
  {
    "objectID": "reference/utils.streamlit_play_all.html#notes",
    "href": "reference/utils.streamlit_play_all.html#notes",
    "title": "utils.streamlit_play_all",
    "section": "",
    "text": "There is often some small lag in triggering multiple buttons. At present, there seems to be no way to avoid this!\nThe JavaScript is injected as a promise that logs progress to the browser console.\nIf no play buttons are found, an error is logged to the console.\nThis function assumes the presence of Plotly figures with updatemenu buttons in the DOM.",
    "crumbs": [
      "vidigi Function Reference",
      "Streamlit Utility Functions",
      "utils.streamlit_play_all"
    ]
  },
  {
    "objectID": "reference/utils.VidigiPriorityStoreLegacy.html",
    "href": "reference/utils.VidigiPriorityStoreLegacy.html",
    "title": "utils.VidigiPriorityStoreLegacy",
    "section": "",
    "text": "utils.VidigiPriorityStoreLegacy()\nA SimPy store that processes requests with priority.\nThis class extends the SimPy Store to include a priority queue for handling requests. Requests are processed based on their priority, submission time, and preemption flag.\nAttributes: GetQueue (class): A reference to the sorted queue implementation used for handling prioritized requests. get (class): A reference to the PriorityGet class, which handles the creation of prioritized requests.\n\n\nCredit to arabinelli # https://stackoverflow.com/questions/58603000/how-do-i-make-a-priority-get-request-from-resource-store"
  },
  {
    "objectID": "reference/utils.VidigiPriorityStoreLegacy.html#notes",
    "href": "reference/utils.VidigiPriorityStoreLegacy.html#notes",
    "title": "utils.VidigiPriorityStoreLegacy",
    "section": "",
    "text": "Credit to arabinelli # https://stackoverflow.com/questions/58603000/how-do-i-make-a-priority-get-request-from-resource-store"
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 1.0.0 and above",
    "section": "",
    "text": "On the Health Service Modelling Associates (HSMA) course we teach a particular way of writing your simpy models. More details of the approach we take can be found in our Little Book of DES.\nHowever, the core concepts of adding vidigi to your models will be the same across different models - so this example will hopefully be helpful regardless of the way you structure your simpy models.\nThe model on this page has been adapted from Monks, released under the MIT Licence",
    "crumbs": [
      "Walkthroughs",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 1.0.0 and above"
    ]
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#vidigis-requirements",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#vidigis-requirements",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 1.0.0 and above",
    "section": "Vidigi’s requirements",
    "text": "Vidigi’s requirements\nThe key input vidigi requires an event log of the times that each entity in your system reached key milestones like arriving in the system, beginning to queue for a resource, being seen by a resource, and exiting the system.\nWe also need to tell vidigi what kind of activity is happening at each point:\n\narrive/depart\nqueue\nresource_use\n\nWe also provide vidigi with a table of coordinates that will help it to lay out our entities and resources, and determine their path from the entrance, to the exit, and to some extent their movement between stages.\nVidigi then takes this event log and the layout table and will process them into a table that tracks the position of every entity in the system at specified time intervals.",
    "crumbs": [
      "Walkthroughs",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 1.0.0 and above"
    ]
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#hsma-model-structure",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#hsma-model-structure",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 1.0.0 and above",
    "section": "HSMA Model Structure",
    "text": "HSMA Model Structure\nIn HSMA, we use four primary classes to structure our models:\n\ng, which stores model parameters (like the number of resources of a given type and distribution parameters) and simulation parameters (like the number of replications to run and the )\nEntity, which may be named something more descriptive like ‘Patient’ or ‘Customer’. You may also have more than one entity class. Each entity will store information such as its ID, and will be passed into the model to work through the pathway.\nModel, which will generate entities, simulate the pathway the entity takes through the system, and contain a way to run a single replication of the model\nTrial, which allows us to run the simulation multiple times, collect results from all of these, and get an indication of average performance and performance variation across our different model runs",
    "crumbs": [
      "Walkthroughs",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 1.0.0 and above"
    ]
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#a-simple-model",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#a-simple-model",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 1.0.0 and above",
    "section": "A Simple Model",
    "text": "A Simple Model\nWe’re going to start off with a very simple model of a walk-in clinic pathway.\nIn this clinic, patients arrive and are seen in the order they arrive by one of several available nurses. All nurses have the same skillset, so the queue is a simple first-in-first-out (FIFO). There is some variability in the arrival time of patients, as well as variability in how long it takes for each patient to be seen.\n\nthe g Class\nIn our g class, we set up parameters that will be used throughout.\n\nclass g:\n    n_cubicles = 3 # The number of treatment cubicles\n    trauma_treat_mean = 40 # Mean of the trauma cubicle treatment distribution (Lognormal)\n    trauma_treat_var = 5 # Variance of the trauma cubicle treatment distribution (Lognormal)\n\n    arrival_rate = 5 # mean of the exponential distribution for sampling the inter-arrival time of entities\n\n    # Simulation running parameters\n    sim_duration = 600 # The number of time units the simulation will run for\n    number_of_runs = 100 # The number of times the simulation will be run with different random number streams\n    random_number_set = 42 # Control the randomness in our distributions\n\n\n\nthe Patient Class\nOur Patient class represents a single individual.\nThe attributes in this class are used to track various metrics that will be used for determining how well our particular scenario has performed - think of it like a person holding a clipboard that is having various times and figures recorded on it as they move through the system.\n\nclass Patient:\n    def __init__(self, p_id):\n        self.identifier = p_id\n        self.arrival = -np.inf\n        self.wait_treat = -np.inf\n        self.total_time = -np.inf\n        self.treat_duration = -np.inf\n\n\n\nthe Model Class\nOur model class is more complex.\n\nthe init method\nFirst, we set up a series of attributes.\n\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create an empty list to store our patient objects - these can be handy\n        # to look at later\n        self.patients = []\n\n        # Create our resources\n        self.init_resources()\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create our distributions\n        # 1. for patient inter-arrival time\n        self.patient_inter_arrival_dist = Exponential(\n            mean = g.arrival_rate,\n            # Set a random seed that will vary across runs\n            # (this isn't the best way to set this - but will do for this example!)\n            random_seed = (self.run_number + 1) * g.random_number_set\n            )\n        # 2. for the duration of patient treatments\n        self.treat_dist = Lognormal(\n            mean = g.trauma_treat_mean,\n            stdev = g.trauma_treat_var,\n            random_seed = (self.run_number + 1) * g.random_number_set\n            )\n\n\n\nthe init_resources method\nNext, we make sure to initialise our resources. We are using a simple simpy resource with a capacity of a given number of slots - defined in our g class.\n\n    def init_resources(self):\n        '''\n        Init the number of resources\n\n        Resource list:\n            1. Nurses/treatment bays (same thing in this model)\n\n        '''\n        self.treatment_cubicles = simpy.Resource(self.env, capacity=g.n_cubicles)\n\n\n\nthe generator_patient_arrivals method\nHere we will write the loop that manages the generation of patient objects, with waits between each patient being informed by our exponential distribution.\nThis also sends the patients off on their individual journies - but we haven’t written that method yet!\n\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            # Store patient in our patient list for later easy access\n            self.patients.append(p)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival times)\n            sampled_inter = self.patient_inter_arrival_dist.sample()\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.\n            # Note - time in SimPy progresses in \"Time Units\", which can represent anything\n            # you like - just make sure you're consistent within the model\n            yield self.env.timeout(sampled_inter)\n\n\n\nthe attend_clinic function\nThis is the function that will send the patient through the system, using the resource (our cubicles/nurses) and recording a few things about their journey in their patient attributes.\n\n    def attend_clinic(self, patient):\n        patient.arrival = self.env.now\n\n        # request examination resource\n        start_wait = self.env.now\n\n        with self.treatment_cubicles.request() as req:\n            # Seize a treatment resource when available\n            yield req\n\n            # record the waiting time for treatment\n            patient.wait_treat = self.env.now - start_wait\n\n            # sample treatment duration\n            patient.treat_duration = self.treat_dist.sample()\n\n            yield self.env.timeout(patient.treat_duration)\n\n        # total time in system\n        patient.total_time = self.env.now - patient.arrival\n\n\n\nthe run function\nFinally, we define a function to undertake a single run of the model.\n\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n\n\n\nthe Trial Class\nOur trial class is where we manage running the simulation multiple times - so we can get a better idea of how our system will cope when inter-arrival times and treatment durations vary within reasonable bounds.\n\nthe init method\nWe’ll set up a dataframe to help track metrics of interest across the runs.\n\ndef  __init__(self):\n    self.df_trial_results = pd.DataFrame()\n    self.df_trial_results[\"Run Number\"] = [0]\n    self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n    self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n\n\nThe run_trial method\nRun the simulation for the number of runs specified in g class.\nFor each run, we create a new instance of the Model class and call its run method, which sets everything else in motion.\nOnce the run has completed, we grab out the stored run results (just mean queuing time here) and store it against the run number in the trial results dataframe.\n\n    def run_trial(self):\n\n        for run in range(1, g.number_of_runs+1):\n            my_model = Model(run)\n            my_model.run()\n\n            self.df_trial_results.loc[run] = (\n                # take the mean average (add up all values and divide by the number of values)\n                np.mean(\n                    [patient.wait_treat # grab the individual patient's wait time...\n                    for patient # for every patient...\n                    in my_model.patients] # in our list of patient objects\n                    )\n            )\n\n        return self.df_trial_results",
    "crumbs": [
      "Walkthroughs",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 1.0.0 and above"
    ]
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#making-changes-for-vidigi",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#making-changes-for-vidigi",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 1.0.0 and above",
    "section": "Making Changes for Vidigi",
    "text": "Making Changes for Vidigi\n\nimports\nWe will want to import a few additional things from vidigi’s functions.\n\n\n\nOriginal\n\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\nfrom sim_tools.distributions import Exponential, Lognormal\n\n\n\n\n\n\nWith Vidigi Modifications\n\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\nfrom sim_tools.distributions import Exponential, Lognormal\nfrom vidigi.resources import VidigiStore \nfrom vidigi.logging import EventLogger \nfrom vidigi.utils import EventPosition, create_event_position_df \nfrom vidigi.animation import animate_activity_log \n\n\n\n\nInstead of importing each of these separately, we could do import vidigi and then refer to the relevant parts with their full names in the code. For example, to access VidigiStore, we’d use vidigi.resources.VidigiStore.\nIt’s up to you - but importing only the relevant functions and classes upfront can make your later code neater.\n\n\nthe g Class\nOur g class is unchanged.\n\n\nthe Entity Class\nOur entity class - in this case, Patient - is unchanged.\n\n\nthe Model Class\n\nThe init method\nTo our init method for the Model class, we add an instance of the vidigi EventLogger class that will help us to generate our event logs.\n\n\n\nOriginal\n\ndef __init__(self, run_number):\n    # Create a SimPy environment in which everything will live\n    self.env = simpy.Environment()\n\n    # Create a patient counter (which we'll use as a patient ID)\n    self.patient_counter = 0\n\n    # Create an empty list to store our patient objects - these can be handy\n    # to look at later\n    self.patients = []\n\n    # Create our resources\n    self.init_resources()\n\n    # Store the passed in run number\n    self.run_number = run_number\n\n    # Create our distributions\n    # 1. for patient inter-arrival time\n    self.patient_inter_arrival_dist = Exponential(\n        mean = g.arrival_rate,\n        # Set a random seed that will vary across runs\n        # (this isn't the best way to set this - but will do for this example!)\n        random_seed = (self.run_number + 1) * g.random_number_set\n        )\n    # 2. for the duration of patient treatments\n    self.treat_dist = Lognormal(\n        mean = g.trauma_treat_mean,\n        stdev = g.trauma_treat_var,\n        random_seed = (self.run_number + 1) * g.random_number_set\n        )\n\n\n\n\n\n\nWith Vidigi Modifications\n\ndef __init__(self, run_number):\n    # Create a SimPy environment in which everything will live\n    self.env = simpy.Environment()\n\n    # Store the passed in run number\n    self.run_number = run_number\n\n    # Create a patient counter (which we'll use as a patient ID)\n    self.patient_counter = 0\n\n    # Create an empty list to store our patient objects - these can be handy\n    # to look at later\n    self.patients = []\n\n    # Create our resources\n    self.init_resources()\n\n    # Create our distributions\n    # 1. for patient inter-arrival time\n    self.patient_inter_arrival_dist = Exponential(\n        mean = g.arrival_rate,\n        # Set a random seed that will vary across runs\n        # (this isn't the best way to set this - but will do for this example!)\n        random_seed = (self.run_number + 1) * g.random_number_set\n        )\n    # 2. for the duration of patient treatments\n    self.treat_dist = Lognormal(\n        mean = g.trauma_treat_mean,\n        stdev = g.trauma_treat_var,\n        random_seed = (self.run_number + 1) * g.random_number_set\n        )\n\n    # By passing in the env we've created, the logger \n    # will default to the   \n    # simulation time when populating the   \n    # time column of our event logs  \n    # Passing the run number also ensures we can  \n    # separate out different runs  \n    # of the simulation in our later calculations \n    self.logger = EventLogger( \n        env=self.env,  \n        run_number=self.run_number \n        ) \n\n\n\n\n\n\nthe init_resources method\nVidigi needs to know which resource a user made use of so that we can ensure it stays with the correct resource throughout its time in the animation.\nThe standard simpy Resource does not have a way of tracking that, so we need to use a special store type provided by Vidigi that allows us to track resource IDs - without having to change our code as much as we would with a standard Simpy store.\nIf you are using priority resources, this step will be a little different - see Example 3 in the documents if you need to use Resources that prioritise some entities over others. Vidigi also provides a class for that - the VidigiPriorityStore.\n\n\n\nOriginal\n\ndef init_resources(self):\n    self.treatment_cubicles = simpy.Resource(\n        self.env,\n        capacity=g.n_cubicles\n        )\n\n\n\n\n\n\nWith Vidigi Modifications\n\ndef init_resources(self):\n    self.treatment_cubicles = VidigiStore( \n        self.env, \n        num_resources=g.n_cubicles \n        ) \n\n\n\n\n\n\nthe generator_patient_arrivals method\nThis method is unchanged.\n\n\nthe attend_clinic method\nThis is the key place in which we add our logging. The logs are what vidigi relies on to calculate who should be where, when, within the animation.\nThis is also where we need to slightly change the way we request resources to allow us to access their ID attribute.\nWhere we would have previously used\n\nwith self.treatment_cubicles.request() as req:\n    # Seize a treatment resource when available\n    yield req\n\n    # ALL CODE WHERE WE NEED TO KEEP HOLD OF THE RESOURCE\n\n# CONTINUE AFTER RELEASING RESOURCE HERE\n\nwe instead now use\n\nwith self.treatment_cubicles.request() as req:\n    # Seize a treatment resource when available\n    treatment_cubicle = yield req\n\n    # ALL CODE WHERE WE NEED TO KEEP HOLD OF THE RESOURCE\n\n# CONTINUE AFTER RELEASING RESOURCE HERE\n\ni.e. we just make sure we assign the result of yield req to a variable - in this case we call it treatment_cubicle to reflect the fact that it’s an individual treatment cubicle being returned.\nFor logging, vidigi provides a series of helper methods to make sure that we record the logs in the way it’s expecting.\nRemember - we set up an instance of the vidigi EventLogger class in our __init__ method of our model, calling it logger.\nTherefore we will access these helpers like so:\n\nself.logger.log_arrival()\nself.logger.log_queue()\nself.logger.log_resource_use_start()\nself.logger.log_resource_use_end()\nself.logger.log_departure()\n\nThese are all of the key steps you are likely to need to log in a standard model\n\nwhen people arrive\nwhen they begin waiting for something to happen\nwhen they are using a resource\nwhen they finish using that resource\nwhen they leave\n\nYou can have multiple instances of queues and resource use within your logs per entity.\nHowever, each entity should have only one arrival and one departure.\nFor arrivals and departures, only the entity ID - our patient ID, in this case - needs to be passed in.\nFor queues, we need to provide an event name to the event parameter to identify the step later on.\nFor resource use (both start and end), we need to provide an event name to the event parameter, and also provide a resource_id so that we are tracking which resource is in use when - which is why we needed to make the change to use the VidigiStore earlier.\nBecause we passed in the simpy simulation environment when setting up our logger, it will automatically take the sim time via env.now when we record an entry with any of these logging entry functions - so you don’t have to worry about recording that yourself.\nWe also initialised our logger object with the run number - so that will automatically be included in each logging entry too!\n\n\n\nOriginal\n\ndef attend_clinic(self, patient):\n    patient.arrival = self.env.now\n\n    # request examination resource\n    start_wait = self.env.now\n\n    with self.treatment_cubicles.request() as req:\n        # Seize a treatment resource when available\n        yield req\n\n        # record the waiting time for treatment\n        patient.wait_treat = self.env.now - start_wait\n\n        # sample treatment duration\n        patient.treat_duration = self.treat_dist.sample()\n\n        yield self.env.timeout(patient.treat_duration)\n\n    # total time in system\n    patient.total_time = self.env.now - patient.arrival\n\n\n\n\n\n\nWith Vidigi Modifications\n\ndef attend_clinic(self, patient):\n    patient.arrival = self.env.now\n\n    # First, we log when the patient arrives  \n    # using the EventLogger object we created    \n    # and assigned to our model  \n    # in the __init__ method.  \n    # The time will automatically be recorded    \n    # as the current simulation time    \n    self.logger.log_arrival( \n            entity_id=patient.identifier \n            ) \n\n    # request examination resource\n    start_wait = self.env.now\n\n    self.logger.log_queue(  \n        entity_id=patient.identifier,  \n        event=\"treatment_wait_begins\"  \n        )  \n\n    # Seize a treatment resource when available\n    with self.treatment_cubicles.request() as req:\n        # Make sure we assign the result of the yield     \n        # to a variable    \n        # Assuming we are using a VidigiStore or     \n        # VidigiPriorityStore, this will allow us    \n        # to access the useful ID attribute of the     \n        # returned cubicle    \n        treatment_cubicle = yield req    \n\n        # record the waiting time for treatment\n        patient.wait_treat = self.env.now - start_wait\n\n        # As we've waited for a resource to become available     \n        #  with the `yield req`, we can now record     \n        # that the user's resource use is starting.    \n        self.logger.log_resource_use_start(  \n                entity_id=patient.identifier,  \n                event=\"treatment_begins\",  \n                resource_id=treatment_cubicle.id_attribute  \n                )  \n\n        # sample treatment duration\n        patient.treat_duration = self.treat_dist.sample()\n\n        yield self.env.timeout(patient.treat_duration)\n\n        # Now that we have waited for the patient to be seen,    \n        # we can log that their use    \n        # of the resource has ended    \n        self.logger.log_resource_use_end(  \n            entity_id=patient.identifier,  \n            event=\"treatment_complete\",  \n            resource_id=treatment_cubicle.id_attribute  \n            )  \n\n    # total time in system\n    patient.total_time = self.env.now - patient.arrival\n\n    # Finally, we record when the     \n    # entity leaves the system  \n    self.logger.log_departure(  \n        entity_id=patient.identifier  \n        )  \n\n\n\n\n\n\nthe run method\nThis code is unchanged.\n\n\n\nthe Trial Class\nLet’s add an empty list to store the created event logs from each run.\nWe’ll also create an empty dataframe that will be replaced with our final dataframe of all event logs.\n\nthe init method\n\n\n\nOriginal\n\ndef  __init__(self):\n    self.df_trial_results = pd.DataFrame()\n    self.df_trial_results[\"Run Number\"] = [0]\n    self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n    self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n\n\n\n\n\nWith Vidigi Modifications\n\ndef  __init__(self):\n    self.df_trial_results = pd.DataFrame()\n    self.df_trial_results[\"Run Number\"] = [0]\n    self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n    self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n    self.all_event_logs = [] \n    self.all_event_logs_df = pd.DataFrame() \n\n\n\n\n\n\nthe run_trial method\n\n\n\nOriginal\n\ndef run_trial(self):\n\n    for run in range(1, g.number_of_runs+1):\n        my_model = Model(run)\n        my_model.run()\n\n        self.df_trial_results.loc[run] = (\n            # take the mean average (add up all values and divide by the number of values)\n            np.mean(\n                [patient.wait_treat # grab the individual patient's wait time...\n                for patient # for every patient...\n                in my_model.patients] # in our list of patient objects\n                )\n        )\n\n    return self.df_trial_results\n\n\n\n\n\n\nWith Vidigi Modifications\n\ndef run_trial(self):\n    for run in range(1, g.number_of_runs+1):\n        my_model = Model(run)\n        my_model.run()\n\n        self.df_trial_results.loc[run] = (\n            # take the mean average (add up all values and divide by the number of values)\n            np.mean(\n                [patient.wait_treat # grab the individual patient's wait time...\n                for patient # for every patient...\n                in my_model.patients] # in our list of patient objects\n                )\n        )\n\n        # For each run, we append the logger object     \n        # (which is of class EventLogger)  \n        # to our list all_event_logs, which     \n        # started out empty  \n        self.all_event_logs.append(my_model.logger) \n\n    # At the end, we create one large pandas     \n    #  dataframe of the results from every run    \n    self.all_event_logs_df = pd.concat(  \n        [run_results.to_dataframe()   \n        for run_results   \n        in self.all_event_logs]  \n        )",
    "crumbs": [
      "Walkthroughs",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 1.0.0 and above"
    ]
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#using-vidigi-to-create-an-animation-from-our-event-log",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#using-vidigi-to-create-an-animation-from-our-event-log",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 1.0.0 and above",
    "section": "Using vidigi to create an animation from our event log",
    "text": "Using vidigi to create an animation from our event log\nFor simple animations with vidigi, it is recommended that you use the animate_activity_log function.\nThis all-in-one function takes an event log of the structure discussed above, then turns it into an animated output that can be embedded in a quarto document, a web app, or saved as a standalone HTML file.\nFirst, we need to create an instance of our trial class, then run the trial.\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\nThe dataframe of event logs can then be viewed using my_trial.all_event_logs_df\n\nThe event_position_df\nWe can then generate our coordinates for the initial positioning of each step.\n\n\n\n\n\n\nNote\n\n\n\nThe ‘event’ names must match the event names you assigned in the logging steps.\nHowever, this will not be displayed anywhere in the final setup. Instead, use ‘label’ to define a human-readable label that can optionally be displayed in the final animation.\n\n\n\n\n\n\n\n\nWarning\n\n\n\n‘label’ should not be left out or be an empty string - both of these will cause problems.\n\n\n\n\n\n\n\n\nNote\n\n\n\nYou only need to provide positions for\n\narrival\ndeparture\nqueue\nresource_use (optional - you can have an animation that is only queues)\n\ni.e. you do not need to provide coordinates for resource_use_end\nYou can also opt to skip any queue or resource_use steps you do not want to show, though note that this could produce a misleading output if not carefully explained to end users\n\n\n\n\n\n\n\n\nTip\n\n\n\nFor queues and resource use, the coordinate will correspond to the bottom-right-hand corner of the block of queueing entities or resources.\n\n\nWe pass in a list of EventPosition objects.\nEach expects\n\nan event name (which must be ‘arrival’, ‘depart’, or match with one of the event names we used for any of our queue or resource_use steps)\nan x position\na y position\na label, which can optionally be displayed as part of the animation\n\nFor an event position relating to a resource use step, we will also pass in a string for ‘resoure’.\nIn our g class, we used an attribute called ‘n_cubicles’ to define how many cubicles are available. We will pass this attribute name so that the animation function will be able to look up the correct number of resources to display - as we’ll be passing the g class in to the animation function too, so it will be able to access that data if it knows what to look for.\n\n# Create a list of EventPosition objects\nevent_position_df = create_event_position_df([\n    EventPosition(event='arrival', x=50, y=450, label=\"Arrival\"),\n    EventPosition(event='treatment_wait_begins', x=205, y=275, label=\"Waiting for Treatment\"),\n    EventPosition(event='treatment_begins', x=205, y=175, label=\"Being Treated\", resource='n_cubicles'),\n    EventPosition(event='depart', x=270, y=70, label=\"Exit\")\n])",
    "crumbs": [
      "Walkthroughs",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 1.0.0 and above"
    ]
  },
  {
    "objectID": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#creating-the-animation",
    "href": "vidigi_docs/adding_vidigi_to_a_simple_simpy_model_hsma_structure.html#creating-the-animation",
    "title": "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 1.0.0 and above",
    "section": "Creating the animation",
    "text": "Creating the animation\nFinally, we can create the animation.\n\n\n\n\n\n\nWarning\n\n\n\nIt is important that you only pass in a single run at a time!\nPassing a dataframe in containing more than one run will produce incorrect animations.\nYou may, however, wish to give the user control over which run they visualise using a dropdown in something like Streamlit or Shiny\n\n\n\n# Filter our dataframe down to a single run\nsingle_run_event_log_df = my_trial.all_event_logs_df[my_trial.all_event_logs_df['run_number']==1]\n\nanimate_activity_log(\n        # Pass in our filtered event log\n        event_log=single_run_event_log_df,\n        # Pass in our event position dataframe\n        event_position_df= event_position_df,\n        # Use an instance of the g class as our scenario so that it can access the required\n        # information about how many resources are available\n        scenario=g(),\n        # How long should the animation last? We can pass in any value here - but I've chosen to\n        # make it last as long as our originally defined simulation duration\n        limit_duration=g.sim_duration,\n        # Turn on logging messages\n        debug_mode=True,\n        # Turn on axis units - this can help with honing your event_position_df iteratively\n        setup_mode=True,\n        # How big should the time steps be? Here,\n        every_x_time_units=1,\n        # Should the animation allow you to just drag a slider to progress through the animation,\n        # or should it include a play button?\n        include_play_button=True,\n        # How big should the icons representing our entities be?\n        entity_icon_size=20,\n        # How big should the icons representing our resources be?\n        resource_icon_size=20,\n        # How big should the gap between our entities be when they are queueing?\n        gap_between_entities=6,\n        # When we wrap the entities to fit more neatly on the screen, how big should the vertical\n        # gap be between these rows?\n        gap_between_queue_rows=25,\n        # How tall, in pixels, should the plotly plot be?\n        plotly_height=600,\n        # How wide, in pixels, should the plotly plot be?\n        plotly_width=1000,\n        # How long, in milliseconds, should each frame last?\n        frame_duration=200,\n        # How long, in milliseconds, should the transition between each pair of frames be?\n        frame_transition_duration=600,\n        # How wide, in coordinates, should our plot's internal coordinate system be?\n        override_x_max=300,\n        # How tall, in coordinates, should our plot's internal coordinate system be?\n        override_y_max=500,\n        # How long should a queue be before it starts wrapping vertically?\n        wrap_queues_at=25,\n        # What are the maximum numbers of entities that should be displayed in any queueing steps\n        # before displaying additional entities as a text string like '+ 37 more'\n        step_snapshot_max=125,\n        # What should the time display units be underneath the simulation?\n        time_display_units=\"simulation_day_clock_ampm\",\n        # display our Label column from our event_position_df to identify the position of each icon\n        display_stage_labels=True\n    )\n\n\n\n\n\n\n\nClick here to view the full code\n\n\n\n\n\n\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\nfrom sim_tools.distributions import Exponential, Lognormal\nfrom vidigi.resources import VidigiStore \nfrom vidigi.logging import EventLogger \nfrom vidigi.utils import EventPosition, create_event_position_df \nfrom vidigi.animation import animate_activity_log \n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    n_cubicles = 3 # The number of treatment cubicles\n    trauma_treat_mean = 40 # Mean of the trauma cubicle treatment distribution (Lognormal)\n    trauma_treat_var = 5 # Variance of the trauma cubicle treatment distribution (Lognormal)\n\n    arrival_rate = 5 # mean of the exponential distribution for sampling the inter-arrival time of entities\n\n    # Simulation running parameters\n    sim_duration = 600 # The number of time units the simulation will run for\n    number_of_runs = 100 # The number of times the simulation will be run with different random number streams\n    random_number_set = 42 # Control the randomness in our distributions\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    def __init__(self, p_id):\n        self.identifier = p_id\n        self.arrival = -np.inf\n        self.wait_treat = -np.inf\n        self.total_time = -np.inf\n        self.treat_duration = -np.inf\n\n# Class representing our model of the clinic.\nclass Model:\n    '''\n    Simulates the simplest minor treatment process for a patient\n\n    1. Arrive\n    2. Examined/treated by nurse when one available\n    3. Discharged\n    '''\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        # Create an empty list to store our patient objects - these can be handy\n        # to look at later\n        self.patients = []\n\n        # Create our resources\n        self.init_resources()\n\n        # Create our distributions\n        # 1. for patient inter-arrival time\n        self.patient_inter_arrival_dist = Exponential(\n            mean = g.arrival_rate,\n            # Set a random seed that will vary across runs\n            # (this isn't the best way to set this - but will do for this example!)\n            random_seed = (self.run_number + 1) * g.random_number_set\n            )\n        # 2. for the duration of patient treatments\n        self.treat_dist = Lognormal(\n            mean = g.trauma_treat_mean,\n            stdev = g.trauma_treat_var,\n            random_seed = (self.run_number + 1) * g.random_number_set\n            )\n\n        # By passing in the env we've created, the logger will default to the simulation  \n        # time when populating the time column of our event logs  \n        # Passing the run number also ensures we can separate out different runs  \n        # of the simulation in our later calculations \n        self.logger = EventLogger( \n            env=self.env,  \n            run_number=self.run_number \n            ) \n\n    def init_resources(self):\n        self.treatment_cubicles = VidigiStore( \n            self.env, \n            num_resources=g.n_cubicles \n            ) \n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            # Store patient in list for later easy access\n            self.patients.append(p)\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            self.env.process(self.attend_clinic(p))\n\n            # Randomly sample the time to the next patient arriving.  Here, we\n            # sample from an exponential distribution (common for inter-arrival\n            # times), and pass in a lambda value of 1 / mean.  The mean\n            # inter-arrival time is stored in the g class.\n            sampled_inter = self.patient_inter_arrival_dist.sample()\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(sampled_inter)\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_clinic(self, patient):\n        patient.arrival = self.env.now\n\n        # First, we log when the patient arrives  \n        # using the EventLogger object we created and assigned to   \n        # our model in the __init__ method.  \n        # The time will automatically be recorded as the current\n        # simulation time\n        self.logger.log_arrival( \n                entity_id=patient.identifier \n                ) \n\n        # request examination resource\n        start_wait = self.env.now\n\n        self.logger.log_queue(  \n            entity_id=patient.identifier,  \n            event=\"treatment_wait_begins\"  \n            )  \n\n        # Seize a treatment resource when available\n        with self.treatment_cubicles.request() as req:\n            # Make sure we assign the result of the yield to a variable\n            # Assuming we are using a VidigiStore or VidigiPriorityStore, this will allow us\n            # to access the useful ID attribute of the returned cubicle\n            treatment_cubicle = yield req    \n\n            # record the waiting time for treatment\n            patient.wait_treat = self.env.now - start_wait\n\n            # As we've waited for a resource to become available with the `yield req`, we\n            # can now record that the user's resource use is starting.\n            self.logger.log_resource_use_start(  \n                    entity_id=patient.identifier,  \n                    event=\"treatment_begins\",  \n                    resource_id=treatment_cubicle.id_attribute  \n                    )  \n\n            # sample treatment duration\n            patient.treat_duration = self.treat_dist.sample()\n\n            yield self.env.timeout(patient.treat_duration)\n\n            # Now that we have waited for the patient to be seen, we can log that their use\n            # of the resource has ended\n            self.logger.log_resource_use_end(  \n                entity_id=patient.identifier,  \n                event=\"treatment_complete\",  \n                resource_id=treatment_cubicle.id_attribute  \n                )  \n\n        # total time in system\n        patient.total_time = self.env.now - patient.arrival\n\n        # Finally, we record when the entity leaves the system  \n        self.logger.log_departure(  \n            entity_id=patient.identifier  \n            )  \n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n        self.all_event_logs = [] \n        self.all_event_logs_df = pd.DataFrame() \n\n    # Method to run a trial\n    def run_trial(self):\n        for run in range(1, g.number_of_runs+1):\n            my_model = Model(run)\n            my_model.run()\n\n            self.df_trial_results.loc[run] = (\n                # take the mean average (add up all values and divide by the number of values)\n                np.mean(\n                    [patient.wait_treat # grab the individual patient's wait time...\n                    for patient # for every patient...\n                    in my_model.patients] # in our list of patient objects\n                    )\n            )\n\n            # For each run, we append the logger object (which is of class EventLogger)  \n            # to our list all_event_logs, which started out empty  \n            self.all_event_logs.append(my_model.logger) \n\n        # At the end, we create one large pandas dataframe of the results from every run\n        self.all_event_logs_df = pd.concat(  \n            [run_results.to_dataframe() for run_results in self.all_event_logs]  \n            )  \n\n\n\n\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\nLet’s have a look at what our genereated event logs look like.\n\nmy_trial.all_event_logs_df.head(10)\n\n\n\n\n\n\n\n\nentity_id\nevent_type\nevent\ntime\npathway\nrun_number\ntimestamp\nresource_id\n\n\n\n\n0\n1\narrival_departure\narrival\n0.000000\nNone\n1\nNone\nNaN\n\n\n1\n1\nqueue\ntreatment_wait_begins\n0.000000\nNone\n1\nNone\nNaN\n\n\n2\n1\nresource_use\ntreatment_begins\n0.000000\nNone\n1\nNone\n1.0\n\n\n3\n2\narrival_departure\narrival\n8.965271\nNone\n1\nNone\nNaN\n\n\n4\n2\nqueue\ntreatment_wait_begins\n8.965271\nNone\n1\nNone\nNaN\n\n\n5\n2\nresource_use\ntreatment_begins\n8.965271\nNone\n1\nNone\n2.0\n\n\n6\n3\narrival_departure\narrival\n12.659854\nNone\n1\nNone\nNaN\n\n\n7\n3\nqueue\ntreatment_wait_begins\n12.659854\nNone\n1\nNone\nNaN\n\n\n8\n3\nresource_use\ntreatment_begins\n12.659854\nNone\n1\nNone\n3.0\n\n\n9\n4\narrival_departure\narrival\n22.343529\nNone\n1\nNone\nNaN\n\n\n\n\n\n\n\nAnd finally, let’s see what the animation looks like!\n\n\nAnimation function called at 15:39:13\nIteration through time-unit-by-time-unit logs complete 15:39:16\nSnapshot df concatenation complete at 15:39:16\nReshaped animation dataframe finished construction at 15:39:17\nPlacement dataframe finished construction at 15:39:17\nOutput animation generation complete at 15:39:24\nTotal Time Elapsed: 10.95 seconds\n\n\n        \n        \n        \n\n\n                                                    \n\n\nWhen you have finished tweaking the layout, you can further enhance your output.\n\nanimate_activity_log(\n        event_log=single_run_event_log_df,\n        event_position_df= event_position_df,\n        scenario=g(),\n        limit_duration=g.sim_duration,\n        debug_mode=False, # Turn off logging messages\n        setup_mode=False, # Turn off axis units\n        every_x_time_units=1,\n        include_play_button=True,\n        entity_icon_size=20,\n        resource_icon_size=20,\n        gap_between_entities=6,\n        gap_between_queue_rows=25,\n        plotly_height=600,\n        frame_duration=200,\n        plotly_width=1000,\n        override_x_max=300,\n        override_y_max=500,\n        wrap_queues_at=25,\n        step_snapshot_max=125,\n        time_display_units=\"simulation_day_clock_ampm\",\n        display_stage_labels=False, # hide our Label column from our event_position_df\n        # Add a local or web-hosted image as our background\n        add_background_image=\"https://raw.githubusercontent.com/hsma-tools/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\")\n\n                                                    \n\n\nWe can then rerun our animation, passing in different parameters - though make sure to rerun your trial if you do so!\nHere, we will increase the number of cubicles from 3 to 7 and see the impact this has on the queue size.\n\ng.n_cubicles = 7 \n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\nsingle_run_event_log_df = my_trial.all_event_logs_df[my_trial.all_event_logs_df['run_number']==1]\n\nanimate_activity_log(\n        event_log=single_run_event_log_df,\n        event_position_df= event_position_df,\n        scenario=g(),\n        limit_duration=g.sim_duration,\n        debug_mode=False, # Turn off logging messages\n        setup_mode=False, # Turn off axis units\n        every_x_time_units=1,\n        include_play_button=True,\n        entity_icon_size=20,\n        resource_icon_size=20,\n        gap_between_entities=6,\n        gap_between_queue_rows=25,\n        plotly_height=600,\n        frame_duration=200,\n        plotly_width=1000,\n        override_x_max=300,\n        override_y_max=500,\n        wrap_queues_at=25,\n        step_snapshot_max=125,\n        time_display_units=\"simulation_day_clock_ampm\",\n        display_stage_labels=False, # hide our Label column from our event_position_df\n        # Add a local or web-hosted image as our background\n        add_background_image=\"https://raw.githubusercontent.com/hsma-tools/vidigi/refs/heads/main/examples/example_1_simplest_case/Simplest%20Model%20Background%20Image%20-%20Horizontal%20Layout.drawio.png\")",
    "crumbs": [
      "Walkthroughs",
      "Adding Vidigi to a Simple simpy Model (HSMA Structure) - vidigi 1.0.0 and above"
    ]
  },
  {
    "objectID": "vidigi_docs/basic_example_minimal_required_vidigi_functions.html",
    "href": "vidigi_docs/basic_example_minimal_required_vidigi_functions.html",
    "title": "Step 2. Set up simulation parameters",
    "section": "",
    "text": "If you would prefer to implement your own approach to logging, you can avoid the use of the EventLogger class, and instead manually build your event logs, as shown in this example.\n\n\n\nvidigi\nsimpy - for simulation model (or see the Ciw functions and examples elsewhere in this documentation)\nrandom - for generating random arrivals\npandas - for managing dataframes\n\n\nimport simpy\nimport pandas as pd\nimport random\nfrom vidigi.animation import animate_activity_log\nfrom vidigi.utils import EventPosition, create_event_position_df\n\n\n# Simple simulation parameters\nSIM_DURATION = 50\nNUM_SERVERS = 1\nARRIVAL_RATE = 1.0\nSERVICE_TIME = 3.0\n\n\n\n\nCreate a simple simulation model using simpy.\nOn the left is a basic simpy model. If not familiar check out simpy documentation for intro to simpy.\nOn the right is how we incorporate vidigi. Information for vidigi collected in a list of dictionaries which we will convert into a dataframe. You need a arrival_departure event.\n\n\n\n\ndef patient_generator(env, server, event_log):\n    \"\"\"Generate patients arriving at the shop\"\"\"\n    patient_id = 0\n\n    while True:\n        patient_id += 1\n\n        # Start the patient process\n        env.process(patient_process(env, patient_id, server, event_log))\n\n        # Wait for next arrival\n        yield env.timeout(random.expovariate(ARRIVAL_RATE))\n\ndef patient_process(env, patient_id, server, event_log):\n    \"\"\"Process a single patient through the system\"\"\"\n\n    # Request server\n    with server.request() as request:\n        yield request\n\n        # Service time\n        service_duration = random.expovariate(1.0/SERVICE_TIME)\n        yield env.timeout(service_duration)\n\n# Run the simulation\ndef run_simulation():\n    env = simpy.Environment()\n    server = simpy.Resource(env, capacity=NUM_SERVERS)\n    event_log = []\n\n    # Start patient generator\n    env.process(patient_generator(env, server, event_log))\n\n    # Run simulation\n    env.run(until=SIM_DURATION)\n\n\n\n\n\n\n\ndef patient_generator(env, server, event_log):\n    \"\"\"Generate patients arriving at the shop\"\"\"\n    patient_id = 0\n\n    while True:\n        patient_id += 1\n\n        # Log arrival\n        event_log.append({ \n            'patient': patient_id, \n            'event': 'arrival', \n            'event_type': 'arrival_departure',  \n            'time': env.now \n        }) \n\n        # Start the patient process\n        env.process(patient_process(env, patient_id, server, event_log))\n\n        # Wait for next arrival\n        yield env.timeout(random.expovariate(ARRIVAL_RATE))\n\ndef patient_process(env, patient_id, server, event_log):\n    \"\"\"Process a single patient through the system\"\"\"\n\n    # Log start of queue wait \n    event_log.append({ \n        'patient': patient_id, \n        'event': 'queue_wait_begins', \n        'event_type': 'queue', \n        'time': env.now \n    }) \n\n    # Request server\n    with server.request() as request:\n        yield request\n\n        # Log service start\n        event_log.append({ \n            'patient': patient_id, \n            'event': 'service_begins', \n            'event_type': 'resource_use', \n            'time': env.now, \n            'resource_id': 1 \n        }) \n\n        # Service time\n        service_duration = random.expovariate(1.0/SERVICE_TIME)\n        yield env.timeout(service_duration)\n\n        # Log service end \n        event_log.append({ \n            'patient': patient_id, \n            'event': 'service_complete', \n            'event_type': 'resource_use_end', \n            'time': env.now, \n            'resource_id': 1 \n        }) \n\n    # Log departure \n    event_log.append({ \n        'patient': patient_id, \n        'event': 'depart', \n        'event_type': 'arrival_departure', \n        'time': env.now \n    }) \n\n# Run the simulation\ndef run_simulation():\n    env = simpy.Environment()\n    server = simpy.Resource(env, capacity=NUM_SERVERS)\n    event_log = []\n\n    # Start patient generator\n    env.process(patient_generator(env, server, event_log))\n\n    # Run simulation\n    env.run(until=SIM_DURATION)\n\n    return pd.DataFrame(event_log) \n\n\n\n\n\n\n\n\n# Run simulation and get event log\nevent_log_df = run_simulation()\nprint(f\"Generated {len(event_log_df)} events\")\n\nGenerated 125 events\n\n\n\n\n\n\n# Define positions for animation\nevent_positions = create_event_position_df([\n    EventPosition(event='arrival', x=0, y=350, label=\"Entrance\"),\n    EventPosition(event='queue_wait_begins', x=250, y=250, label=\"Queue\"),\n    EventPosition(event='service_begins', x=250, y=150, resource='server', label=\"Being Served\"),\n    EventPosition(event='depart', x=250, y=50, label=\"Exit\")\n])\n\n\n\n\nExplaining:\n\nplotly_height and plotly_width\noverride_x_max and override_y_max\nsetup_mode\nevery_x_time_units\n\n\n# Create animation\nanimate_activity_log(\n    event_log=event_log_df,\n    event_position_df=event_positions,\n    entity_col_name=\"patient\",\n    every_x_time_units=1,\n    plotly_height=600,\n    override_x_max=360,\n    limit_duration=SIM_DURATION\n)",
    "crumbs": [
      "Walkthroughs",
      "A very simple example with one server - avoiding the vidigi logger class"
    ]
  },
  {
    "objectID": "vidigi_docs/basic_example_minimal_required_vidigi_functions.html#step-1.-import-required-libraries",
    "href": "vidigi_docs/basic_example_minimal_required_vidigi_functions.html#step-1.-import-required-libraries",
    "title": "Step 2. Set up simulation parameters",
    "section": "",
    "text": "vidigi\nsimpy - for simulation model (or see the Ciw functions and examples elsewhere in this documentation)\nrandom - for generating random arrivals\npandas - for managing dataframes\n\n\nimport simpy\nimport pandas as pd\nimport random\nfrom vidigi.animation import animate_activity_log\nfrom vidigi.utils import EventPosition, create_event_position_df\n\n\n# Simple simulation parameters\nSIM_DURATION = 50\nNUM_SERVERS = 1\nARRIVAL_RATE = 1.0\nSERVICE_TIME = 3.0",
    "crumbs": [
      "Walkthroughs",
      "A very simple example with one server - avoiding the vidigi logger class"
    ]
  },
  {
    "objectID": "vidigi_docs/basic_example_minimal_required_vidigi_functions.html#step-3.-write-model-code-with-event-logs",
    "href": "vidigi_docs/basic_example_minimal_required_vidigi_functions.html#step-3.-write-model-code-with-event-logs",
    "title": "Step 2. Set up simulation parameters",
    "section": "",
    "text": "Create a simple simulation model using simpy.\nOn the left is a basic simpy model. If not familiar check out simpy documentation for intro to simpy.\nOn the right is how we incorporate vidigi. Information for vidigi collected in a list of dictionaries which we will convert into a dataframe. You need a arrival_departure event.\n\n\n\n\ndef patient_generator(env, server, event_log):\n    \"\"\"Generate patients arriving at the shop\"\"\"\n    patient_id = 0\n\n    while True:\n        patient_id += 1\n\n        # Start the patient process\n        env.process(patient_process(env, patient_id, server, event_log))\n\n        # Wait for next arrival\n        yield env.timeout(random.expovariate(ARRIVAL_RATE))\n\ndef patient_process(env, patient_id, server, event_log):\n    \"\"\"Process a single patient through the system\"\"\"\n\n    # Request server\n    with server.request() as request:\n        yield request\n\n        # Service time\n        service_duration = random.expovariate(1.0/SERVICE_TIME)\n        yield env.timeout(service_duration)\n\n# Run the simulation\ndef run_simulation():\n    env = simpy.Environment()\n    server = simpy.Resource(env, capacity=NUM_SERVERS)\n    event_log = []\n\n    # Start patient generator\n    env.process(patient_generator(env, server, event_log))\n\n    # Run simulation\n    env.run(until=SIM_DURATION)\n\n\n\n\n\n\n\ndef patient_generator(env, server, event_log):\n    \"\"\"Generate patients arriving at the shop\"\"\"\n    patient_id = 0\n\n    while True:\n        patient_id += 1\n\n        # Log arrival\n        event_log.append({ \n            'patient': patient_id, \n            'event': 'arrival', \n            'event_type': 'arrival_departure',  \n            'time': env.now \n        }) \n\n        # Start the patient process\n        env.process(patient_process(env, patient_id, server, event_log))\n\n        # Wait for next arrival\n        yield env.timeout(random.expovariate(ARRIVAL_RATE))\n\ndef patient_process(env, patient_id, server, event_log):\n    \"\"\"Process a single patient through the system\"\"\"\n\n    # Log start of queue wait \n    event_log.append({ \n        'patient': patient_id, \n        'event': 'queue_wait_begins', \n        'event_type': 'queue', \n        'time': env.now \n    }) \n\n    # Request server\n    with server.request() as request:\n        yield request\n\n        # Log service start\n        event_log.append({ \n            'patient': patient_id, \n            'event': 'service_begins', \n            'event_type': 'resource_use', \n            'time': env.now, \n            'resource_id': 1 \n        }) \n\n        # Service time\n        service_duration = random.expovariate(1.0/SERVICE_TIME)\n        yield env.timeout(service_duration)\n\n        # Log service end \n        event_log.append({ \n            'patient': patient_id, \n            'event': 'service_complete', \n            'event_type': 'resource_use_end', \n            'time': env.now, \n            'resource_id': 1 \n        }) \n\n    # Log departure \n    event_log.append({ \n        'patient': patient_id, \n        'event': 'depart', \n        'event_type': 'arrival_departure', \n        'time': env.now \n    }) \n\n# Run the simulation\ndef run_simulation():\n    env = simpy.Environment()\n    server = simpy.Resource(env, capacity=NUM_SERVERS)\n    event_log = []\n\n    # Start patient generator\n    env.process(patient_generator(env, server, event_log))\n\n    # Run simulation\n    env.run(until=SIM_DURATION)\n\n    return pd.DataFrame(event_log)",
    "crumbs": [
      "Walkthroughs",
      "A very simple example with one server - avoiding the vidigi logger class"
    ]
  },
  {
    "objectID": "vidigi_docs/basic_example_minimal_required_vidigi_functions.html#step-4.-run-simulation",
    "href": "vidigi_docs/basic_example_minimal_required_vidigi_functions.html#step-4.-run-simulation",
    "title": "Step 2. Set up simulation parameters",
    "section": "",
    "text": "# Run simulation and get event log\nevent_log_df = run_simulation()\nprint(f\"Generated {len(event_log_df)} events\")\n\nGenerated 125 events",
    "crumbs": [
      "Walkthroughs",
      "A very simple example with one server - avoiding the vidigi logger class"
    ]
  },
  {
    "objectID": "vidigi_docs/basic_example_minimal_required_vidigi_functions.html#step-5.-create-event-positions-dataframe",
    "href": "vidigi_docs/basic_example_minimal_required_vidigi_functions.html#step-5.-create-event-positions-dataframe",
    "title": "Step 2. Set up simulation parameters",
    "section": "",
    "text": "# Define positions for animation\nevent_positions = create_event_position_df([\n    EventPosition(event='arrival', x=0, y=350, label=\"Entrance\"),\n    EventPosition(event='queue_wait_begins', x=250, y=250, label=\"Queue\"),\n    EventPosition(event='service_begins', x=250, y=150, resource='server', label=\"Being Served\"),\n    EventPosition(event='depart', x=250, y=50, label=\"Exit\")\n])",
    "crumbs": [
      "Walkthroughs",
      "A very simple example with one server - avoiding the vidigi logger class"
    ]
  },
  {
    "objectID": "vidigi_docs/basic_example_minimal_required_vidigi_functions.html#step-6.-create-animation",
    "href": "vidigi_docs/basic_example_minimal_required_vidigi_functions.html#step-6.-create-animation",
    "title": "Step 2. Set up simulation parameters",
    "section": "",
    "text": "Explaining:\n\nplotly_height and plotly_width\noverride_x_max and override_y_max\nsetup_mode\nevery_x_time_units\n\n\n# Create animation\nanimate_activity_log(\n    event_log=event_log_df,\n    event_position_df=event_positions,\n    entity_col_name=\"patient\",\n    every_x_time_units=1,\n    plotly_height=600,\n    override_x_max=360,\n    limit_duration=SIM_DURATION\n)",
    "crumbs": [
      "Walkthroughs",
      "A very simple example with one server - avoiding the vidigi logger class"
    ]
  },
  {
    "objectID": "vidigi_docs/basic_example_with_vidigi_logger_helpers_multiple_servers.html",
    "href": "vidigi_docs/basic_example_with_vidigi_logger_helpers_multiple_servers.html",
    "title": "A slightly more complex example with multiple servers",
    "section": "",
    "text": "When dealing with multiple servers, we need to have a way to monitor which resource is in use. This is where vidigi’s custom resource classes come in, such as VidigiStore.\nVidigiStore is designed to mimic the Resource class in Simpy - so you can continue to use the same patterns of resource requesting you are familiar with.",
    "crumbs": [
      "Walkthroughs",
      "A slightly more complex example with multiple servers"
    ]
  },
  {
    "objectID": "vidigi_docs/basic_example_with_vidigi_logger_helpers_multiple_servers.html#step-1.-import-required-libraries",
    "href": "vidigi_docs/basic_example_with_vidigi_logger_helpers_multiple_servers.html#step-1.-import-required-libraries",
    "title": "A slightly more complex example with multiple servers",
    "section": "Step 1. Import required libraries",
    "text": "Step 1. Import required libraries\n\nvidigi\nsimpy - for simulation model (or see the Ciw functions and examples elsewhere in this documentation)\nrandom - for generating random arrivals\npandas - for managing dataframes\n\n\nimport simpy\nimport pandas as pd\nimport random\nfrom vidigi.animation import animate_activity_log\nfrom vidigi.logging import EventLogger\nfrom vidigi.utils import EventPosition, create_event_position_df\nfrom vidigi.resources import VidigiStore",
    "crumbs": [
      "Walkthroughs",
      "A slightly more complex example with multiple servers"
    ]
  },
  {
    "objectID": "vidigi_docs/basic_example_with_vidigi_logger_helpers_multiple_servers.html#step-2.-set-up-simulation-parameters",
    "href": "vidigi_docs/basic_example_with_vidigi_logger_helpers_multiple_servers.html#step-2.-set-up-simulation-parameters",
    "title": "A slightly more complex example with multiple servers",
    "section": "Step 2. Set up simulation parameters",
    "text": "Step 2. Set up simulation parameters\n\n# Simple simulation parameters\nSIM_DURATION = 50\nNUM_SERVERS = 3\nARRIVAL_RATE = 4.0\nSERVICE_TIME = 3.0",
    "crumbs": [
      "Walkthroughs",
      "A slightly more complex example with multiple servers"
    ]
  },
  {
    "objectID": "vidigi_docs/basic_example_with_vidigi_logger_helpers_multiple_servers.html#step-3.-write-model-code-with-event-logs",
    "href": "vidigi_docs/basic_example_with_vidigi_logger_helpers_multiple_servers.html#step-3.-write-model-code-with-event-logs",
    "title": "A slightly more complex example with multiple servers",
    "section": "Step 3. Write model code with event logs",
    "text": "Step 3. Write model code with event logs\nCreate a simple simulation model using simpy.\nOn the left is a basic simpy model. If not familiar check out simpy documentation for intro to simpy.\nOn the right is how we incorporate vidigi. Information for vidigi collected in a list of dictionaries which we will convert into a dataframe. You need a arrival_departure event.\n\n\n\nSimple SimPy Model\n\ndef patient_generator(env, server, event_log):\n    \"\"\"Generate patients arriving at the shop\"\"\"\n    patient_id = 0\n\n    while True:\n        patient_id += 1\n\n        # Start the patient process\n        env.process(patient_process(env, patient_id, server, event_log))\n\n        # Wait for next arrival\n        yield env.timeout(random.expovariate(ARRIVAL_RATE))\n\ndef patient_process(env, patient_id, server, event_log):\n    \"\"\"Process a single patient through the system\"\"\"\n\n    # Request server\n    with server.request() as request:\n        yield request\n\n        # Service time\n        service_duration = random.expovariate(1.0/SERVICE_TIME)\n        yield env.timeout(service_duration)\n\n# Run the simulation\ndef run_simulation():\n    env = simpy.Environment()\n    server = simpy.Resource(env, capacity=NUM_SERVERS)\n    event_log = []\n\n    # Start patient generator\n    env.process(patient_generator(env, server, event_log))\n\n    # Run simulation\n    env.run(until=SIM_DURATION)\n\n\n\n\n\nWith Vidigi Modifications\n\nclass Params: \n    def __init__(self): \n        self.num_servers = 3 \n\ndef patient_generator(env, servers, logger):\n    \"\"\"Generate patients arriving at the shop\"\"\"\n    patient_id = 0\n\n    while True:\n        patient_id += 1\n\n        # Log arrival\n        logger.log_arrival(entity_id=patient_id) \n\n        # Start the patient process\n        env.process(patient_process(env, patient_id, servers, logger))\n\n        # Wait for next arrival\n        yield env.timeout(random.expovariate(ARRIVAL_RATE))\n\ndef patient_process(env, patient_id, servers, logger):\n    \"\"\"Process a single patient through the system\"\"\"\n\n    # Log start of queue wait \n    logger.log_queue(entity_id=patient_id, event='queue_wait_begins') \n\n    # Request server\n    with servers.request() as request:\n        server = yield request  \n\n        # Log service start\n        logger.log_resource_use_start(entity_id=patient_id, event=\"service_begins\", resource_id=server.id_attribute) \n\n        # Service time\n        service_duration = random.expovariate(1.0/SERVICE_TIME)\n        yield env.timeout(service_duration)\n\n        # Log service start\n        logger.log_resource_use_end(entity_id=patient_id, event=\"service_complete\", resource_id=server.id_attribute) \n\n    # Log departure \n    logger.log_departure(entity_id=patient_id)  \n\n# Run the simulation\ndef run_simulation():\n    params = Params()\n    env = simpy.Environment()\n    servers = VidigiStore(env=env, num_resources=params.num_servers) \n    logger = EventLogger(env=env) \n\n    # Start patient generator\n    env.process(patient_generator(env, servers, logger))\n\n    # Run simulation\n    env.run(until=SIM_DURATION)\n\n    return logger.to_dataframe()",
    "crumbs": [
      "Walkthroughs",
      "A slightly more complex example with multiple servers"
    ]
  },
  {
    "objectID": "vidigi_docs/basic_example_with_vidigi_logger_helpers_multiple_servers.html#step-4.-run-simulation",
    "href": "vidigi_docs/basic_example_with_vidigi_logger_helpers_multiple_servers.html#step-4.-run-simulation",
    "title": "A slightly more complex example with multiple servers",
    "section": "Step 4. Run simulation",
    "text": "Step 4. Run simulation\n\n# Run simulation and get event log\nevent_log_df = run_simulation()\nprint(f\"Generated {len(event_log_df)} events\")\n\nGenerated 546 events",
    "crumbs": [
      "Walkthroughs",
      "A slightly more complex example with multiple servers"
    ]
  },
  {
    "objectID": "vidigi_docs/basic_example_with_vidigi_logger_helpers_multiple_servers.html#step-5.-create-event-positions-dataframe",
    "href": "vidigi_docs/basic_example_with_vidigi_logger_helpers_multiple_servers.html#step-5.-create-event-positions-dataframe",
    "title": "A slightly more complex example with multiple servers",
    "section": "Step 5. Create event positions dataframe",
    "text": "Step 5. Create event positions dataframe\n\n# Define positions for animation\nevent_positions = create_event_position_df([\n    EventPosition(event='arrival', x=0, y=350, label=\"Entrance\"),\n    EventPosition(event='queue_wait_begins', x=250, y=250, label=\"Queue\"),\n    EventPosition(event='service_begins', x=250, y=150, resource='num_servers', label=\"Being Served\"),\n    EventPosition(event='depart', x=250, y=50, label=\"Exit\")\n])",
    "crumbs": [
      "Walkthroughs",
      "A slightly more complex example with multiple servers"
    ]
  },
  {
    "objectID": "vidigi_docs/basic_example_with_vidigi_logger_helpers_multiple_servers.html#step-6.-create-animation",
    "href": "vidigi_docs/basic_example_with_vidigi_logger_helpers_multiple_servers.html#step-6.-create-animation",
    "title": "A slightly more complex example with multiple servers",
    "section": "Step 6. Create animation",
    "text": "Step 6. Create animation\nExplaining:\n\nplotly_height and plotly_width\noverride_x_max and override_y_max\nsetup_mode\nevery_x_time_units\n\nWe pass our Params() class in so that vidigi knows the number of resource icons it needs to generate.\n\n# Create animation\nanimate_activity_log(\n    event_log=event_log_df,\n    event_position_df=event_positions,\n    scenario=Params(),\n    every_x_time_units=1,\n    plotly_height=600,\n    override_x_max=360,\n    limit_duration=SIM_DURATION\n)",
    "crumbs": [
      "Walkthroughs",
      "A slightly more complex example with multiple servers"
    ]
  },
  {
    "objectID": "vidigi_docs/introduction.html",
    "href": "vidigi_docs/introduction.html",
    "title": "Usage Instructions with SimPy",
    "section": "",
    "text": "Visual display of the outputs of discrete event simulations in simpy have been identified as one of the limitations of simpy, potentially hindering adoption of FOSS simulation in comparison to commercial modelling offerings or GUI FOSS alternatives such as JaamSim.\n\nWhen compared to commercial DES software packages that are commonly used in health research, such as Simul8, or AnyLogic, a limitation of our approach is that we do not display a dynamic patient pathway or queuing network that updates as the model runs a single replication. This is termed Visual Interactive Simulation (VIS) and can help users understand where process problems and delays occur in a patient pathway; albeit with the caveat that single replications can be outliers. A potential FOSS solution compatible with a browser-based app could use a Python package that can represent a queuing network, such as NetworkX, and displaying results via matplotlib. If sophisticated VIS is essential for a FOSS model then researchers may need to look outside of web apps; for example, salabim provides a powerful FOSS solution for custom animation of DES models. - Monks T and Harper A. Improving the usability of open health service delivery simulation models using Python and web apps [version 2; peer review: 3 approved]. NIHR Open Res 2023, 3:48 (https://doi.org/10.3310/nihropenres.13467.2)\n\nThis package allows visually appealing, flexible visualisations of the movement of entities through some kind of pathway.\nIt is primarily tested with discrete event simulations to be created from SimPy models, though has also been tested with the Ciw package.\n\nPlotly is leveraged to create the final animation, meaning that users can benefit from the ability to further customise or extend the plotly plot, as well as easily integrating with web frameworks such as Streamlit, Dash or Shiny for Python.\nThe code has been designed to be flexible and could potentially be used with alternative simulation packages such as simmeR or Salabim if it is possible to provide all of the required details in the logs that are output.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "vidigi_docs/introduction.html#introduction",
    "href": "vidigi_docs/introduction.html#introduction",
    "title": "Usage Instructions with SimPy",
    "section": "",
    "text": "Visual display of the outputs of discrete event simulations in simpy have been identified as one of the limitations of simpy, potentially hindering adoption of FOSS simulation in comparison to commercial modelling offerings or GUI FOSS alternatives such as JaamSim.\n\nWhen compared to commercial DES software packages that are commonly used in health research, such as Simul8, or AnyLogic, a limitation of our approach is that we do not display a dynamic patient pathway or queuing network that updates as the model runs a single replication. This is termed Visual Interactive Simulation (VIS) and can help users understand where process problems and delays occur in a patient pathway; albeit with the caveat that single replications can be outliers. A potential FOSS solution compatible with a browser-based app could use a Python package that can represent a queuing network, such as NetworkX, and displaying results via matplotlib. If sophisticated VIS is essential for a FOSS model then researchers may need to look outside of web apps; for example, salabim provides a powerful FOSS solution for custom animation of DES models. - Monks T and Harper A. Improving the usability of open health service delivery simulation models using Python and web apps [version 2; peer review: 3 approved]. NIHR Open Res 2023, 3:48 (https://doi.org/10.3310/nihropenres.13467.2)\n\nThis package allows visually appealing, flexible visualisations of the movement of entities through some kind of pathway.\nIt is primarily tested with discrete event simulations to be created from SimPy models, though has also been tested with the Ciw package.\n\nPlotly is leveraged to create the final animation, meaning that users can benefit from the ability to further customise or extend the plotly plot, as well as easily integrating with web frameworks such as Streamlit, Dash or Shiny for Python.\nThe code has been designed to be flexible and could potentially be used with alternative simulation packages such as simmeR or Salabim if it is possible to provide all of the required details in the logs that are output.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "vidigi_docs/introduction.html#examples",
    "href": "vidigi_docs/introduction.html#examples",
    "title": "Usage Instructions with SimPy",
    "section": "Examples",
    "text": "Examples\nTo develop and demonstrate the concept, it has so far been used to incorporate visualisation into several existing simpy models that were not initially designed with this sort of visualisation in mind: - a minor injuries unit, showing the utility of the model at high resolutions with branching pathways and the ability to add in a custom background to clearly demarcate process steps\n\n\nan elective surgical pathway (with a focus on cancelled theatre slots due to bed unavailability in recovery areas), with length of stay displayed as well as additional text and graphical data\n\n\n\na community mental health assessment pathway, showing the wait to an appointment as well as highlighting ‘urgent’ patients with a different icon and showing the time from referral to appointment below the patient icons when they attend the appointment.\n\n\n\na community mental health assessment pathway with pooling of clinics, showing the ‘home’ clinic for clients via icon so the balance between ‘home’ and ‘other’ clients can be explored.\n\n\n\na community mental health assessment and treatment pathway, showing the movement of clients between a wait list, a booking list, and returning for repeat appointments over a period of time while sitting on a caseload in between.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "vidigi_docs/introduction.html#creating-a-visualisation-from-an-existing-model",
    "href": "vidigi_docs/introduction.html#creating-a-visualisation-from-an-existing-model",
    "title": "Usage Instructions with SimPy",
    "section": "Creating a visualisation from an existing model",
    "text": "Creating a visualisation from an existing model\nTwo key things need to happen to existing models to work with the visualisation code: 1. All simpy resources need to be changed to simpy stores containing a custom resource with an ID attribute. Vidigi provides two helper classes - VidigiStore and VidigiPriorityStore - to support with this. 2. Logging needs to be added at key points: arrival, (queueing, resource use start, resource use end), departure where the steps in the middle can be repeated for as many queues and resource types as required, with the minimum requirement being at least one of each of arrival, queueing, departure.\n\n1. All simpy resources need to be changed to simpy stores containing a custom resource with an ID attribute\nTo allow the use of resources to be visualised correctly - with entities staying with the same resource throughout the time they are using it - it is essential to be able to identify and track individual resources.\nBy default, this is not possible with Simpy resources. They have no ID attribute or similar.\n\nThe easiest workaround which drops fairly painlessly into existing models is to use a simpy store with a custom resource class.\nThe custom resource is setup as follows:\n\nclass CustomResource(simpy.Resource):\n    def __init__(self, env, capacity, id_attribute=None):\n        super().__init__(env, capacity)\n        self.id_attribute = id_attribute\n\n    def request(self, *args, **kwargs):\n        # Add logic to handle the ID attribute when a request is made\n        return super().request(*args, **kwargs)\n\n    def release(self, *args, **kwargs):\n        # Add logic to handle the ID attribute when a release is made\n        return super().release(*args, **kwargs)\n\nThe creation of simpy resources is then replaced with the following pattern:\n\nbeds = simpy.Store(environment)\n\nfor i in range(number_of_beds):\n    beds.put(\n        CustomResource(\n            environment,\n            capacity=1,\n            id_attribute=i+1)\n        )\n\n\nvidigi.resources provides a helper function for setting up simpy resources in the required manner.\nFor a given resource that would have been created like this:\n\nnurses = simpy.Resource(simpy_environment, capacity=number_of_nurses)\n\nYou would use\n\nfrom vidigi.resources import VidigiStore\nnurses = VidigiStore(simpy_environment, num_resources=number_of_nurses)\n\nWhile you are now using a simpy store, VidigiStore and VidigiPriorityStore have a number of helper methods to allow you to continue to use\nThis becomes slightly more complex with conditional requesting (for example, where a resource request is made but if it cannot be fulfilled in time, the requester will renege). This is covered to some extent in some of the provided examples, but further demonstrations of this are planned.\nThe benefit of this is that when we are logging, we can use the .id_attribute attribute of the custom resource to record the resource that was in use. This can have wider benefits for monitoring individual resource utilisation within your model as well.\n\n\n2. Logging needs to be added at key points\nThe animation function needs to be passed an event log with the following layout:\n\n\n\n\n\n\n\n\n\n\n\npatient\npathway\nevent_type\nevent\ntime\nresource_id\n\n\n\n\n15\nPrimary\narrival_departure\narrival\n1.22\n\n\n\n15\nPrimary\nqueue\nenter_queue_for_bed\n1.35\n\n\n\n27\nRevision\narrival_departure\narrival\n1.47\n\n\n\n27\nRevision\nqueue\nenter_queue_for_bed\n1.58\n\n\n\n12\nPrimary\nresource_use_end\npost_surgery_stay_ends\n1.9\n4\n\n\n15\nRevision\nresource_use\npost_survery_stay_begins\n1.9\n4\n\n\n\nOne easy way to achieve this is by appending dictionaries to a list at each important point in the process. For example:\n\nevent_log = []\n...\n...\nevent_log.append(\n    {'patient': id,\n    'pathway': 'Revision',\n    'event_type': 'resource_use',\n    'event': 'post_surgery_stay_begins',\n    'time': simpy_environment.now,\n    'resource_id': bed.id_attribute}\n    )\n\nThe list of dictionaries could then be converted to a pandas dataframe using\n\npd.DataFrame(event_log)\n\nand passed to the animation function where required.\nHowever, from vidigi 1.0.0, you can use the EventLogger helper class instead! This will ensure the expected data is available throughout.\n\nfrom vidigi.logging import EventLogger\n\nlogger = EventLogger(\n            # Pass in the simulation environment if using simpy\n            # so that the current sim time will be used when logging\n            env=simpy_environment,\n            # Optionally, pass in a run number (when running multiple iterations of your simulation,\n            # ensuring you can tell logs from different runs apart easily)\n            run_number=run_number\n            )\n\nWe will access these helpers like so:\n\nlogger.log_arrival()\nlogger.log_queue()\nlogger.log_resource_use_start()\nlogger.log_resource_use_end()\nlogger.log_departure()\n\nThese are all of the key steps you are likely to need to log in a standard model\n\nwhen people arrive\nwhen they begin waiting for something to happen\nwhen they are using a resource\nwhen they finish using that resource\nwhen they leave\n\nYou can have multiple instances of queues and resource use within your logs per entity.\nHowever, each entity should have only one arrival and one departure.\nFor arrivals and departures, only the entity ID - e.g. a patient or customer identifier - needs to be passed in.\nFor queues, we also need to provide an event name to the event parameter to identify the step later on.\nFor resource use (both start and end), we need to provide an event name to the event parameter, and also provide a resource_id so that we are tracking which resource is in use when - which is why we needed to make the change to use the VidigiStore earlier.\n\nEvent types\n\narrival_departure\nWithin this, a minimum of two ‘arrival_departure’ events per entity are mandatory - arrival and depart, both with an event_type of arrival_departure, as shown below.\n\nlogger.log_arrival(\n        entity_id=patient.identifier\n        )\n\n\nlogger.log_departure(\n        entity_id=patient.identifier\n        )\n\nThese are critical as they are used to determine when patients should first and last appear in the model. Forgetting to include a departure step for all types of patients can lead to slow model performance as the size of the event logs for individual moments will continue to increase indefinitely.\n\n\n\n\n\n\nClick to see how we’d do this with a dictionary instead\n\n\n\n\n\n\nevent_log.append(\n      {'patient': unique_entity_identifier,\n      'pathway': 'Revision',\n      'event_type': 'arrival_departure',\n      'event': 'arrival',\n      'time': env.now}\n  )\n\n\nevent_log.append(\n      {'patient': unique_entity_identifier,\n      'pathway': 'Revision',\n      'event_type': 'arrival_departure',\n      'event': 'depart',\n      'time': env.now}\n  )\n\n\n\n\n\n\nqueue\nQueues are key steps in the model.\nIt is possible to solely use queues and never make use of a simpy resource.\nBy tracking each important step in the process as a ‘queue’ step, the movement of patients can be accurately tracked.\nEntities will be ordered by the point at which they are added to the queue, with the first entries appearing at the front (bottom-right) of the queue.\n\nlogger.log_queue(\n    entity_id=patient.identifier,\n    event=\"treatment_wait_begins\"\n)\n\nWhile the keys shown above are mandatory, you can add as many additional keys to a step’s log as desired. This can allow you to flexibly make use of the event log for other purposes as well as the animation.\n\n\n\n\n\n\nClick to see how we’d do this with a dictionary instead\n\n\n\n\n\n\nevent_log.append(\n            {'patient': unique_entity_identifier,\n             'pathway': 'High intensity',\n             'event_type': 'queue',\n             'event': 'appointment_booked_waiting',\n             'time': self.env.now\n             }\n        )\n\n\n\n\n\n\nresource_use and resource_use_end\nResource use is more complex to include but comes with two key benefits over the queue: - it becomes easier to monitor the length of time a resource is in use by a single entity as users won’t ‘move through’ the resource use stage (which can also prove confusing to less experienced viewers) - it becomes possible to show the total number of resources that are available, making it easier to understand how well resources are being utilised at different stages\n\nwith treatment_cubicles.request() as req:\n        # Make sure we assign the result of the yield to a variable\n        # Assuming we are using a VidigiStore or VidigiPriorityStore, this will allow us\n        # to access the useful ID attribute of the returned resource\n        treatment_cubicle = yield req\n\n        # As we've waited for a resource to become available\n        #  with the `yield req`, we can now record\n        # that the user's resource use is starting\n        logger.log_resource_use_start(\n                entity_id=patient.identifier,\n                event=\"treatment_begins\",\n                resource_id=treatment_cubicle.id_attribute\n                )  #&lt;&lt;\n\n        yield self.env.timeout(1) # some amount of time\n\n        # Now that we have waited for the patient to be seen,\n        # we can log that their use of the resource has ended\n        self.logger.log_resource_use_end(\n            entity_id=patient.identifier,\n            event=\"treatment_complete\",\n            resource_id=treatment_cubicle.id_attribute\n            )\n\n\n\n\n\n\n\nClick to see how we’d do this with a dictionary instead\n\n\n\n\n\n\nevent_log.append(\n    {'patient': unique_entity_identifier,\n     'pathway': 'Trauma',\n     'event_type': 'resource_use',\n     'event': 'triage_begins',\n     'time': env.now,\n     'resource_id': triage_resource.id_attribute\n    }\n)\n\nyield self.env.timeout(1) # some amount of time\n\nevent_log.append(\n            {'patient': unique_entity_identifier,\n             'pathway': 'Trauma',\n             'event_type': 'resource_use_end',\n             'event': 'triage_complete',\n             'time': env.now,\n             'resource_id': triage_resource.id_attribute}\n        )\n\n\n\n\nWhen providing your event position details, it then just requires you to include an identifier for the resource.\nThis requires you to be using an class to manage your resource counts (if following HSMA simpy structure, this will be your g class).",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "vidigi_docs/introduction.html#creating-the-animation",
    "href": "vidigi_docs/introduction.html#creating-the-animation",
    "title": "Usage Instructions with SimPy",
    "section": "Creating the animation",
    "text": "Creating the animation\n\nDetermining event positioning in the animation\nOnce the event log has been created, the positions of each queue and resource must be set up.\nAn easy way to create this is passing a list of dictionaries to the pd.DataFrame function.\nThe columns required are event: This must match the label used for the event in the event log x: The x coordinate of the event for the animation. This will correspond to the bottom-right hand corner of a queue, or the rightmost resource. y: The y coordinate of the event for the animaation. This will correspond to the lowest row of a queue, or the central point of the resources. label: A label for the stage. This can be hidden at a later step if you opt to use a background image with labels built-in. Note that line breaks in the label can be created using the HTML tag &lt;br&gt;. resource (OPTIONAL): Only required if the step is a resource_use step. This looks at the ‘scenario’ object passed to the animate_activity_log() function and pulls the attribute with the given name, which should give the number of available resources for that step.\nVidigi provides some helper classes and functions for setting this up.\n\nfrom vidigi.utils import create_event_position_df, EventPosition\n\nevent_position_df = create_event_position_df([\n    EventPosition(event='arrival', x=50, y=450, label=\"Arrival\"),\n    EventPosition(event='treatment_wait_begins', x=205, y=275, label=\"Waiting for Treatment\"),\n    EventPosition(event='treatment_begins', x=205, y=175, label=\"Being Treated\", resource='n_cubicles'),\n    EventPosition(event='depart', x=270, y=70, label=\"Exit\")\n])\n\n\n\n\n\n\n\nClick to see how we’d do this with a dictionary instead\n\n\n\n\n\nIf you’d rather not use the Vidigi helpers for this, you can just pass it as a dataframe, which can be easily generated with a list of dictionaries.\n\n        event_position_df = pd.DataFrame([\n                # Triage\n                {'event': 'triage_wait_begins',\n                 'x':  160, 'y': 400, 'label': \"Waiting for&lt;br&gt;Triage\"  },\n                {'event': 'triage_begins',\n                 'x':  160, 'y': 315, 'resource':'n_triage', 'label': \"Being Triaged\" },\n\n                # Trauma pathway\n                {'event': 'TRAUMA_stabilisation_wait_begins',\n                 'x': 300, 'y': 560, 'label': \"Waiting for&lt;br&gt;Stabilisation\" },\n                {'event': 'TRAUMA_stabilisation_begins',\n                 'x': 300, 'y': 500, 'resource':'n_trauma', 'label': \"Being&lt;br&gt;Stabilised\" },\n\n                {'event': 'TRAUMA_treatment_wait_begins',\n                 'x': 630, 'y': 560, 'label': \"Waiting for&lt;br&gt;Treatment\" },\n                {'event': 'TRAUMA_treatment_begins',\n                 'x': 630, 'y': 500, 'resource':'n_cubicles', 'label': \"Being&lt;br&gt;Treated\" },\n\n                 {'event': 'depart',\n                 'x':  670, 'y': 330, 'label': \"Exit\"}\n            ])\n\n\n\n\n\n\nCreating the animation\nThere are two main ways to create the animation:\n\nusing the one-step function animate_activity_log()\n\nSee this simple example or this slightly more complex example for a demonstration of this.\n\nusing the functions reshape_for_animations(), generate_animation_df() and generate_animation() separately, passing the output of each to the next step. This allows you to apply significant extra customisations to things such as entity icons for patients of different classes.\n\nSee this priority queueing example for a demonstration of this.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "vidigi_docs/introduction.html#emergency-department-treatment-centre-model",
    "href": "vidigi_docs/introduction.html#emergency-department-treatment-centre-model",
    "title": "Usage Instructions with SimPy",
    "section": "Emergency department (Treatment Centre) model",
    "text": "Emergency department (Treatment Centre) model\nMonks.T, Harper.A, Anagnoustou. A, Allen.M, Taylor.S. (2022) Open Science for Computer Simulation\nhttps://github.com/TomMonks/treatment-centre-sim\nThe layout code for the emergency department model: https://github.com/hsma-programme/Teaching_DES_Concepts_Streamlit",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "vidigi_docs/introduction.html#the-hospital-efficiency-project-model",
    "href": "vidigi_docs/introduction.html#the-hospital-efficiency-project-model",
    "title": "Usage Instructions with SimPy",
    "section": "The hospital efficiency project model",
    "text": "The hospital efficiency project model\nHarper, A., & Monks, T. Hospital Efficiency Project Orthopaedic Planning Model Discrete-Event Simulation [Computer software]. https://doi.org/10.5281/zenodo.7951080\nhttps://github.com/AliHarp/HEP/tree/main",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "vidigi_docs/introduction.html#simulation-model-with-scheduling-example",
    "href": "vidigi_docs/introduction.html#simulation-model-with-scheduling-example",
    "title": "Usage Instructions with SimPy",
    "section": "Simulation model with scheduling example",
    "text": "Simulation model with scheduling example\nMonks, T.\nhttps://github.com/health-data-science-OR/stochastic_systems\nhttps://github.com/health-data-science-OR/stochastic_systems/tree/master/labs/simulation/lab5",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "vidigi_docs/prep_vidigi_outputs_for_bupar_processing.html",
    "href": "vidigi_docs/prep_vidigi_outputs_for_bupar_processing.html",
    "title": "vidigi",
    "section": "",
    "text": "from examples.example_2_branching_multistep.ex_2_model_classes import Trial, g\nimport pandas as pd\nimport os\n\n\ng.sim_duration = 3000\ng.number_of_runs = 1\n\n\n\n\n\n\n\nView Imported Code, which has had logging steps added at the appropriate points in the ‘model’ class\n\n\n\n\n\nimport random\nimport numpy as np\nimport pandas as pd\nimport simpy\nfrom sim_tools.distributions import Exponential, Lognormal, Uniform, Normal, Bernoulli\nfrom vidigi.utils import populate_store\nfrom examples.simulation_utility_functions import trace\n\n\n# Class to store global parameter values.  We don't create an instance of this\n# class - we just refer to the class blueprint itself to access the numbers\n# inside.\nclass g:\n    '''\n    Create a scenario to parameterise the simulation model\n\n    Parameters:\n    -----------\n    random_number_set: int, optional (default=DEFAULT_RNG_SET)\n        Set to control the initial seeds of each stream of pseudo\n        random numbers used in the model.\n\n    n_triage: int\n        The number of triage cubicles\n\n    n_reg: int\n        The number of registration clerks\n\n    n_exam: int\n        The number of examination rooms\n\n    n_trauma: int\n        The number of trauma bays for stablisation\n\n    n_cubicles_non_trauma_treat: int\n        The number of non-trauma treatment cubicles\n\n    n_cubicles_trauma_treat: int\n        The number of trauma treatment cubicles\n\n    triage_mean: float\n        Mean duration of the triage distribution (Exponential)\n\n    reg_mean: float\n        Mean duration of the registration distribution (Lognormal)\n\n    reg_var: float\n        Variance of the registration distribution (Lognormal)\n\n    exam_mean: float\n        Mean of the examination distribution (Normal)\n\n    exam_var: float\n        Variance of the examination distribution (Normal)\n\n    trauma_mean: float\n        Mean of the trauma stabilisation distribution (Exponential)\n\n    trauma_treat_mean: float\n        Mean of the trauma cubicle treatment distribution (Lognormal)\n\n    trauma_treat_var: float\n        Variance of the trauma cubicle treatment distribution (Lognormal)\n\n    non_trauma_treat_mean: float\n        Mean of the non trauma treatment distribution\n\n    non_trauma_treat_var: float\n        Variance of the non trauma treatment distribution\n\n    non_trauma_treat_p: float\n        Probability non trauma patient requires treatment\n\n    prob_trauma: float\n        probability that a new arrival is a trauma patient.\n    '''\n    random_number_set = 42\n\n    n_triage=2\n    n_reg=2\n    n_exam=3\n    n_trauma=4\n    n_cubicles_non_trauma_treat=4\n    n_cubicles_trauma_treat=5\n\n    triage_mean=6\n    reg_mean=8\n    reg_var=2\n    exam_mean=16\n    exam_var=3\n    trauma_mean=90\n    trauma_treat_mean=30\n    trauma_treat_var=4\n    non_trauma_treat_mean=13.3\n    non_trauma_treat_var=2\n\n    non_trauma_treat_p=0.6\n    prob_trauma=0.12\n\n    arrival_df=\"ed_arrivals.csv\"\n\n    sim_duration = 600\n    number_of_runs = 100\n\n# Class representing patients coming in to the clinic.\nclass Patient:\n    '''\n    Class defining details for a patient entity\n    '''\n    def __init__(self, p_id):\n        '''\n        Constructor method\n\n        Params:\n        -----\n        identifier: int\n            a numeric identifier for the patient.\n        '''\n        self.identifier = p_id\n\n        # Time of arrival in model/at centre\n        self.arrival = -np.inf\n        # Total time in pathway\n        self.total_time = -np.inf\n\n        # Shared waits\n        self.wait_triage = -np.inf\n        self.wait_reg = -np.inf\n        self.wait_treat = -np.inf\n        # Non-trauma pathway - examination wait\n        self.wait_exam = -np.inf\n        # Trauma pathway - stabilisation wait\n        self.wait_trauma = -np.inf\n\n        # Shared durations\n        self.triage_duration = -np.inf\n        self.reg_duration = -np.inf\n        self.treat_duration = -np.inf\n\n        # Non-trauma pathway - examination duration\n        self.exam_duration = -np.inf\n        # Trauma pathway - stabilisation duration\n        self.trauma_duration = -np.inf\n\n\n# Class representing our model of the clinic.\nclass Model:\n    '''\n    Simulates the simplest minor treatment process for a patient\n\n    1. Arrive\n    2. Examined/treated by nurse when one available\n    3. Discharged\n    '''\n    # Constructor to set up the model for a run.  We pass in a run number when\n    # we create a new model.\n    def __init__(self, run_number):\n        # Create a SimPy environment in which everything will live\n        self.env = simpy.Environment()\n\n        self.event_log = []\n\n        # Create a patient counter (which we'll use as a patient ID)\n        self.patient_counter = 0\n\n        self.trauma_patients = []\n        self.non_trauma_patients = []\n\n        # Create our resources\n        self.init_resources()\n\n        # Store the passed in run number\n        self.run_number = run_number\n\n        # Create a new Pandas DataFrame that will store some results against\n        # the patient ID (which we'll use as the index).\n        self.results_df = pd.DataFrame()\n        self.results_df[\"Patient ID\"] = [1]\n        self.results_df[\"Queue Time Cubicle\"] = [0.0]\n        self.results_df[\"Time with Nurse\"] = [0.0]\n        self.results_df.set_index(\"Patient ID\", inplace=True)\n\n        # Create an attribute to store the mean queuing times across this run of\n        # the model\n        self.mean_q_time_cubicle = 0\n\n        # create distributions\n\n        # Triage duration\n        self.triage_dist = Exponential(g.triage_mean,\n                                       random_seed=self.run_number*g.random_number_set)\n\n        # Registration duration (non-trauma only)\n        self.reg_dist = Lognormal(g.reg_mean,\n                                  np.sqrt(g.reg_var),\n                                  random_seed=self.run_number*g.random_number_set)\n\n        # Evaluation (non-trauma only)\n        self.exam_dist = Normal(g.exam_mean,\n                                np.sqrt(g.exam_var),\n                                random_seed=self.run_number*g.random_number_set)\n\n        # Trauma/stablisation duration (trauma only)\n        self.trauma_dist = Exponential(g.trauma_mean,\n                                       random_seed=self.run_number*g.random_number_set)\n\n        # Non-trauma treatment\n        self.nt_treat_dist = Lognormal(g.non_trauma_treat_mean,\n                                       np.sqrt(g.non_trauma_treat_var),\n                                       random_seed=self.run_number*g.random_number_set)\n\n        # treatment of trauma patients\n        self.treat_dist = Lognormal(g.trauma_treat_mean,\n                                    np.sqrt(g.non_trauma_treat_var),\n                                    random_seed=self.run_number*g.random_number_set)\n\n        # probability of non-trauma patient requiring treatment\n        self.nt_p_treat_dist = Bernoulli(g.non_trauma_treat_p,\n                                         random_seed=self.run_number*g.random_number_set)\n\n        # probability of non-trauma versus trauma patient\n        self.p_trauma_dist = Bernoulli(g.prob_trauma,\n                                       random_seed=self.run_number*g.random_number_set)\n\n        # init sampling for non-stationary poisson process\n        self.init_nspp()\n\n    def init_nspp(self):\n\n        # read arrival profile\n        self.arrivals = pd.read_csv(g.arrival_df)  # pylint: disable=attribute-defined-outside-init\n        self.arrivals['mean_iat'] = 60 / self.arrivals['arrival_rate']\n\n        # maximum arrival rate (smallest time between arrivals)\n        self.lambda_max = self.arrivals['arrival_rate'].max()  # pylint: disable=attribute-defined-outside-init\n\n        # thinning exponential\n        self.arrival_dist = Exponential(60.0 / self.lambda_max,  # pylint: disable=attribute-defined-outside-init\n                                            random_seed=self.run_number*g.random_number_set)\n\n        # thinning uniform rng\n        self.thinning_rng = Uniform(low=0.0, high=1.0,  # pylint: disable=attribute-defined-outside-init\n                                    random_seed=self.run_number*g.random_number_set)\n\n\n    def init_resources(self):\n        '''\n        Init the number of resources\n        and store in the arguments container object\n\n        Resource list:\n            1. Nurses/treatment bays (same thing in this model)\n\n        '''\n        # Shared Resources\n        self.triage_cubicles = simpy.Store(self.env)\n        populate_store(num_resources=g.n_triage,\n                simpy_store=self.triage_cubicles,\n                sim_env=self.env)\n\n        self.registration_cubicles = simpy.Store(self.env)\n        populate_store(num_resources=g.n_reg,\n                       simpy_store=self.registration_cubicles,\n                       sim_env=self.env)\n\n        # Non-trauma\n        self.exam_cubicles = simpy.Store(self.env)\n        populate_store(num_resources=g.n_exam,\n                       simpy_store=self.exam_cubicles,\n                       sim_env=self.env)\n\n        self.non_trauma_treatment_cubicles = simpy.Store(self.env)\n        populate_store(num_resources=g.n_cubicles_non_trauma_treat,\n                       simpy_store=self.non_trauma_treatment_cubicles,\n                       sim_env=self.env)\n\n        # Trauma\n        self.trauma_stabilisation_bays = simpy.Store(self.env)\n        populate_store(num_resources=g.n_trauma,\n                       simpy_store=self.trauma_stabilisation_bays,\n                       sim_env=self.env)\n\n        self.trauma_treatment_cubicles = simpy.Store(self.env)\n        populate_store(num_resources=g.n_cubicles_trauma_treat,\n                       simpy_store=self.trauma_treatment_cubicles,\n                       sim_env=self.env)\n\n    # A generator function that represents the DES generator for patient\n    # arrivals\n    def generator_patient_arrivals(self):\n        # We use an infinite loop here to keep doing this indefinitely whilst\n        # the simulation runs\n        while True:\n            t = int(self.env.now // 60) % self.arrivals.shape[0]\n            lambda_t = self.arrivals['arrival_rate'].iloc[t]\n\n            # set to a large number so that at least 1 sample taken!\n            u = np.Inf\n\n            interarrival_time = 0.0\n            # reject samples if u &gt;= lambda_t / lambda_max\n            while u &gt;= (lambda_t / self.lambda_max):\n                interarrival_time += self.arrival_dist.sample()\n                u = self.thinning_rng.sample()\n\n            # Freeze this instance of this function in place until the\n            # inter-arrival time we sampled above has elapsed.  Note - time in\n            # SimPy progresses in \"Time Units\", which can represent anything\n            # you like (just make sure you're consistent within the model)\n            yield self.env.timeout(interarrival_time)\n\n            # Increment the patient counter by 1 (this means our first patient\n            # will have an ID of 1)\n            self.patient_counter += 1\n\n            # Create a new patient - an instance of the Patient Class we\n            # defined above.  Remember, we pass in the ID when creating a\n            # patient - so here we pass the patient counter to use as the ID.\n            p = Patient(self.patient_counter)\n\n            trace(f'patient {self.patient_counter} arrives at: {self.env.now:.3f}')\n            self.event_log.append(\n                {'patient': self.patient_counter,\n                 'pathway': 'Shared',\n                 'event': 'arrival',\n                 'event_type': 'arrival_departure',\n                 'time': self.env.now}\n            )\n\n            # sample if the patient is trauma or non-trauma\n            trauma = self.p_trauma_dist.sample()\n\n            # Tell SimPy to start up the attend_clinic generator function with\n            # this patient (the generator function that will model the\n            # patient's journey through the system)\n            # and store patient in list for later easy access\n            if trauma:\n                # create and store a trauma patient to update KPIs.\n                self.trauma_patients.append(p)\n                self.env.process(self.attend_trauma_pathway(p))\n\n            else:\n                # create and store a non-trauma patient to update KPIs.\n                self.non_trauma_patients.append(p)\n                self.env.process(self.attend_non_trauma_pathway(p))\n\n    # A generator function that represents the pathway for a patient going\n    # through the clinic.\n    # The patient object is passed in to the generator function so we can\n    # extract information from / record information to it\n    def attend_non_trauma_pathway(self, patient):\n        '''\n        simulates the non-trauma/minor treatment process for a patient\n\n        1. request and wait for sign-in/triage\n        2. patient registration\n        3. examination\n        4a. percentage discharged\n        4b. remaining percentage treatment then discharge\n        '''\n        # record the time of arrival and entered the triage queue\n        patient.arrival = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Non-Trauma',\n             'event_type': 'queue',\n             'event': 'triage_wait_begins',\n             'time': self.env.now}\n        )\n\n        ###################################################\n        # request sign-in/triage\n        triage_resource = yield self.triage_cubicles.get()\n\n        # record the waiting time for triage\n        patient.wait_triage = self.env.now - patient.arrival\n        trace(f'patient {patient.identifier} triaged to minors '\n                f'{self.env.now:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Non-Trauma',\n                'event_type': 'resource_use',\n                'event': 'triage_begins',\n                'time': self.env.now,\n                'resource_id': triage_resource.id_attribute\n                }\n        )\n\n        # sample triage duration.\n        patient.triage_duration = self.triage_dist.sample()\n        yield self.env.timeout(patient.triage_duration)\n\n        trace(f'triage {patient.identifier} complete {self.env.now:.3f}; '\n                f'waiting time was {patient.wait_triage:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Non-Trauma',\n                'event_type': 'resource_use_end',\n                'event': 'triage_complete',\n                'time': self.env.now,\n                'resource_id': triage_resource.id_attribute}\n        )\n\n        # Resource is no longer in use, so put it back in the store\n        self.triage_cubicles.put(triage_resource)\n        #########################################################\n\n        # record the time that entered the registration queue\n        start_wait = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Non-Trauma',\n             'event_type': 'queue',\n             'event': 'MINORS_registration_wait_begins',\n             'time': self.env.now}\n        )\n\n        #########################################################\n        # request registration clerk\n        registration_resource = yield self.registration_cubicles.get()\n\n        # record the waiting time for registration\n        patient.wait_reg = self.env.now - start_wait\n        trace(f'registration of patient {patient.identifier} at '\n                f'{self.env.now:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Non-Trauma',\n                'event_type': 'resource_use',\n                'event': 'MINORS_registration_begins',\n                'time': self.env.now,\n                'resource_id': registration_resource.id_attribute\n                }\n        )\n\n        # sample registration duration.\n        patient.reg_duration = self.reg_dist.sample()\n        yield self.env.timeout(patient.reg_duration)\n\n        trace(f'patient {patient.identifier} registered at'\n                f'{self.env.now:.3f}; '\n                f'waiting time was {patient.wait_reg:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Non-Trauma',\n                'event': 'MINORS_registration_complete',\n                'event_type': 'resource_use_end',\n                'time': self.env.now,\n                'resource_id': registration_resource.id_attribute}\n        )\n        # Resource is no longer in use, so put it back in the store\n        self.registration_cubicles.put(registration_resource)\n        ########################################################\n\n        # record the time that entered the evaluation queue\n        start_wait = self.env.now\n\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Non-Trauma',\n             'event': 'MINORS_examination_wait_begins',\n             'event_type': 'queue',\n             'time': self.env.now}\n        )\n\n        #########################################################\n        # request examination resource\n        examination_resource = yield self.exam_cubicles.get()\n\n        # record the waiting time for examination to begin\n        patient.wait_exam = self.env.now - start_wait\n        trace(f'examination of patient {patient.identifier} begins '\n                f'{self.env.now:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Non-Trauma',\n                'event': 'MINORS_examination_begins',\n                'event_type': 'resource_use',\n                'time': self.env.now,\n                'resource_id': examination_resource.id_attribute\n                }\n        )\n\n        # sample examination duration.\n        patient.exam_duration = self.exam_dist.sample()\n        yield self.env.timeout(patient.exam_duration)\n\n        trace(f'patient {patient.identifier} examination complete '\n                f'at {self.env.now:.3f};'\n                f'waiting time was {patient.wait_exam:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Non-Trauma',\n                'event': 'MINORS_examination_complete',\n                'event_type': 'resource_use_end',\n                'time': self.env.now,\n                'resource_id': examination_resource.id_attribute}\n        )\n        # Resource is no longer in use, so put it back in\n        self.exam_cubicles.put(examination_resource)\n        ############################################################################\n\n        # sample if patient requires treatment?\n        patient.require_treat = self.nt_p_treat_dist.sample()  #pylint: disable=attribute-defined-outside-init\n\n        if patient.require_treat:\n\n            self.event_log.append(\n                {'patient': patient.identifier,\n                 'pathway': 'Non-Trauma',\n                 'event': 'requires_treatment',\n                 'event_type': 'attribute_assigned',\n                 'time': self.env.now}\n            )\n\n            # record the time that entered the treatment queue\n            start_wait = self.env.now\n            self.event_log.append(\n                {'patient': patient.identifier,\n                 'pathway': 'Non-Trauma',\n                 'event': 'MINORS_treatment_wait_begins',\n                 'event_type': 'queue',\n                 'time': self.env.now}\n            )\n            ###################################################\n            # request treatment cubicle\n\n            non_trauma_treatment_resource = yield self.non_trauma_treatment_cubicles.get()\n\n            # record the waiting time for treatment\n            patient.wait_treat = self.env.now - start_wait\n            trace(f'treatment of patient {patient.identifier} begins '\n                    f'{self.env.now:.3f}')\n            self.event_log.append(\n                {'patient': patient.identifier,\n                    'pathway': 'Non-Trauma',\n                    'event': 'MINORS_treatment_begins',\n                    'event_type': 'resource_use',\n                    'time': self.env.now,\n                    'resource_id': non_trauma_treatment_resource.id_attribute\n                }\n            )\n\n            # sample treatment duration.\n            patient.treat_duration = self.nt_treat_dist.sample()\n            yield self.env.timeout(patient.treat_duration)\n\n            trace(f'patient {patient.identifier} treatment complete '\n                    f'at {self.env.now:.3f};'\n                    f'waiting time was {patient.wait_treat:.3f}')\n            self.event_log.append(\n                {'patient': patient.identifier,\n                    'pathway': 'Non-Trauma',\n                    'event': 'MINORS_treatment_complete',\n                    'event_type': 'resource_use_end',\n                    'time': self.env.now,\n                    'resource_id': non_trauma_treatment_resource.id_attribute}\n            )\n\n            # Resource is no longer in use, so put it back in the store\n            self.non_trauma_treatment_cubicles.put(non_trauma_treatment_resource)\n        ##########################################################################\n\n        # Return to what happens to all patients, regardless of whether they were sampled as needing treatment\n        self.event_log.append(\n            {'patient': patient.identifier,\n            'pathway': 'Shared',\n            'event': 'depart',\n            'event_type': 'arrival_departure',\n            'time': self.env.now}\n        )\n\n        # total time in system\n        patient.total_time = self.env.now - patient.arrival\n\n    def attend_trauma_pathway(self, patient):\n        '''\n        simulates the major treatment process for a patient\n\n        1. request and wait for sign-in/triage\n        2. trauma\n        3. treatment\n        '''\n        # record the time of arrival and entered the triage queue\n        patient.arrival = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'queue',\n             'event': 'triage_wait_begins',\n             'time': self.env.now}\n        )\n\n        ###################################################\n        # request sign-in/triage\n        triage_resource = yield self.triage_cubicles.get()\n\n        # record the waiting time for triage\n        patient.wait_triage = self.env.now - patient.arrival\n\n        trace(f'patient {patient.identifier} triaged to trauma '\n                f'{self.env.now:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'resource_use',\n             'event': 'triage_begins',\n             'time': self.env.now,\n             'resource_id': triage_resource.id_attribute\n            }\n        )\n\n        # sample triage duration.\n        patient.triage_duration = self.triage_dist.sample()\n        yield self.env.timeout(patient.triage_duration)\n\n        trace(f'triage {patient.identifier} complete {self.env.now:.3f}; '\n              f'waiting time was {patient.wait_triage:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'resource_use_end',\n             'event': 'triage_complete',\n             'time': self.env.now,\n             'resource_id': triage_resource.id_attribute}\n        )\n\n        # Resource is no longer in use, so put it back in the store\n        self.triage_cubicles.put(triage_resource)\n        ###################################################\n\n        # record the time that entered the trauma queue\n        start_wait = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'queue',\n             'event': 'TRAUMA_stabilisation_wait_begins',\n             'time': self.env.now}\n        )\n\n        ###################################################\n        # request trauma room\n        trauma_resource = yield self.trauma_stabilisation_bays.get()\n\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Trauma',\n                'event_type': 'resource_use',\n                'event': 'TRAUMA_stabilisation_begins',\n                'time': self.env.now,\n                'resource_id': trauma_resource.id_attribute\n                }\n        )\n\n        # record the waiting time for trauma\n        patient.wait_trauma = self.env.now - start_wait\n\n        # sample stablisation duration.\n        patient.trauma_duration = self.trauma_dist.sample()\n        yield self.env.timeout(patient.trauma_duration)\n\n        trace(f'stabilisation of patient {patient.identifier} at '\n              f'{self.env.now:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'resource_use_end',\n             'event': 'TRAUMA_stabilisation_complete',\n             'time': self.env.now,\n             'resource_id': trauma_resource.id_attribute\n            }\n        )\n        # Resource is no longer in use, so put it back in the store\n        self.trauma_stabilisation_bays.put(trauma_resource)\n\n        #######################################################\n\n        # record the time that patient entered the treatment queue\n        start_wait = self.env.now\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'queue',\n             'event': 'TRAUMA_treatment_wait_begins',\n             'time': self.env.now}\n        )\n\n        ########################################################\n        # request treatment cubicle\n        trauma_treatment_resource = yield self.trauma_treatment_cubicles.get()\n\n        # record the waiting time for trauma\n        patient.wait_treat = self.env.now - start_wait\n        trace(f'treatment of patient {patient.identifier} at '\n                f'{self.env.now:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n                'pathway': 'Trauma',\n                'event_type': 'resource_use',\n                'event': 'TRAUMA_treatment_begins',\n                'time': self.env.now,\n                'resource_id': trauma_treatment_resource.id_attribute\n                }\n        )\n\n        # sample treatment duration.\n        patient.treat_duration = self.trauma_dist.sample()\n        yield self.env.timeout(patient.treat_duration)\n\n        trace(f'patient {patient.identifier} treatment complete {self.env.now:.3f}; '\n              f'waiting time was {patient.wait_treat:.3f}')\n        self.event_log.append(\n            {'patient': patient.identifier,\n             'pathway': 'Trauma',\n             'event_type': 'resource_use_end',\n             'event': 'TRAUMA_treatment_complete',\n             'time': self.env.now,\n             'resource_id': trauma_treatment_resource.id_attribute}\n        )\n        self.event_log.append(\n            {'patient': patient.identifier,\n            'pathway': 'Shared',\n            'event': 'depart',\n            'event_type': 'arrival_departure',\n            'time': self.env.now}\n        )\n\n        # Resource is no longer in use, so put it back in the store\n        self.trauma_treatment_cubicles.put(trauma_treatment_resource)\n\n        #########################################################\n\n        # total time in system\n        patient.total_time = self.env.now - patient.arrival\n\n\n    # This method calculates results over a single run.  Here we just calculate\n    # a mean, but in real world models you'd probably want to calculate more.\n    def calculate_run_results(self):\n        # Take the mean of the queuing times across patients in this run of the\n        # model.\n        self.mean_q_time_cubicle = self.results_df[\"Queue Time Cubicle\"].mean()\n\n    # The run method starts up the DES entity generators, runs the simulation,\n    # and in turns calls anything we need to generate results for the run\n    def run(self):\n        # Start up our DES entity generators that create new patients.  We've\n        # only got one in this model, but we'd need to do this for each one if\n        # we had multiple generators.\n        self.env.process(self.generator_patient_arrivals())\n\n        # Run the model for the duration specified in g class\n        self.env.run(until=g.sim_duration)\n\n        # Now the simulation run has finished, call the method that calculates\n        # run results\n        self.calculate_run_results()\n\n        self.event_log = pd.DataFrame(self.event_log)\n\n        self.event_log[\"run\"] = self.run_number\n\n        return {'results': self.results_df, 'event_log': self.event_log}\n\n# Class representing a Trial for our simulation - a batch of simulation runs.\nclass Trial:\n    # The constructor sets up a pandas dataframe that will store the key\n    # results from each run against run number, with run number as the index.\n    def  __init__(self):\n        self.df_trial_results = pd.DataFrame()\n        self.df_trial_results[\"Run Number\"] = [0]\n        self.df_trial_results[\"Arrivals\"] = [0]\n        self.df_trial_results[\"Mean Queue Time Cubicle\"] = [0.0]\n        self.df_trial_results.set_index(\"Run Number\", inplace=True)\n\n        self.all_event_logs = []\n\n    # Method to run a trial\n    def run_trial(self):\n        # Run the simulation for the number of runs specified in g class.\n        # For each run, we create a new instance of the Model class and call its\n        # run method, which sets everything else in motion.  Once the run has\n        # completed, we grab out the stored run results (just mean queuing time\n        # here) and store it against the run number in the trial results\n        # dataframe.\n        for run in range(g.number_of_runs):\n            random.seed(run)\n\n            my_model = Model(run)\n            model_outputs = my_model.run()\n            patient_level_results = model_outputs[\"results\"]\n            event_log = model_outputs[\"event_log\"]\n\n            self.df_trial_results.loc[run] = [\n                len(patient_level_results),\n                my_model.mean_q_time_cubicle,\n            ]\n\n            # print(event_log)\n\n            self.all_event_logs.append(event_log)\n\n        self.all_event_logs = pd.concat(self.all_event_logs)\n\n\n\n\nmy_trial = Trial()\n\nmy_trial.run_trial()\n\n\nmy_trial.all_event_logs.head(10)\n\n\n\n\n\n\n\n\npatient\npathway\nevent\nevent_type\ntime\nresource_id\nrun\n\n\n\n\n0\n1\nShared\narrival\narrival_departure\n3.285355\nNaN\n0\n\n\n1\n1\nNon-Trauma\ntriage_wait_begins\nqueue\n3.285355\nNaN\n0\n\n\n2\n1\nNon-Trauma\ntriage_begins\nresource_use\n3.285355\n1.0\n0\n\n\n3\n2\nShared\narrival\narrival_departure\n3.289691\nNaN\n0\n\n\n4\n2\nNon-Trauma\ntriage_wait_begins\nqueue\n3.289691\nNaN\n0\n\n\n5\n2\nNon-Trauma\ntriage_begins\nresource_use\n3.289691\n2.0\n0\n\n\n6\n1\nNon-Trauma\ntriage_complete\nresource_use_end\n7.364946\n1.0\n0\n\n\n7\n1\nNon-Trauma\nMINORS_registration_wait_begins\nqueue\n7.364946\nNaN\n0\n\n\n8\n1\nNon-Trauma\nMINORS_registration_begins\nresource_use\n7.364946\n1.0\n0\n\n\n9\n2\nNon-Trauma\ntriage_complete\nresource_use_end\n9.407274\n2.0\n0\n\n\n\n\n\n\n\n\nmy_trial.all_event_logs.event_type.value_counts()\n\nevent_type\nqueue                 2100\nresource_use          2035\nresource_use_end      2021\narrival_departure     1167\nattribute_assigned     264\nName: count, dtype: int64\n\n\n\nmy_trial.all_event_logs.event.value_counts()\n\nevent\narrival                             623\ntriage_wait_begins                  623\ntriage_begins                       622\ntriage_complete                     620\ndepart                              544\nMINORS_registration_wait_begins     539\nMINORS_registration_begins          514\nMINORS_registration_complete        512\nMINORS_examination_wait_begins      512\nMINORS_examination_begins           475\nMINORS_examination_complete         472\nrequires_treatment                  264\nMINORS_treatment_wait_begins        264\nMINORS_treatment_begins             264\nMINORS_treatment_complete           262\nTRAUMA_stabilisation_wait_begins     81\nTRAUMA_stabilisation_begins          81\nTRAUMA_stabilisation_complete        81\nTRAUMA_treatment_wait_begins         81\nTRAUMA_treatment_begins              79\nTRAUMA_treatment_complete            74\nName: count, dtype: int64\n\n\n\n# First, identify all patients who have a 'depart' event\n# patients_with_depart = my_trial.all_event_logs[my_trial.all_event_logs['event'].str.contains('depart')]['patient'].unique()\n\n# Then filter the original DataFrame to only include those patients\n# filtered_df = my_trial.all_event_logs[my_trial.all_event_logs['patient'].isin(patients_with_depart)]\n\nlogs_transformed = my_trial.all_event_logs[~my_trial.all_event_logs['event'].str.contains('wait')].copy()\n# logs_transformed = filtered_df[~filtered_df['event'].str.contains('wait')].copy()\nlogs_transformed = logs_transformed[logs_transformed['event_type'].isin(['resource_use', 'resource_use_end'])].copy()\nlogs_transformed['event_stage'] = logs_transformed['event_type'].apply(lambda x: 'complete' if 'end' in x else 'start')\nlogs_transformed['event_name'] = logs_transformed['event'].str.replace('_begins|_complete', '', regex=True)\nlogs_transformed['resource_id_full'] = logs_transformed.apply(lambda x: f\"{x['event_name']}_{x['resource_id']:.0f}\", axis=1)\nlogs_transformed = logs_transformed.sort_values(['run', 'time'], ascending=True)\n# logs_transformed[\"activity_id\"] = (\n#     logs_transformed.groupby([\"run\", \"patient\", \"event_name\"]).ngroup() + 1\n# )\n\n# logs_transformed = logs_transformed.sort_values([\"run\", \"patient\", \"activity_id\", \"event_stage\"], ascending=[True, True, True, False])\n\n# Sort the data by run, patient, time, and event_name to handle tied start times\nlogs_transformed = logs_transformed.sort_values([\"run\", \"patient\", \"time\", \"event_name\"])\n\n# Get the first occurrence of each activity (the start event)\nfirst_occurrences = (\n    logs_transformed[logs_transformed[\"event_stage\"] == \"start\"]\n    .drop_duplicates([\"run\", \"patient\", \"event_name\"])\n    .copy()\n)\n\n# Sort by time within each run to determine the proper sequence\nfirst_occurrences = first_occurrences.sort_values([\"run\", \"time\", \"event_name\"])\n\n# Assign sequential activity_id within each run\nfirst_occurrences[\"activity_id\"] = first_occurrences.groupby(\"run\").cumcount() + 1\n\n# Merge the activity_id back to the main DataFrame\nlogs_transformed = logs_transformed.merge(\n    first_occurrences[[\"run\", \"patient\", \"event_name\", \"activity_id\"]],\n    on=[\"run\", \"patient\", \"event_name\"],\n    how=\"left\"\n)\n\n# Sort for final ordering\nlogs_transformed = logs_transformed.sort_values(\n    [\"run\", \"patient\", \"activity_id\", \"event_stage\"],\n    ascending=[True, True, True, False]\n)\nlogs_transformed.head(50)\n\n\n\n\n\n\n\n\npatient\npathway\nevent\nevent_type\ntime\nresource_id\nrun\nevent_stage\nevent_name\nresource_id_full\nactivity_id\n\n\n\n\n0\n1\nNon-Trauma\ntriage_begins\nresource_use\n3.285355\n1.0\n0\nstart\ntriage\ntriage_1\n1\n\n\n2\n1\nNon-Trauma\ntriage_complete\nresource_use_end\n7.364946\n1.0\n0\ncomplete\ntriage\ntriage_1\n1\n\n\n1\n1\nNon-Trauma\nMINORS_registration_begins\nresource_use\n7.364946\n1.0\n0\nstart\nMINORS_registration\nMINORS_registration_1\n3\n\n\n4\n1\nNon-Trauma\nMINORS_registration_complete\nresource_use_end\n15.418481\n1.0\n0\ncomplete\nMINORS_registration\nMINORS_registration_1\n3\n\n\n3\n1\nNon-Trauma\nMINORS_examination_begins\nresource_use\n15.418481\n1.0\n0\nstart\nMINORS_examination\nMINORS_examination_1\n5\n\n\n5\n1\nNon-Trauma\nMINORS_examination_complete\nresource_use_end\n31.636252\n1.0\n0\ncomplete\nMINORS_examination\nMINORS_examination_1\n5\n\n\n6\n2\nNon-Trauma\ntriage_begins\nresource_use\n3.289691\n2.0\n0\nstart\ntriage\ntriage_2\n2\n\n\n8\n2\nNon-Trauma\ntriage_complete\nresource_use_end\n9.407274\n2.0\n0\ncomplete\ntriage\ntriage_2\n2\n\n\n7\n2\nNon-Trauma\nMINORS_registration_begins\nresource_use\n9.407274\n2.0\n0\nstart\nMINORS_registration\nMINORS_registration_2\n4\n\n\n10\n2\nNon-Trauma\nMINORS_registration_complete\nresource_use_end\n17.104670\n2.0\n0\ncomplete\nMINORS_registration\nMINORS_registration_2\n4\n\n\n9\n2\nNon-Trauma\nMINORS_examination_begins\nresource_use\n17.104670\n2.0\n0\nstart\nMINORS_examination\nMINORS_examination_2\n6\n\n\n11\n2\nNon-Trauma\nMINORS_examination_complete\nresource_use_end\n32.875857\n2.0\n0\ncomplete\nMINORS_examination\nMINORS_examination_2\n6\n\n\n12\n2\nNon-Trauma\nMINORS_treatment_begins\nresource_use\n32.875857\n1.0\n0\nstart\nMINORS_treatment\nMINORS_treatment_1\n7\n\n\n13\n2\nNon-Trauma\nMINORS_treatment_complete\nresource_use_end\n46.278797\n1.0\n0\ncomplete\nMINORS_treatment\nMINORS_treatment_1\n7\n\n\n14\n3\nNon-Trauma\ntriage_begins\nresource_use\n33.426168\n1.0\n0\nstart\ntriage\ntriage_1\n8\n\n\n16\n3\nNon-Trauma\ntriage_complete\nresource_use_end\n33.545008\n1.0\n0\ncomplete\ntriage\ntriage_1\n8\n\n\n15\n3\nNon-Trauma\nMINORS_registration_begins\nresource_use\n33.545008\n1.0\n0\nstart\nMINORS_registration\nMINORS_registration_1\n9\n\n\n18\n3\nNon-Trauma\nMINORS_registration_complete\nresource_use_end\n42.359504\n1.0\n0\ncomplete\nMINORS_registration\nMINORS_registration_1\n9\n\n\n17\n3\nNon-Trauma\nMINORS_examination_begins\nresource_use\n42.359504\n3.0\n0\nstart\nMINORS_examination\nMINORS_examination_3\n12\n\n\n19\n3\nNon-Trauma\nMINORS_examination_complete\nresource_use_end\n59.468749\n3.0\n0\ncomplete\nMINORS_examination\nMINORS_examination_3\n12\n\n\n20\n3\nNon-Trauma\nMINORS_treatment_begins\nresource_use\n59.468749\n2.0\n0\nstart\nMINORS_treatment\nMINORS_treatment_2\n16\n\n\n21\n3\nNon-Trauma\nMINORS_treatment_complete\nresource_use_end\n72.510229\n2.0\n0\ncomplete\nMINORS_treatment\nMINORS_treatment_2\n16\n\n\n22\n4\nNon-Trauma\ntriage_begins\nresource_use\n37.900548\n2.0\n0\nstart\ntriage\ntriage_2\n10\n\n\n24\n4\nNon-Trauma\ntriage_complete\nresource_use_end\n37.914164\n2.0\n0\ncomplete\ntriage\ntriage_2\n10\n\n\n23\n4\nNon-Trauma\nMINORS_registration_begins\nresource_use\n37.914164\n2.0\n0\nstart\nMINORS_registration\nMINORS_registration_2\n11\n\n\n26\n4\nNon-Trauma\nMINORS_registration_complete\nresource_use_end\n45.938325\n2.0\n0\ncomplete\nMINORS_registration\nMINORS_registration_2\n11\n\n\n25\n4\nNon-Trauma\nMINORS_examination_begins\nresource_use\n45.938325\n1.0\n0\nstart\nMINORS_examination\nMINORS_examination_1\n13\n\n\n27\n4\nNon-Trauma\nMINORS_examination_complete\nresource_use_end\n62.120017\n1.0\n0\ncomplete\nMINORS_examination\nMINORS_examination_1\n13\n\n\n28\n4\nNon-Trauma\nMINORS_treatment_begins\nresource_use\n62.120017\n3.0\n0\nstart\nMINORS_treatment\nMINORS_treatment_3\n17\n\n\n29\n4\nNon-Trauma\nMINORS_treatment_complete\nresource_use_end\n76.274743\n3.0\n0\ncomplete\nMINORS_treatment\nMINORS_treatment_3\n17\n\n\n30\n5\nNon-Trauma\ntriage_begins\nresource_use\n51.770459\n1.0\n0\nstart\ntriage\ntriage_1\n14\n\n\n32\n5\nNon-Trauma\ntriage_complete\nresource_use_end\n55.072516\n1.0\n0\ncomplete\ntriage\ntriage_1\n14\n\n\n31\n5\nNon-Trauma\nMINORS_registration_begins\nresource_use\n55.072516\n1.0\n0\nstart\nMINORS_registration\nMINORS_registration_1\n15\n\n\n34\n5\nNon-Trauma\nMINORS_registration_complete\nresource_use_end\n62.243834\n1.0\n0\ncomplete\nMINORS_registration\nMINORS_registration_1\n15\n\n\n33\n5\nNon-Trauma\nMINORS_examination_begins\nresource_use\n62.243834\n2.0\n0\nstart\nMINORS_examination\nMINORS_examination_2\n18\n\n\n35\n5\nNon-Trauma\nMINORS_examination_complete\nresource_use_end\n77.316027\n2.0\n0\ncomplete\nMINORS_examination\nMINORS_examination_2\n18\n\n\n36\n6\nTrauma\ntriage_begins\nresource_use\n113.767200\n2.0\n0\nstart\ntriage\ntriage_2\n19\n\n\n38\n6\nTrauma\ntriage_complete\nresource_use_end\n123.546842\n2.0\n0\ncomplete\ntriage\ntriage_2\n19\n\n\n37\n6\nTrauma\nTRAUMA_stabilisation_begins\nresource_use\n123.546842\n1.0\n0\nstart\nTRAUMA_stabilisation\nTRAUMA_stabilisation_1\n21\n\n\n39\n6\nTrauma\nTRAUMA_stabilisation_complete\nresource_use_end\n184.740714\n1.0\n0\ncomplete\nTRAUMA_stabilisation\nTRAUMA_stabilisation_1\n21\n\n\n40\n6\nTrauma\nTRAUMA_treatment_begins\nresource_use\n184.740714\n1.0\n0\nstart\nTRAUMA_treatment\nTRAUMA_treatment_1\n37\n\n\n41\n6\nTrauma\nTRAUMA_treatment_complete\nresource_use_end\n186.523313\n1.0\n0\ncomplete\nTRAUMA_treatment\nTRAUMA_treatment_1\n37\n\n\n42\n7\nNon-Trauma\ntriage_begins\nresource_use\n123.044756\n1.0\n0\nstart\ntriage\ntriage_1\n20\n\n\n44\n7\nNon-Trauma\ntriage_complete\nresource_use_end\n127.086253\n1.0\n0\ncomplete\ntriage\ntriage_1\n20\n\n\n43\n7\nNon-Trauma\nMINORS_registration_begins\nresource_use\n127.086253\n2.0\n0\nstart\nMINORS_registration\nMINORS_registration_2\n23\n\n\n46\n7\nNon-Trauma\nMINORS_registration_complete\nresource_use_end\n135.479993\n2.0\n0\ncomplete\nMINORS_registration\nMINORS_registration_2\n23\n\n\n45\n7\nNon-Trauma\nMINORS_examination_begins\nresource_use\n135.479993\n3.0\n0\nstart\nMINORS_examination\nMINORS_examination_3\n27\n\n\n47\n7\nNon-Trauma\nMINORS_examination_complete\nresource_use_end\n152.106294\n3.0\n0\ncomplete\nMINORS_examination\nMINORS_examination_3\n27\n\n\n48\n8\nNon-Trauma\ntriage_begins\nresource_use\n124.735469\n2.0\n0\nstart\ntriage\ntriage_2\n22\n\n\n50\n8\nNon-Trauma\ntriage_complete\nresource_use_end\n129.267277\n2.0\n0\ncomplete\ntriage\ntriage_2\n22\n\n\n\n\n\n\n\n\nlogs_transformed[(logs_transformed[\"run\"]==1) & (logs_transformed[\"activity_id\"]==26)]\n\n\n\n\n\n\n\n\npatient\npathway\nevent\nevent_type\ntime\nresource_id\nrun\nevent_stage\nevent_name\nresource_id_full\nactivity_id\n\n\n\n\n\n\n\n\n\n\nlogs_transformed[logs_transformed[\"activity_id\"]==26].sort_values('run').head(30)\n\n\n\n\n\n\n\n\npatient\npathway\nevent\nevent_type\ntime\nresource_id\nrun\nevent_stage\nevent_name\nresource_id_full\nactivity_id\n\n\n\n\n60\n10\nTrauma\ntriage_begins\nresource_use\n129.468902\n2.0\n0\nstart\ntriage\ntriage_2\n26\n\n\n62\n10\nTrauma\ntriage_complete\nresource_use_end\n165.815421\n2.0\n0\ncomplete\ntriage\ntriage_2\n26\n\n\n\n\n\n\n\n\nlogs_transformed.sort_values('activity_id').head(20)\n\n\n\n\n\n\n\n\npatient\npathway\nevent\nevent_type\ntime\nresource_id\nrun\nevent_stage\nevent_name\nresource_id_full\nactivity_id\n\n\n\n\n0\n1\nNon-Trauma\ntriage_begins\nresource_use\n3.285355\n1.0\n0\nstart\ntriage\ntriage_1\n1\n\n\n2\n1\nNon-Trauma\ntriage_complete\nresource_use_end\n7.364946\n1.0\n0\ncomplete\ntriage\ntriage_1\n1\n\n\n6\n2\nNon-Trauma\ntriage_begins\nresource_use\n3.289691\n2.0\n0\nstart\ntriage\ntriage_2\n2\n\n\n8\n2\nNon-Trauma\ntriage_complete\nresource_use_end\n9.407274\n2.0\n0\ncomplete\ntriage\ntriage_2\n2\n\n\n1\n1\nNon-Trauma\nMINORS_registration_begins\nresource_use\n7.364946\n1.0\n0\nstart\nMINORS_registration\nMINORS_registration_1\n3\n\n\n4\n1\nNon-Trauma\nMINORS_registration_complete\nresource_use_end\n15.418481\n1.0\n0\ncomplete\nMINORS_registration\nMINORS_registration_1\n3\n\n\n7\n2\nNon-Trauma\nMINORS_registration_begins\nresource_use\n9.407274\n2.0\n0\nstart\nMINORS_registration\nMINORS_registration_2\n4\n\n\n10\n2\nNon-Trauma\nMINORS_registration_complete\nresource_use_end\n17.104670\n2.0\n0\ncomplete\nMINORS_registration\nMINORS_registration_2\n4\n\n\n3\n1\nNon-Trauma\nMINORS_examination_begins\nresource_use\n15.418481\n1.0\n0\nstart\nMINORS_examination\nMINORS_examination_1\n5\n\n\n5\n1\nNon-Trauma\nMINORS_examination_complete\nresource_use_end\n31.636252\n1.0\n0\ncomplete\nMINORS_examination\nMINORS_examination_1\n5\n\n\n11\n2\nNon-Trauma\nMINORS_examination_complete\nresource_use_end\n32.875857\n2.0\n0\ncomplete\nMINORS_examination\nMINORS_examination_2\n6\n\n\n9\n2\nNon-Trauma\nMINORS_examination_begins\nresource_use\n17.104670\n2.0\n0\nstart\nMINORS_examination\nMINORS_examination_2\n6\n\n\n12\n2\nNon-Trauma\nMINORS_treatment_begins\nresource_use\n32.875857\n1.0\n0\nstart\nMINORS_treatment\nMINORS_treatment_1\n7\n\n\n13\n2\nNon-Trauma\nMINORS_treatment_complete\nresource_use_end\n46.278797\n1.0\n0\ncomplete\nMINORS_treatment\nMINORS_treatment_1\n7\n\n\n14\n3\nNon-Trauma\ntriage_begins\nresource_use\n33.426168\n1.0\n0\nstart\ntriage\ntriage_1\n8\n\n\n16\n3\nNon-Trauma\ntriage_complete\nresource_use_end\n33.545008\n1.0\n0\ncomplete\ntriage\ntriage_1\n8\n\n\n15\n3\nNon-Trauma\nMINORS_registration_begins\nresource_use\n33.545008\n1.0\n0\nstart\nMINORS_registration\nMINORS_registration_1\n9\n\n\n18\n3\nNon-Trauma\nMINORS_registration_complete\nresource_use_end\n42.359504\n1.0\n0\ncomplete\nMINORS_registration\nMINORS_registration_1\n9\n\n\n24\n4\nNon-Trauma\ntriage_complete\nresource_use_end\n37.914164\n2.0\n0\ncomplete\ntriage\ntriage_2\n10\n\n\n22\n4\nNon-Trauma\ntriage_begins\nresource_use\n37.900548\n2.0\n0\nstart\ntriage\ntriage_2\n10\n\n\n\n\n\n\n\n\nlogs_transformed[[\"event_name\", \"event_stage\", \"event_type\"]].value_counts()\n\nevent_name            event_stage  event_type      \ntriage                start        resource_use        622\n                      complete     resource_use_end    620\nMINORS_registration   start        resource_use        514\n                      complete     resource_use_end    512\nMINORS_examination    start        resource_use        475\n                      complete     resource_use_end    472\nMINORS_treatment      start        resource_use        264\n                      complete     resource_use_end    262\nTRAUMA_stabilisation  complete     resource_use_end     81\n                      start        resource_use         81\nTRAUMA_treatment      start        resource_use         79\n                      complete     resource_use_end     74\nName: count, dtype: int64\n\n\n\nlogs_transformed.event.value_counts()\n\nevent\ntriage_begins                    622\ntriage_complete                  620\nMINORS_registration_begins       514\nMINORS_registration_complete     512\nMINORS_examination_begins        475\nMINORS_examination_complete      472\nMINORS_treatment_begins          264\nMINORS_treatment_complete        262\nTRAUMA_stabilisation_begins       81\nTRAUMA_stabilisation_complete     81\nTRAUMA_treatment_begins           79\nTRAUMA_treatment_complete         74\nName: count, dtype: int64\n\n\nFor ease, now let’s save these results as a file that we can load into R.\nWe could use a csv for easy interoperability. Alternatively, we could use something like Feather or Parquet, which are usable by both R and Python while retaining data types.\nFor ease of use and long-term readbility, we will use csv in this case.\n\nlogs_transformed.to_csv('simulation_logs_for_bupar.csv', index=False)"
  }
]